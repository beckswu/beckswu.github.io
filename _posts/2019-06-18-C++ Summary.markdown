---
layout:     post
title:      "C++ Primer - 笔记"
subtitle:   "C++ Primer Summary "
date:       2019-06-18 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - Batch
    - 学习笔记
---


```c++
cout<<" File Name "<< __FILE__ << endl; //打印现在file name

cout<<" Line Number "<<__LINE__<<endl; //打印现在现在的行数

```

- function return reference 可以用non-reference 去接, non-reference 接的话借的是copy 
- namespace 中function 不是在class 但是声明了 static 是  give **internal linkage**, meaning that it is only accessible within the translation unit that contains the definition. Without static, it has external linkage, and is accessible in any translation unit. So you'd use static (or, alternatively, an unnamed namespace) when writing a function that's only intended for use within this unit; the internal linkage means that other units can define different functions with the same name without causing naming conflicts.

## Variable and Basic Types

<span style="background-color: #FFFF00">**Initialization is not assignment**</span>. Initialization happens when a variable is given a value *when it is created*.(创建变量时 赋予它一个初始值). **Assignment** obliterates an object's current value and replaces that value with a new one (
<span style="background-color: #FFFF00">把对象当前值擦除，用一个新值代替</span>)

#### Initialization, Definition, Declaration, Scope
 
**(1). List Initialization**

```c++
//下面四种初始化都正确

int units_sold = 0;
int units_sold = {0};
int units_sold {0};
int units_sold(0);
```

<span style="background-color: #FFFF00">List Initialization will throw error if the initializer might lead to the loss of information. (编译器将会报错，如果使用列表初始化且初始值存在丢失信息的风险).</span> 如果不用List Initialization 就不会, 会implicit convert


```c++
long double id = 3.1415026536;
int a{ld}, b = {ld}; //error: 存在丢失信息风险

int c(ld), d = ld; // 转化执行，但是丢失了部分值 (truncated)

```

**(2). Default Initialization**

Most classess let us define objects without <span style="color: red">explict initializers</span>. Such classes supply an appropriate default value. e.g. std:string empty; empty implicitly initialized to the empty string. 

Note: Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class.

**(3). Variable Declarations and Definitions**

 - <span style="background-color: #FFFF00">**A declaration makes a name known to the program. A definition creates the associated entity.**</span>
- A variable **declaration**  <span style="background-color: #FFFF00"> specifies the type and name of a variable</span>. A variable definition is a declaration. In addition to specifying the name and type, a **definition** also <span style="background-color: #FFFF00"> allocates storage and may provide the variable with an initial value</span>. 变量声明规定了变量的类型和名字，在这一点上定义与之相同. 但除此之外, 定义还申请存储空间, 也可能会为变量赋一个初始值
- <span style="background-color: #FFFF00"> Variable must be defined exactly once but can be declared many times</span> 变量只能被定义一次，但可以被声明多次
- 如果想声明一个变量而非定义它，在变量前添加extern

```c++
extern int i; //声明i而非定义i

int j; //声明并定义j
```

任何包含了显示初始化的声明既是定义. 给extern 表含的变量一个初始值，抵消了extern的作用

```c++
extern int i = 5; //定义
```

**(4). Nested Scopes**

<span style="background-color: #FFFF00"> 用 :: 访问global variable (explicitly request global variable) </span>

```c++
int reused = 42;
int main(){
    cout << resused <<endl; // 42

    int reused = 0; //新建局部变量，覆盖全局变量

    cout << resused <<" global " << ::resused <<endl; // 0 , 42

}
```




#### Compound Types

A **compount type** is a type that is defined in terms of another type, which is references and pointers

1. reference, pointer:
    - <span style="background-color: #FFFF00">等号两边类型(type)必须相同 </span> type modifier(&, \*) 不一定相同, <span style="background-color: #FFFF00">除了一个特殊情况 const reference</span>
         - 比如 ```double dval = 3.14;,int &refVal5 = dval;//error``` 
2. 对于const非reference 非pointer, 等号左右两边等号类型可以不同. 
3. **对于const reference 等号两边可以不同类型，compiler会做转换**  ```const double pi = 3.14; const int & i = pi;```


**Reference** At here, reference is only lvalue reference not rvalue reference

<span style="background-color: #FFFF00"> reference must be assigned at initlization, non-const reference 不能assign rvalue, must be lvalue </span>. 程序把引用和初始值绑定(bind)到一起，而不是将初始值拷给引用, 引用无法绑定到另一个对象. <span style="color: red"> **A reference is not an object**. Instead, a reference is just another name for an already existing object </span>


```c++
int val = 1024;
int &refval = val, &r = i; // correct

refval = 2; //val = 2

int &refval2; //error

int &refval3 = 10 ;//error: initializer must be an object

double dval = 3.14;
int &refVal5 = dval; // error: initializer must be an int object
```

We can define multiple references in a single definition

```c++
int i2 = 2048; // i and i2 are both ints 

int i3= 1024, &ri = i3; // i3 is an int;ri is a reference bound to i3 

int &r3 = i3, &r4 = i2; // both r3 and r4 are references
```


**Pointer**

- assign pointer <span style="color:red">需要assign 的类型和被assign 类型compatible</span>. 
- <span style="background-color:#FFFF00">**Pointer is a object whereas reference is not object**</span>
- <span style="background-color: #FFFF00">It is error to copy or try to access the value of an invalid pointer</span>. As when we use an uninitialized variable, <span style="color: red">this error is one that the compiler is unlikely to detect(编译器不会检查access invalid pointer)</span>. The result of accessing an invalid pointer is undefined. 
-  Given two valid pointers of the same type, we can compare them use<span style="background-color: #FFFF00"> the equality(==) or inequality(!=) operator, Two pointers are equal if the yhold the same address (两个指针存放的地址相同) </span>
- <span style="background-color: #FFFF00">修饰符 (type modifier \*)仅仅是修饰一个variable</span>,  而非修饰整行所有变量.  Each declarator can relate its variable to the base type differently from the other declarators in the same definition.```int* p1, p2```, p1 是 int pointer, p2 是int, , 如果两个都是pointer 用```int* p1, *p2```

```c++
double dval;
double *pd = &dval; //ok: initializer is the address of a doub;e

double *p2 = pd;//ok: initializer is a pointer to double

int *pi = pd;//error: types of pi and pd differ, 一个int,一个double

pi = &dval; //error: assigning the address of a double to a pointer to int

//上面两个error 都会compile fail


int dval;
double *pi = &dval;//error: types of pi and pd differ, 一个int,一个double, 也是compile error


```

<span style="background-color:#FFFF00">& 赋值是改变等号左侧 pointer指代对象, \* 不改变指代对象，改变的是指代对象的值 </span>
```c++
int r = 1;
int *p = &r;
int *p2 = p;
    
*p2 = 10; //change pointed value, aslo change value of the object pointer points to

cout << *p <<" , "<<*p2  <<" , "<< r <<endl; //print 10 ,10, 10

int c = 5;
p = &c; //change object that pointer points to

cout << *p  <<" , "<< r <<" , "<< c<<endl;//print 5, 10 , 5

```

```c++
int i = 1024, *p = &i, &r = i;// i is an int; p is a pointer to int; r is a reference to int

int* p1, p2;//p1 is a pointer to int; p2 is an int (not pointer), 

//上面的*， 仅仅修饰了p1, 而非让所有变量的类型一样都是int pointer

int *p1, *p2; // both p1 and p2 are pointers to int
```


**void pointer**: <span style="background-color: #FFFF00">A void* pointer holds an address, but the type of the object at that address is unknown:  </span>. Generally,we use a void* pointer to deal with memory as memory, rather than using the pointer to access the object stored in that memory. 



**Pointers to Pointers**

```c++
int ival = 1024;
int *pi = &ival; // pi points to an int

int **ppi = &pi; // ppi points to a pointer to an int


cout << "The value of ival\n"
    << "direct value: " << ival << "\n" 
    << "indirect value: " << *pi << "\n"
     << "doubly indirect value: " << **ppi << endl;//print 1024, 1024, 1024

```

**References to Pointers**: A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer:


```c++

int i = 42; 
int *p; //p is a pointer to int

int *&r = p;  // r is a reference to the pointer p

//cannot write as  int &*r = p; 

//because reference(not object) don't have pointer, but pointer has reference


r = &i;// r refers to a pointer; assigning &i to r makes p point to i

*r = 0; 
// dereferencing r yields i, the object to which p points; changes i to 0


```

<span style="background-color: #FFFF00"> **离变量名最近的符号(symbol， 上面例子 &r 的符号& ) 对变量类型有最直接的影响, 因此r是一个引用;**</span>

#### Const Qualifier

1. 非reference, 非 pointer,Const Initialize时候 等号两边type可以不一样, e.g. 
    - ```int a = 0; const double b = a;```
    - ```double a = 0; const int b = a;```
2. reference or pointer, Const Initialize时候 等号两边type 必须strictly 一样

**(1). Reference**

1. ```const```value 必须initialize when define 
2. **Const Value-Value**: 
    - **non const -> const**  value e.g.```int val = 5; const int cst = val;```, <span style="background-color:#FFFF00"> 因为const value是通过复制生成，改变原来值，不会改变const value值</span> e.g. ```int val = 3; const int cstRef = val;val = 10;```, ```cstRef = 3``` , ```val = 10``` 
    - **const -> non const**  const (reference or without reference)  initilize non const value; ```const int & cstRef = 3; int val = cstRef```.
3. **Const Ref-Ref**:
    - **Const Ref -> Ref**  <span style="color:red">**Error**</span>  <span style="background-color:#FFFF00"> const reference 不能bind 到non-const reference，因为reference is not object </span> ```const int & ref = 3; int &i = ref; \\error```,
    - **Ref -> Const Ref** ✔️ ```int val = 3; int & ref = val; const int &cstRef = ref;```
4. **Ref-Value**:
    - **Ref -> Const Value** ✔️, ```int val = 3; int & ref = val; const int cstRef = ref;```
    - **Const Value -> Ref** <span style="color:red">**Error**</span> ```const int cstRef = 3; int & ref = cstRef;```, 因为Referene 不是object, 这么做有更改Const 可能性
    - **Const Ref -> Value** ✔️, ```const int & cstRef = 3; int val = cstRef;```
    - **Value-> Const Ref** ✔️, ```int val = 3; const int & cstRef = val;```
    - **Const Ref -> Const Value** ✔️,```const int & cstRef = 5;const int val = cstRef;```
    - **Const Value -> Const Ref** ✔️,```const int val = 5;const int & cstRef = val;```
5. ```const reference```, 如果type 不匹配 or 用rvalue expression, 会生成一个**temporary object**, 这样如果改了原来的值, ```const reference```不会改 (因为```const reference```连得是temporary object) e.g. ```double val = 3.14; const int & cstRef = val; ```
    - 如果不是const reference, ```double val = 3.14; int & cstRef = val;  ``` 因为没有**中间值**生成, 改变```val```的值,有改变const reference 风险, <span style="color:red">**Error**</span>
6. ```const reference```生成后 <span style="background-color:#FFFF00">不能直接更改，但可能会被间接更改(没有temporary object生成)</span> ```int val = 3;const int & cstRef = val;val = 10;``` , ```val = cstRef = 10```


const value 必须initialize when define 

```c++
const int i = get_size(); // ok: initialized at run time 

const int j = 42; // ok: initialized at compile time 

const int k; // error: k is uninitialized const

```
 
const value 可以生成non const value (反之也可以), 但是const reference 不可以生成 nonconst reference (nonconst reference 可以生成const reference)
```c++
int val = 42;
const int cst = val; // ok: nonconst val -> const val

const int &  cstRef = val;
int jVal= cst; // ok:const val -> nonconst val

int & jRef = cstRef; //error const Ref -> non const Ref

int &jVal2 = val;
const int & cstRef2 = jVal2; //ok: non const Ref -> const Ref

```

```const int bufSize = 512;``` <span style="color: red"> the compiler will usually replace uses of the variable with its corresponding value during compilation.</span> That is, the compiler will generate code using the value 512 in the places that our code uses bufSize. Compiler会找到代码中所有用到bufSize的地方，然后用512代替。


```c++
//不能用非const reference 指向const object

const int ci = 1024;
int &r2 = ci;// error: non const reference to a const object

int i = 42;
```

**One exception for const references**: initailize const from any expression that can be converted to the type of the reference. <span style="background-color: #FFFF00">当initilize const reference, 我们可以用任意表达式. </span>

```c++
int i = 42;
const int &r1 = i; // we can bind a const int& to a plain int object 

const int &r2 = 42; // ok: r1 is a reference to const

const int &r3 = r1 * 2; // ok: r3 is a reference to const

int &r4 = r1 * 2; // error: r4 is a plain, non const reference

```
to understand this exception in initialization rules:

```c++
double dval = 3.14;
const int &ri = dval; //okay,

dval = 6.28;
cout<<ri << ","<<dval<<endl; //print 3, 6.14


int Ival = 5;
const int & ri2 = Ival; //okay,
const int & ri3 = Ival*2; //okay,
    
Ival = 30;
cout<<ri2<<" ,"<<ri3 << ","<<Ival<<endl; //print 30, 10, 30

```

上面例子中.To sure object to which ```ri``` is bound is an int, compiler transforms the code into something like (但不适用```ri2```, 因为initialize ```ri2```时, 没有生成temporary object). In this case, ```ri``` is bound to a **temporary object**. A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. 

```c++
const int temp = dval;//create a temporary const int from the double

const int &ri =temp;//bind ri to that temporary

const int temp2 = Ival*2;//create a temporary const int from the int

const int &ri3 =temp2;//bind ri to that temporary

```


**A Reference to const May Refer to an Object That Is Not const**: 当```const reference```initialized时, 并没有generate **temporary object**, 可能会被间接更改```const refernce```的value

```c++
int i = 42;
int&r1=i; //r1 boundto i

const int &r2 = i; //r2 also bound to i; but cannot be used to change i


r1=0; // r1 is not const; i is now 0
//r2 = 0;//error: r2 is a reference to const

cout<<i<< ", "<<r1<<", "<<r2<<endl; //print 0, 0 , 0

```

**(2). Pointer and const**

1. Level Const
   - **low-level const**(object is const): const <span style="background-color: #FFFF00">在pointer 左面</span>表data is const, cannot change underlying data value. but can point to different underlying. <br/>
   - **top-level const**(pointer is const): const <span style="background-color: #FFFF00">在pointer 右面有pointer在时候表示 pointer is const (**a const pointer**), 如果没有pointer 在表示数据const (```const int a = 0```</span>, 不能改变指向对象，但可以改变the value of underlying object)
2. <span style="background-color: #FFFF00">The distinction between **top-level** and **low-level** matters when we copy an object</span>. When we copy an object, **top-level consts can be ignored:** e.g. ```const * const int = const * int```
    -  <span style="background-color: #FFFF00">对于pointer之间的copy, 如果忽略Low Level const</span>, <span style="color:red">**Error**</span> 
       - **Pointer of Const -> Pointer**:  <span style="color:red">**Error**</span> e.g. ```int val = 42; const int * p3Low = val;int * p3 = p3Low;//error```
       - **Const Value -> Pointer**  <span style="color:red">**Error**</span> e.g. ```const double cstVal = 3.14; double *ptr = &cstVal; //error```
       - **Const Pointer -> Pointer**:✔️ 因为可以忽略top-level constant <span style="color:red">**Error**</span> e.g. ```int i = 0; int * const p = &i; int *a = p;```
    - 对于value 到 const pointer 的copy, 可以忽略low-level const
       -  **Value -> Const Pointer** ✔️  e.g. ```int val = 1; int const * const pLowTop = & val;```
       -  **Const Pointer -> Value** ✔️ ```int j = 0; const int * cstPtr = & j; int val = *cstPtr;```
       -  **Pointer -> Const Pointer** ✔️ ```int i = 0, *a = & i; const int * const p = a;```
3.  The types of a pointer and the object to which it points must match(等号左右两边类型必须match). 


```c++
int i = 0;
int *const p1Top = &i; // const is top-level; we can't change the value of p1Top

const int ci = 42; //  const is top-level; we cannot change ci

const int *p2Low = &ci; //  const is low-level; we can change p2Low

const int *const p3LowTop = p2; // right-most const is top-level, left-most is not

const int &r = ci; // const in reference types is always low-level


//top level constant can be ignored

i = ci; // ok: copying the value of ci; top-level const in ci is ignored 

p2Low = p3LowTop; // ok: pointed-to type matches; top-level const in p3LowTop is ignored


```

<span style="background-color: #FFFF00">On the other hand, low-level const is never ignored.(lower-level 从不会被忽略)</span>.  When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects(拷贝 输出对象必须具有相同的底层const 资格). In general, we can convert a nonconst to const but not the other way round:

```c++
int *p = p3LowTop; // error: p3LowTop has a low-level const but p doesn't

p2Low = p3LowTop; // ok: p2Low has the same low-level const qualification as p3LowTop

p2Low = &i; // ok: we can convert int* to const int*

int &r = ci; // error: can't bind an ordinary int& to a const int object 

const int &r2 = i; // ok: can bind const int& to plain int

```

The first exception is that we can use a pointer to const to point to a nonconst object: 可以用const pointer指向non-const object

```c++
const double cstVal = 3.14; // pi is const; its value may not be changed

double *ptr = &cstVal; // error: ptr is a plain pointer

const double *cptrLow = &cstVal; // ok: cptr may point to a double that is 

*cptrLow = 42; // error: cannot assign value to *cptr

double dval = 3.14; // dval is a double; its value can be changed
 
cptrLow = &dval; // ok: but can't change dval through cptr

```

```c++
double pi = 3.14159;
const double *const pip = &pi; 
// pip is a const pointer (在pointer右边的const) to a const object

```

#### Constexpr

A **constant expression**: value cannot change and can be evaluated at compile time. A **literal** is a constant expression. By delcaring **constexpr**, we can ask compiler to verify that a variable is a constant expression.  

Const 的缺点, 有时候我们需要**constant expression**, 但用**const**, 生成却不是**constant expression**. 比如, 下面例子even though```sz``` is a ```const```, the value of its initializer is not known until <span style="color:red">run time</span>
```c++
const int limit = 20;
//limit is a constant expression

const int sz = get_size(); 
//sz is not a constant expression

constexpr int sz2 = get_size(); 
//只有当get_size() is a constexpr function, sz2才是constexpr function

```

The type we can use in a **constexpr** declaration are known as **literal types**.
- <span style="background-color: #FFFF00"> arithmetic, reference, pointer types are **literal types**</span>, 
- <span style="background-color: #FFFF00"> 自己定义的class, **string** types 不是**literal types**, 不能用于define varaibles as **constexpr**</span>. varaibles defined inside a function 因为没有fixed address, 不能用**constexpr**,
- The **address** of an object defined  <span style="color:red">outside</span> of any function is **constant expression**, and **some objects have fixed address** so may used to initialzie a **constexpr** pointer.

- **Pointers and constexpr**

```c++
const int * p = nullptr; 
//p is a pointer to a const int (low level)

constexpr int * q = nullptr
//q is a const pointer to int (top level)

```
p and q are quite different. The difference is ```constexpr``` imposes a ```top-level const``` on pointer

```c++
constexpr int * pTop = nullptr; 
//pTop is a constant pointer to int that is null

const int tempInt = 10;
pTop = & tempInt; //Error, cannot assign const int to int * const


int j = 0;
constexpr int i = 42; // i is const int

constexpr const int * pLowTop = &i; 
// pLowTop is const pointer to the const int i

constexpr int * p1Top = & j
//p1Top is a const pointer to the int j

constexpr int * pTop2 = &i; 
// error, fix it is const int * pLow = & i

```

#### Type Aliases

**Type Alias** is a name that is a synonym for another type 

1. **typedef**: ```typedef double wages```, typedef can also include type modifiers (such as reference, pointer) that define compound types 
2. **using**: ```using SI = Sales_item;```

**Pointers, Const, and Type Aliases**

```c++
typedef char *pstring;
const pstring cstr = 0; 
//cstr is a constant pointer to char

//是pointer const， 而不是数据类型data type是const 

const pstring* ps; //ps is a pointer to a constant pointer to char

```

```const pstring```(不等于 ```const char * ```) is constant pointer to char, not a pointer to ```const char```, <span style="color:red">如果直接replace the alias with its correspoinding type 是错误的, **Error**</span>, 如果想要pointer to ```const char```, 需要重新定义```typedef const char * pstring```


#### Auto 

- **auto** tells the compiler to deduce the type from the initializer. By implication, a variable that uses **auto** as its type specifier must have an initializer.
- **auto** can define multiple variables in single line, 但是initializers for all the variables in the declaration must <span style="background-color: #FFFF00">have types that are consistent</span>
- **auto** is not always exactly the same as initializer types. 当用auto时候，<span style="background-color: #FFFF00">top level const通常会被忽略, low-level const 会被kept</span>, 
- 用**```auto &``` or ```auto*``` ** to auto-deduced type, <span style="background-color: #FFFF00">会keep top level, low-level const</span>
- 不能用**auto** to deduce from the type from a list of initializer ```auto a = {1,2,3}; \\error```

可以定义多个variables in single line, 但是需要都是一个类型(type)的
```c++
auto i = 0, *p = &i;
//okay i is int and p is pointer to int

auto sz = 0, pi = 3.14; 
//error: inconsistent type for sz and pi

```

忽略top-level const and keep lower-level const 
```c++
int i = 0, &ref = i;
auto a = ref; // a is an int


const int cval = i, &cstRef = cval;
auto b = cval; //b is an int (top-level const dropped)

auto c = cstRef; //c is an int& (cr is an alias for cval whose top-level const dropped)

auto d = & i; //d is an int*

auto e = &cval; 
//e is const int * (& of a const is low-level const)

```

auto + reference
```c++
auto & g = cval; // g is a const int & 

auto & h = 42; //error, can't bind a plain reference to a literal

const auto & j = 42; //const reference

```

Deduced 的type 必须consistent 
```c++
auto k = cval, &l = i; // k is int, l is int& 

auto & m = cval, *p = & cval;
//m is const int&, *p 是  const int * (a pointer to const int)

auto &n = i, *p2 = & cval;
//error, n is int&, p2 is const int * (not int*)

```

#### Decltype 

- **decltype**: compiler analyzes the expression to determine its <span style="background-color: #FFFF00">type</span> but does <span style="background-color: #FFFF00">not evaulate the expression </span>
- handles **top-level const** subtly different from **auto**
    - **variables**: <span style="background-color: #FFFF00">include **top-level const** and reference</span>
    - **expression**: we can get the type that expression yields. <span style="background-color: #FFFF00">注:Dereference operator(\*) yields type as reference</span>
    - **decltype** and **auto** difference: deduction done by **decltype** depends on the form of its expression. 
        - <span style="background-color: #FFFF00">切记```decltype((variable))```结果永远是引用，```decltype(variable)``` 只有当variable 本身是引用时, 结果才是引用</span>

compiler 不会called ```f```, 但是uses the type that such a call would return as type of ```sum```. 

```c++
decltype(f()) sum = x; //sum has whatever type f returns 

```

use decltype for variable, returns type including **top-level const**

```c++
const int cval = 0, & cRef = cval;
decltype(cval) x = 0; //x is const int

decltype(cRef) y = x; //y is const int& 

decltype(cRef) z;//error: z is const int& which must be initalized

```

use decltype for expression. ```decltype(r)``` is a reference type. but ```r+0``` is an expression that yieds a **nonreference type**. **Dereference operator** is an example of an expression for ```decltype``` returns a **reference**. When we deference a pointer, we get the object to which the pointer points  ```decltype(*p)``` is ```int&``` not ```int```.

```c++
int i = 42, *ptr = & i, &ref = i;
decltype(r + 0) b; //addition yields an int, b is int (uninitialized)

decltype(*p) c; //error: c is int& and must be initialized

```

当我们apply ```decltype``` wrap the variable's name in one ore more parentheses, compiler will evaluate the operand as an expression. A variable is an expression that can be the left-hand side of an assignment. As a result, ```decltype``` on such an expression yields a reference.


```c++
decltype((i)) d; //error: d is int& and must be initialized

decltype(i) e;//ok: e is an int (uninitialized)

```

<br/>

## Strings, Vectors, and Arrays

#### Namespace using Declarations

- ```std::cin``` use the **scope operator(::)** says want to use the name ```cin``` from the namespace ```std```
- ```using namespace::name``` : A **using declaration** let us use a name from a namespace without qualifying the name with a ```namespace_name:: ```prefix
- <span style="background-color: #FFFF00"> Headers should not not include using declarations</span>. 原因: the contents of a header are copied into the including program's text. If a header has a ```using``` declaraction. 那么every program that includes that header gets that same ```using``` declaraction. As a result, program didn't intend to use the specified library name <span style="color:red">might encounter unexpected name conflicts.</span>

#### String 

**(1). Initialization**

- ```string s2(s1)``` ```s2``` is a copy of ```s1``` 
- ```string s2 = s1``` 与```s2(s1)``` 作用一眼
- ```string s3("value")``` ```s3``` is a copy of **string literal**， not including the null(null在const char\*的结尾处)
- ```string s3 = "value"```, 与```string s3("value")```一样, copy of **string literal**
- ```string s4(n,'c')```, initialize ```s4``` with n copies of character ```c```

用```=``` 初始化叫做**copy initialization**, 忽略等号的初始化 是**direct initialization**

```c++
string s5 = "hiya"; //copy initilization 

string s6("hiya"); //direct initialization

string s7(10, 'c'); //direct initialization

```
**(2). Getline**

we can use ```getline``` function instead of ```>>``` operator. This function reads the given stream up to the end of the line (*not including the newline*) to store in string.  

```c++
string line 
//read input a line at a time untile end-of-file

while(getline(cin,line)) // or use while(cin >> line)
    
    if(!line.empty())
        cout << line << endl;
```

**(3). compare**

1. 如果两个strings 长度不一样 且 每个位置char都一样, 那么较短的string ```< ``` 较长的
2. 如果有位置不一样, 那么对比那个位置两个char, 根据字母表，靠前的char的string 更小

```c++
string str = "Hello";
string phrase = "Hello World";
string slang = "Hiya";
//str < phrase, phrase < slang 

```

**(4). Adding Literals and strings**

当我们用string + character literals时,<span style = "background-color:#FFFF00"> 必须保证```+```号左右两侧至少有一个是string type </span>

```c++
string s1 = "hello";
string s4 = s1 + ", "; // ok: adding a string and a literal 

string s5 = "hello" + ", "; // error: no string operand string

s6 = s1 + ", " + "world"; // ok: each + has a string operand string

s7 = "hello" + ", " + s2; // error: can't add string literals

//因为 s7 = ("hello" + "), " + s2; ("hello" + ") no strings

```

**(5). Dealing with char in string**

- ```isalnum(c)```: true if c is a letter or digit
- ```isalpha(c)```: true if c is a letter
- ```iscntrl(c)```: true if c is a control character. <span style="color:red">A control character is a character that does not occupy a printing position on a display. 比如换行 ```\n``` </span>
- ```isdigit(c)```: true if c is a digit
- ```isgraph(c)```: true if c is not a space but is printable, <span style="color:red">A graph character是可以用来打印的character, 除了空格</span>
- ```islower(c)```, ```isupper(c)```: true if c is a lowercase/upper letter 
- ```isprint(c)```: true if c is a printable character. <span style="color:red">printable character =  space + graph character </span>
- ```ispunct(c)```: true if c is punctuation character (不是control character, a digit, a letter or a printable whitespace)
- ```isspace(c)```: true if c is whitespace(i.e. a space, tab, vertical tab, return(回车符), newline(换行符), or formfeed)
- ```isxdigit(c)```: true if c is 十六进制(hexadecimal digit)
- ```tolower(c)```, ```toupper(c)```: 如果c是大/小写字母, 变小/大写, 否则不变

**(6). Change char in string**

use for loop and reference 
```c++
string s("Hello World!!!");
for (auto &c : s) // for every char in s (note: c is a reference)

    c = toupper(c); 
cout << s << endl;
```

#### Vector

We can define ```vector``` to hold objects of most any type. Becauses <span style="background-color:#FFFF00"> references are not objects, **we cannot have a vector of references** </span>

**(1). Initialization**

- ```vector<T>v1```: vector hold objects of type T and v1 is empty 
- ```vector<T>v2(v1)```: v2 has a copy of each element in v1
- ```vector<T>v2 = v1```: v2 is copy of the each element in v1
- ```vector<T>v3(n,val)```: v3 has n elements with value val
- ```vector<T>v4(n)`1`: v3 has n copies of a  <span style="color:red">value-initialized object</span>(e,g, int 默认是0, string 默认是空)
- ```vector<T>v5{a,,b,c...}```: v5 has as many elements as initializers;  <span style="color:red">elements are initialized by corresponding initializers</span>
- ```vector<T>v5 = {a,b,c}```; 与上面一样

 
当我们提供两个数, 比如 对于```vector<int>```, 两个数可以表示size and value, 也可以表示size 为2的两个intial values, 用花括号或者方括号会有歧义. 这时<span style="background-color:#FFFF00">  ```()```are used to construct object whereas ```{}``` is use to initialize the object,</span> . 对于```vector<string>```, ```{}```,<span style="background-color:#FFFF00"> 如果compiler 发现```{}``` 不能initialize object, 会尝试去```()```来代替```{}```initialize</span> 

```c++
vector<int>v1(10,1); //initialize vector 10 个 1

vector<int>v2{10, 1}; //initialize vector 包括 10 和 1

vector<string>v3("hi"); //error


vector<string>v4{10}; //有10个默认的string

vector<string>v5{10, "hi"}; //有10个"hi"

//v4 and v5 the initializers can't be element initializers. 

//compiler looks for other ways to initialize the object from given values

```



如果用copy constructor, 需要type consistent,
```c++
vector<int>ivec;
vector<string>svec(ivec); //error

```

要使用```size_type```, 需要注明类型
```c++
vector<int>::size_type; //正确

vector::size_type; //错误

```

**(2) Vector Grow Efficiently***

**Key Concept: Vector Grow Efficiently**: 定义空的vector 更有效. <span style="background-color:#FFFF00">It is often unnecessary- can result in poorer performance—to define a vector of a specific size (例外是all elements actually need the same value).</span> It is more **efficient** to define an <span style="background-color:#FFFF00">**empty vector and add elements**</span> as the values we need become known at run time.

for loop vector 不能改变vector的大小(size) (add, delete)


#### Iterators

All of library **containers** have **iterators**. but only a few of them support the subscript operator 

- ```begin``` returns an iterator that deontes the first element. <span style="background-color:#FFFF00">如果object是const, 返回的是```const_iterator```,如果object不是const, 返回的是```iterator```</span>
- ```end``` position **one past the end** (尾元素的下一个位置), does not denote an element, 所以 <span style="color:red">it may not be incremented or deferenced</span>
- if a vector is const, 只能使用 ```const_iterator```type. Within a non const vector , we can use either ```iterator``` or ```const_iterator```
- ```>, >=, <, <=``` Iterator 比较, 如果Iterator refer的element 另一个iterator 指得element 在前面出现, 就是小于

```c++
vector<int>::iterator it;
string::iterator it2;//it can read and write

vector<int>::const_iterator it3; //it3 can read but not writer


const vector<int>cv;
auto it1 = cv.begin(); //return vector<int>::const_iterator

auto it3 = v.cbegin(); // eturn vector<int>::const_iterator

```


**(1). Dereference and Member Access**

```(*it)->member``` is a synonym as ```it->member```

```c++
(*it).empty() //dereference it and calls the member empty on object

*it.empty // error: attempts to fech the the member empty from iterator 

//but iterator has no member named empty

```
**(2). Some vector Operations Invalidate Iterators**

比如vector insert 也许会invalidate iterators: It is import to realize 当用iterator loop 不要add remove elements to the container which iterator refer. 


#### Arrays

- Unlike **vector**, <span style="background-color:#FFFF00">**array** have fixed size; we cannot add elements to an array. </span>
- 因为arrays have fixed size, they sometimes offer better run-time performance for specialized applications, 但是相应也损失了一些灵活性(flexibility)
- array size是part of array's type. The dimension must be known at compile time, which is [**constant expression**](#Constexpr)
- 默认值初始化会令数组含有未定义的值 (a default-initialized array of )
- As with vector, arrays hold objects. <span style="background-color:#FFFF00">Thus **there are no array of references**, 但可以有reference to array</span>.
- <span style="background-color:#FFFF00">When define an array, we must specify a type. We cannot use **auto** to deduce the type from a list of initializers</span>

```c++
unsigned cnt = 42; //not constant expression

constexpr unsigned sz = 42; //constant expression

int arr[10]; // array of 10 ints

int *parr[sz]; // array of 42个 pointers to int 

string bad[cnt]; //error: cnt is not constant expression

string strs[get_size()]; //okay if get_size is constexpr, error otherwise

```

**(1). Initializaing Array Element**

- 如果用list initialize the elements in array, 可以忽略维度. 
    - <span style="background-color:#FFFF00">If we omit the dimension, the compiler infers dimension from the number of initializers, </span>
    - <span style="background-color:#FFFF00"> 如果specify a dimension, the number of initializers 不能超过 the specified size.</span>
- ```char arrays``` are special to have an additonal form. <span style="background-color:#FFFF00">can initialize from a string literal and string literals end with a **null character** </span>. That null character is copied into the array along with the characters in the literal. <span style="background-color:#FFFF00">用list initialization， 需要声明```\0```否则不会加上, 如果不用string literal, 会自动加上```\0``` </span>
- <span style="background-color:#FFFF00"> cannot initialize an array as copy of another array. 也不能assign one array to another </span> 有一些compiler 允许array assignment as a compiler extension. 但是最好不要用这种nonstandard方法


```c++
const unsigned sz = 3;
int ia1[sz] = {0,1,2}; //array of 3 inits with invalue 0, 1, 2

int a2[] = {0, 1, 2};  //array of 3 dimension3

int a3[5] = {0, 1, 2}; // equivalent to a[3] = {0,1,2,0,0}

string a4[3] = {"hi", "bye"}; // same as a4[] = {"hi", "bye", ""}

int a5[2] = {0,1,2}; // error: too many initializers

```

char array initialization
```c++
char a1[] = {'C', '+', '+'}; // list initialization, no null

char a2[] = {'C', '+', '+', '\0'}; // list initialization, explicit null 

char a3[] = "C++"; // null terminator added automatically

const char a4[6] = "Daniel"; // error: no space for the null!

```

不能用copy initialize, 也不能assign array to another 
```c++
int a[] = {0, 1, 2}; // array of three ints

int a2[] = a; // error: cannot initialize one array with another 

a2 = a; // error: cannot assign one array to another

```

**(2). Understanding complicated Array Declarations**

因为an array is an object, we can define both pointers and references to arrays. Define arrays that hold pointer 比较直接, defining a pointer or reference to an array 稍微复杂. <span style="color:red">简单方法是从inside括号 from outside 再从右向左度，离变量近的类型对变量有直接影响</span>

- ```int *arrayPtr[10];```,  是array, size 为10, 有10个 pointer to int
- ```int (*Parray)[10];```, 是pointer, 指向 size 为10 的 int array
- ```int (&arrRef)[10];```, 是reference, refer size 为10 的 int array
- ```int *(&arry)[10] = ptrs```, 是reference, refer size 为10的array, array hold pointer to int

```c++
int *arrayPtr[10]; //arrayPtr is an array of 10 个 pointers to int 

int &refs[10] = ...; //error: no arrays of references

int (*Parray)[10] = & arr; //Parray 是pointer points to an array of 10个 int

int (&arrRef)[10] = arr; //arrRef refers to an array of 10 个 ints

```

**(3). Access the Elements**

当我们use a variable to subscript an array, we should define variable to have type ```size_t```, it defined in the ```cstddef```header, which is the c++ version of ```stddef.h``` header from C library. The difference between array and vector subscript 是 subscript operator```[]```` used in vector 只能applies to operands of vector, 而array subscript operator 是C++ 语言自己定义的

```c++
unsigned scores[11] = {};
for(auot i: scores)
    cout<<i<<endl;
```

**(4). Pointers and Arrays**

- <span style="background-color:#FFFF00">when we use an array, compiler 通常converts the array to a pointer</span>
-  We can obtain a pointer to an array element by taking the address of that element using address-of operator(```&```); e.g. ```int nums[] = {1,2,3}; int * p = &nums[0];```
- <span style="background-color:#FFFF00">when we use an object of array type, we are really using a pointer to the first element in that array</span>, array实际上是指向第一个element的pointer, operations on pointer.
    - <span style="background-color:#FFFF00">当我们用array as an initializer, defined using auto, the deduced type is a pointer, not an array </span>
    - <span style="background-color:#FFFF00">但是用到```decltype```, 还是会deduced 出array, 不会是pointer</span>
- 可以用 pointer initialize vector ```int arr[] = {0,1,2,3,4,5}; vector<int>iv(begin(arr), end(arr)); vector<int>iv2(arr + 1, arr+4);```, ```iv2```的vector分别来自```arr[1], arr[2],arr[3]```


```c++
string nums[] = {"one", "two", "three"}; // array of strings 

string *p = &nums[0]; // p points to the first element in nums

string *p2 = nums; // equivalent to p2 = &nums[0]

```

用array as intializer for **auto**, deduced type是pointer, not array 

```c++
int ia[] = {0,1,2,3,4,5}; // ia is an array of ten ints

auto ia2(ia); //ia2 is an int* that points to the first element in oa

ia2 = 42; // error : ia2 is a pointer, can't assign an int 

auto ia3(&ia[0]); //now it's clear that ia3 has type int*

```

decltype(array) is array

```c++
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; // decltype(ia)  is array not pointer

int i = 0, *p = &i;
ia3 = p; // error: can't assign an int* to array 

ia3[4] = i; // ok: assigns the value of i

```

**(5). Pointers Are Iterators**

Pointers to array elements (array) support the same operations as **iterators** on vector and string. We can use pointers to traverse the elements in an array.Array的```begin``` 和 ```end``` 返回的是pointer of object


```c++
int arr[] = {0,1,2,3,4,5};
int *p = arr; // p points to the first element in arr

++p; // p points to arr[1]

int *begin = begin(arr);//pointer to the first element in arr

int *last = end(arr); // pointer one past the last element in arr

```

**(6). Pointer Arithmetic**

- 当add an integer to a pointer(array), the result is a new pointer, the new pointer points to the element the given number ahead of (or behind ) the original pointer. 当用两个pointers 相减, 得到the distance between those pointers. The pointers must point to elements in the same array 
- <span style="background-color:#FFFF00">我们可以比较两个指针, 当这两个指针来自于同一个数组</span> ```int * b = arr, *e = arr + 5; if(s<e)...```, 如果不来自同一个数组, 不能比较, 因为比较毫无意义
- 指针运算. The result of subtracting two pointers a library type named ```ptrdiff_t```, like ```size_t```, the ```ptrdiff_t``` type is a machine-specific type and is defined in the cstddef header, 因为相间可能有negative distance, <span style="background-color:#FFFF00">```ptrdiff_t``` is a signed integral type.</span> 
- 可以用pointer +/- 整数, 再deference resulting pointer, ```int last = *(arr + 4); ``` 括号是必须的当deference from pointer arithmetic
- <span style="background-color:#FFFF00">`**we can use subscript operator on any pointer as long as thet pointer points to  an element (or one past the last element) in an array, 可以用+/- number 用作subscript**</span>
    - Array 和 vector/string subscript operators 不同是, <span style="color:red">`the library types(vector/string) force the index with **unsigned**, 但是built-in subscript operator 可以是negative value(is not an unsigned type)</span>

```c++
constexpr size_t  sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip=arr; //equivalent to int *ip = &arr[0];

int *ip2 = ip + 4;//ip2 points to arr[4], the last element in arr

int *ip3 = ip + 10;//error : arr has only 5 elements

auto n = end(arr) - begin(arr); // n is 5, the number of elements in arr

```

比较指针

```c++
int *b = arr, *e = arr + sz; 
while (b < e) {
    // use *b ++b;

}

int i = 0, sz = 42;
int *p = &i, *e = &sz;
while (p < e)
    // undefined: p and e are unrelated; comparison is meaningless! 

```

上面的也同样适用于null pointer and for pointers that point to an object that is not an array(两个指针必须指向同一个对象or 该对象下一个位置). if ```p``` is null pointer, 可以加减integral constant expression whose value is 0 to p. 我们也可以用null pointer 减去null pointer = 0

Deference
```c++
int ia[] = {0,2,4,6,8}; // array with 5 elements of type int

int last = *(ia + 4); // ok: initializes last to 8, the value of ia[4]

//括号是必须的

int last2 = *ia + 4; // = 0(ia[0]) + 4 = 4
```

subscript operator
```c++
int arr[] = {0,2,4,6,8};
int *p = arr+2; //p points to the third element in arr

int j = p[1]; // p[1] = *(p+1); = arr[3] = 6;

int k = p[-2]; // p[1] = *(p-2); = arr[0] = 0;
```
 
**(7). C-Style Character Strings**

- C-style strings are not a type, 而是convention to use character strings. Strings that follow this convention 储存在character arrays and **null terminated \0** 
- C library string.h provides a set of functions 在C++中 functions 被定义在 cstring header
    - ```strlen(p)```: 返回p的长度, <span style="color:red">not counting the null</span>
    - ```strcmp(p1,p2)```: compares p1 and p2 for equality. Returns 0 if p1 == p2, a positive value if p1 > p2, a negative value if p1 < p2
    - ```strcat(p1,p1)``` : Appends p2 to p1. Returns p1. <span style="color:red">p1必须large enough to hold result </span>
    - ```strcpy(p1,p2)``` : copies p2 into p1. Returns p1. <span style="color:red">p1必须large enough to hold result</span>


用strlen 必须有```\0``` terminate. 如果没有 null terminated, the result is undefined. The most likely effect of  this is that ```strlen``` will keep looking through the memory taht follows ```ca``` until it encounter a null character
```c++
char ca[] = {'C', '+', '+'}; // not null terminated

cout << strlen(ca) << endl; // disaster: ca isn't null terminated

```

Compare string: when we use an array, we really use a pointer to the first element in the array. 下面例子因为pointer do not address the same object, so the comparison is undefined. 我们可以用 ```strcp```对比const char array的content
```c++
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if (ca1 < ca2) // undefined: compares two unrelated addresses


if (strcmp(ca1, ca2) < 0) // same effect as string comparison s1 < s2

```

concat： 对于string, 可以直接用加号, 但是<span style="color:red">doing the same with two arrays would be an error.</span>. 因为expression tries to add two pointers which is illegal and meaningless.  如果largeStr不足够大, 很有可能引发error.如果我们更改largeStr, 又要重新检查它的size. Programs with suck ecode are **error-prone**
```c++
//对于string, 可以直接
string largeStr = s1 + " " + s2;

// disastrous if we miscalculated the size of largeStr
strcpy(largeStr, ca1); // copies ca1 into largeStr

strcat(largeStr, " ");  // adds a space at the end of largeStr

strcat(largeStr, ca2); // concatenates ca2 onto largeStr

```

**(8). Mixing Library strings and C-Style Strings**

- initialize string from a string literal  ```string s("Hello World")```
- **string -> const char pointer: c_str()** returns a a pointer to the beginning of a null-terminated character array that holds the same data in string```const char *str = s.c_str()```. It is not guaranteed to be valid indefinitely.  任何s的subsequent use 也许改变 s value 从而invalidate this array. <span style="background-color:#FFFF00"> 所以最好是先copy string 再call c_str(), 或者call c_str() copy 一份</span>


```c++
string s = "abc";
const char* p = s.c_str();s
s = "xyz";
cout<<p[1]<<endl; //print y

```


#### Multidimensional Arrays

严格讲, no multidimensional arrays in C++, 实际上是refered to arrays of arrays. 

**(1).Initialization**
- initialize all elements to 0 ```int arr[10][20][30] = {0}; ``` 只能初始化0，不能初始化别的数
- initialize whole array ```int ia[2][2] = {%{%0, 1%},  {%2,3%}%};``` or ```int ia[2][2] = { 0,1,2,3};```

- initialize 第一行的数 ```int ix[3][4] = {0,3,6,9};``` 只初始化第一行，剩下都是0



```c++
int ia[3][4];

// array of size 10; each element is a 20-element array whose elements are arrays of 30 ints

int arr[10][20][30] = {0}; //initialize all elements to 0

int ia[3][4] = { {0, 1, 2, 3},  // three elements; each element is an array of size 4 

    {4, 5, 6, 7},   {8, 9, 10, 11} };
//The nested braces are optional , 等于下面的

int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

// explicitly initialize only element 0 in each row, 只初始化每行第一个元素，剩下是0

int ia[3][4] = { \{ 0 }, { 4 }, { 8 } };

// explicitly initialize row 0; the remaining elements are value initialized

int ix[3][4] = {0, 3, 6, 9}; 

int (&row)[4] = ia[1]; // binds row to the second 4-element array in ia

```

**(2). loop through array**

注意外层for loop, 我们用了reference, 因为我们避免 normal array to pointer conversion.因为<span style="background-color:#FFFF00"> auto deduced array type是pointer(指向该数组首元素的指针)</span>, 比如下面最后的例子不用reference, deduced to pointer, 无法compiled 

```c++
size_t cnt = 0;
for (auto &row : ia) // for every element in the outer array

    for (auto &col : row) { // for every element in the inner array 
           ++cnt; 
    }

for (const auto &row : ia) // for every element in the outer array

     for (auto col : row) // for every element in the inner array

        cout << col << endl;

//上面的array 如果不用reference, auto deduced type是pointer 

for (auto row : ia) //

     for (auto col : row) // 

        cout << col << endl;
```


**(3). Pointers and Multidimensional Arrays**

- 当程序使用多维数组名字时, <span style="background-color:#FFFF00">会自动将其转化成a pointer to the first element in the array</span>
- when you define a pointer to a multidimensional array, remember that a multidimensional array is a an array of arrays
- iterate 时候可以用auto 去deduced array type, deduced 的是一个pointer to 最外层的指针

```c++
int ia[3][4]; //有三行, 每行有4个

int (*p)[4] = ia; //p is a pointer 指向array of 4 ints 

//上面（）不能省去, int *p[4], 是array of size 4, hold int pointer

//ia指向的是第一行的array (size of 4)

p = &ia[2]; //p points to the last element in ia


//iterate
for(auto p = ia; p != ia + 3; ++p){
    //q points to the first element of an array of 4 ints, q points to an int

    //use auto to deduced array is pointer

    for (auto q = *p; q != *p+4; ++q)
        cout << * q << " ";
    cout<<endl;
}

for(auto p = begin(ia); p != end(ia); ++p){
    //q points to the first element of an array of 4 ints, q points to an int

    //use auto to deduced array is pointer

    for (auto q = begin(*p); q != end(p); ++q)
        cout << * q << " ";
    cout<<endl;
}

```

**(4). Type Aliases Simplify**

- ```using int_array = int[4];``` 
- ```typedef int int_array[4];```


```c++
typedef int int_array[4];
for(int_array * p = ia; p!= ia + 3; ++p)
    for(int * q = *p; q!=*p + 4; ++q)
        oout << *q <<endl;
```



## Include Guard

InC and C++, an **#include guard**, sometimes called a **macro guard**, **header guard** or **file guard**, is a particular construct used to avoid the problem of double inclusion when dealing with the include directive.避免double include 

<span style="background-color:#FFFF00">C preprocessor 把include 的file 复制its contents  into a copy of the source file known as translation unit.</span> The files included in this regard are generally header files() 包括了 functions, classes, structs的declarations. If certain C or C++ language constructs are defined twice, the resulting translation unit is invalid (<span style="background-color:#FFFF00">如果被defined两次, translation unit invalid</span>). #include guards prevent this erroneous construct from arising by the double inclusion mechanism.



The addition of <span style="background-color:#FFFF00">**#include guards**</span> to a header file is one way to make that file idempotent. Another construct to combat double inclusion is <span style="background-color:#FFFF00">**#pragma once**</span>, which is non-standard but nearly universally supported among C and C++ compilers.


**Double Inclusion**


File "grandparent.h"
```c++
struct foo {
    int member;
};

```


File "parent.h"

```c++
#include "grandparent.h"

```


File "child.c"

```c++
#include "grandparent.h"

#include "parent.h"

```

Result

```c++

struct foo {
    int member;
};
struct foo {
    int member;
};

```

Here, the file "child.c" has indirectly included two copies of the text in the header file "grandparent.h". This causes a <span style="color:red""> compilation error</span>, since the structure type foo will thus be defined twice. In C++, this would be called a violation of the [one definition rule](https://en.wikipedia.org/wiki/One_Definition_Rule)

**Use of #include guards**

In this section, the addition of #include guards, the C preprocessor preprocesses the header files, including and further preprocessing them recursively. This will result in a correct source file, 

File "grandparent.h"

```c++
#ifndef GRANDPARENT_H
#define GRANDPARENT_H

struct foo {
    int member;
};

#endif /* GRANDPARENT_H */

```

File "parent.h"

```c++
#include "grandparent.h"

```

File "child.c"

```c++
#include "grandparent.h"

#include "parent.h"

```

Result

```c++
struct foo {
    int member;
};
```


Here, the first inclusion of "grandparent.h" causes the macro GRANDPARENT_H to be defined. 在parent 之后, when "child.c" includes "grandparent.h" the second time, the #ifndef test returns false, and the preprocessor skips down to the #endif(<span style="background-color:#FFFF00"> 当第二次include parent.h, ifndef返回false, preprocessor skips to endif </span>), thus avoiding the second definition of struct foo. The program compiles correctly.


## Pointer 

#### Function Pointer

1. Unlike normal pointers, <span style="background-color:#FFFF00">a function pointer points to code</span>, not data. <span style="background-color:#FFFF00"> Typically function pointer stores the start of executable code </span>
2. Unlike normal pointers, <span style="background-color:#FFFF00"> we do not allocate de-allocate memory</span> using function pointers. 不用allocate de-allocate memory 
3. A function's name can also be used to get functions' address. For example, we can use address operator ```&``` or without it. ```void (*fucPtr)() = fun```  or ```void (*fucPtr)() = &fun```, 用不用```&```一样的
4. We can have array of function pointers. <span style="background-color:#FFFF00">必须function parameter 和 return type 都是一样的</span> 
5. Function pointer can be passed an **argument** and can also be **returned** from a function

Pointers to functions
```c++
// fcnPtr is a pointer to a function that takes no arguments and returns an integer

int (*fcnPtr)();
```
上面例子中, ```fcnPtr``` is a pointer to a function that has no parameters and returns an integer, <span style="background-color:#FFFF00">it can point to any function that matches this type</span>. 其中```()``` is necessary. as ```int *fcnPtr()```是<span style="color:red">a declaration for a function named fcnPtr that takes no parameters and returns a point to an integer</span>

**Const function pointer**
```
int (*const fcnPtr)();
```
<span style="background-color#FFFF00">如果put const before int ```const int (* fcnPtr)();```, 表示function being pointed to would return a const int</span>


<span style="background-color#FFFF00">Function pointers can be initialized with a function (and non-const function pointers can be assigned a function) </span>

```c++
int foo()
{
    return 5;
}
 
int goo()
{
    return 6;
}
 
int main()
{
    int (*fcnPtr)() = foo; // fcnPtr points to function foo
    
    fcnPtr = goo; // fcnPtr now points to function goo
 
    return 0;
}
```

One common mistake is to do this: ```fcnPtr = goo();```. This would actually <span style="background-color:#FFFF00">assign the return value from a call to function ```goo()``` to ```fcnPtr```</span>.  是assign funcion 返回的值
    
<span style="color:red">Note the type of the function pointer must match the type of the function </span>   
    
```c++
// function prototypes

int foo();
double goo();
int hoo(int x);
 
// function pointer assignments

int (*fcnPtr1)() = foo; // okay

int (*fcnPtr2)() = goo; // wrong -- return types don't match!

double (*fcnPtr4)() = goo; // okay

fcnPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does

int (*fcnPtr3)(int) = hoo; // okay

```
    
**Calling a function using a function pointer**

<span style="background-color:#FFFF00"> Explicit dereference </span>
```c++
int foo(int x)
{
    return x;
}
 
int main()
{
    int (*fcnPtr)(int) = foo; // assign fcnPtr to function foo

    /* The above line is equivalent of following two 
       int (*fcnPtr)(int); 
       fun_ptr = &fun;  
    */
    
    (*fcnPtr)(5); // call function foo(5) through fcnPtr.

    fcnPtr(5); // call function foo(5) through fcnPtr.
    
    int (*fcnPtr2)() = &foo;//assign pointer to function

    (*fcnPtr2)(5); // call function foo(5) through fcnPtr.

    fcnPtr2(5); // call function foo(5) through fcnPtr.

    return 0;
}
```

<span style="background-color:#FFFF00"> Implicit dereference </span>: 就像normal function call, since normal function names are pointers to functions anyway!
```c++
int foo(int x)
{
    return x;
}
 
int main()
{
    int (*fcnPtr)(int) = foo; // assign fcnPtr to function foo
    
    fcnPtr(5); // call function foo(5) through fcnPtr.
 
    return 0;
}
```

<span style="background-color:#FFFF00">需要注意 **Default parameters won't work for functions called through function pointers**: 因为default parameters are resolved at compiled time(意味着if you don't supply an argument for a defaulted parameter, the compiler substitues one when code is compiled), 但是function pointers are resolved at run-time</span>. Consequently, default parameters cannot be resolved when making a function call with a function pointer. 你不得不pass in vlaues for any defaulted parameteres.

Array of function pointers

```c++
void add(int a, int b){
    cout << "a + b  = "<<a+b<<endl;
}

void subtract(int a, int b){
    cout << "a - b = "<<a+b<<endl;
}

void multiply(int a, int b){
    cout << "a * b = "<<a*b<<endl;
}


int main()
{
    const int r = 3;
    void (* FucPtrArray[])(int, int) = {add, subtract, multiply};
    FucPtrArray[2](5,3);
    // It's the same as (*FucPtrArray[2])(5,3);

}
```

**Passing function as arguments to other functions**

Functions used as arguments to another function are called **callback functions** 比如让用户选择自己的sorting algorithm 在selection sort algorithm,
```c++
bool (*comparisonFcn)(int, int);//因为compare tow interters and return a boolean value

```

```c++
#include <algorithm> // for std::swap, use <utility> instead if C++11

#include <iostream>
 
// Note our user-defined comparison is the third parameter

void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))
{
    for (int startIndex = 0; startIndex < size; ++startIndex)
    {
        int bestIndex = startIndex;
        for (int currentIndex = startIndex + 1; currentIndex < size; ++currentIndex)
        {
            if (comparisonFcn(array[bestIndex], array[currentIndex])) // COMPARISON DONE HERE

                bestIndex = currentIndex;
        }
 
        // Swap our start element with our smallest/largest element
        
        std::swap(array[startIndex], array[bestIndex]);
    }
}
 
// Here is a comparison function that sorts in ascending order

bool ascending(int x, int y)
{
    return x > y; // swap if the first element is greater than the second
    
}

bool evensFirst(int x, int y)
{
	// if x is even and y is odd, x goes first (no swap needed)
    
	if ((x % 2 == 0) && !(y % 2 == 0))
		return false;
 
	// if x is odd and y is even, y goes first (swap needed)
    
	if (!(x % 2 == 0) && (y % 2 == 0))
		return true;
 
        // otherwise sort in ascending order
        
	return ascending(x, y);
}
 
// Here is a comparison function that sorts in descending order

bool descending(int x, int y)
{
    return x < y; // swap if the second element is greater than the first
    
}
 
 
int main()
{
    int array[9] = { 3, 7, 9, 5, 6, 1, 8, 2, 4 };
 
    // Sort the array in descending order using the descending() function
    
    selectionSort(array, 9, descending);
    printArray(array, 9);
    //9 8 7 6 5 4 3 2 1

 
    // Sort the array in ascending order using the ascending() function
    
    selectionSort(array, 9, ascending);
    printArray(array, 9); 
    //1 2 3 4 5 6 7 8 9
    
    selectionSort(array, 9, evensFirst);
    printArray(array, 9);
    //2 4 6 8 1 3 5 7 9
    
    return 0;
}
```

<span style="background-color:#FFFF00"> Note: If a function parameter is of a function type, it will be converted to a pointer to the function type</span>. It means 
```c++
void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))
```

is equivalently written as 
```c++
void selectionSort(int *array, int size, bool comparisonFcn(int, int))
```

<span style="background-color:#FFFF00"> This only works for function parameters, not stand-alone function pointers </span>


**Providing default functions**: 下面例子, as long as user calls selectionSort normally(不是通过function pointer), the comparisonFcn parameter will default to ascending. 

```c++
// Default the sort to ascending sort

void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int) = ascending);
```

**Making function pointers prettier with typedef or type aliases**: the syntax for pointers to functions is ugly. However, typedefs can be used to make pointers to functions look more like regular variables:

```c++
typedef bool (*validateFcn)(int, int);
```
This defines a typedef called “validateFcn” that is a pointer to a function that takes two ints and returns a bool.

Now instead of doing this 

```c++
bool validate(int x, int y, bool (*fcnPtr)(int, int)); // ugly

```

You can do this 

```c++
bool validate(int x, int y, validateFcn pfcn) // clean

```

**Using std::function in C++11**: Introduced in C++11, an alternate method of defining and storing function pointers is to use ```std::function```, which is part of the standard library ```<functional>``` header. Both the return type and parameters go inside angled brackets, with the parameters inside parenthesis. If there are no parameters, the parentheses can be left empty. 


    
```c++
#include <functional>

bool validate(int x, int y, std::function<bool(int, int)> fcn); 
// std::function method that returns a bool and takes two int parameters

#include <functional>
#include <iostream>
 
int foo()
{
    return 5;
}
 
int goo()
{
    return 6;
}
 
int main()
{
    std::function<int()> fcnPtr = foo; // declare function pointer that returns an int and takes no parameters
    
    fcnPtr = goo; // fcnPtr now points to function goo
    
    std::cout << fcnPtr(); // call the function just like normal
 
 
    return 0;
}
```

**Type inference for function pointers(Auto)**: the auto keyword can also infer the type of a function pointer.<span style="color:red">The downside is, of course, that all of the details about the function’s parameters types and return type are hidden(**parameters types 和 return types 都是hidden**), so it’s easier to make a mistake when making a call with the function, or using its return value</span>. Unfortunately, type inference won’t work for function parameters (even if they have default values(Auto 不能传入用于function parameters)

```c++
#include <iostream>
 
int foo(int x)
{
	return x;
}
 
int main()
{
	auto fcnPtr = foo;
	std::cout << fcnPtr(5);
 
	return 0;
}
```

<span style="background-color:#FFFF00"> Because the native syntax to declare function pointers is ugly and error prone, we recommend you use typedefs (or in C++11, std::function).</span>

