---
layout:     post
title:      "C++ Primer - 笔记"
subtitle:   "C++ Primer Summary "
date:       2019-06-18 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - Batch
    - 学习笔记
---

## Variable and Basic Types

**Object**: an object is a region of memory that has a type. In the book, we will freely use the term *object* regardless of whether the object has built-in or class type, named or unnamed (命名的还是未命名的), or can be read or written.

<span style="background-color: #FFFF00">**Initialization is not assignment**</span>. Initialization happens when a variable is given a value *when it is created*.(创建变量时 赋予它一个初始值). Assignment obliterates an object's current value and replaces that value with a new one (把对象当前值擦除，用一个新值代替)

#### Initialization, Definition, Declaration, Scope

**List Initialization**

下面四种初始化都正确

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold {0};
int units_sold(0);
```

when used with variables of built-in type, List Initialization has one important property: The compiler will not let us initialize variables of built-in type if the initializer might lead to the loss of information. (编译器将会报错，如果使用列表初始化且初始值存在丢失信息的风险). 

```c++
long double id = 3.1415026536;
int a{ld}, b = {ld}; //error: 存在丢失信息风险

int c(ld), d = ld; // 转化执行，但是丢失了部分值 (truncated)
```

The compiler rejects the initializations of a and b because using a long double to initialize an int is likely to lose data. the fractional part of ld will be truncated. (long double 初始化int 变量时可能丢失数据，所以编译器拒绝了a 和 b的初始请求. 至少ld 的小数部分丢失，而且int 也可能存不下ld的整数部分因为是long)


**Default Initialization**

Most classess let us define objects without <span style="color: red">explict initializers</span>. Such classes supply an appropriate default value. e.g. std:string empty; //empty implicitly initialized to the empty string. 

Note: Uninitialized objects of built-in type defined inside a function body have undefined value. Objects of class type that we do not explicitly initialize have a value that is defined by the class.

**Variable Declarations and Definitions**

 <span style="background-color: #FFFF00">**A declaration makes a name known to the program. A definition creates the associated entity.**</span>

A variable **declaration**  <span style="background-color: #FFFF00"> specifies the type and name of a variable</span>. A variable definition is a declaration. In addition to specifying the name and type, a **definition** also <span style="background-color: #FFFF00"> allocates storage and may provide the variable with an initial value</span>. 变量声明规定了变量的类型和名字，在这一点上定义与之相同. 但除此之外, 定义还申请存储空间, 也可能会为变量赋一个初始值

如果想声明一个变量而非定义它，在变量前添加extern

```c++
extern int i; //声明i而非定义i

int j; //声明并定义j
```

任何包含了显示初始化的声明既是定义. 给extern 表含的变量一个初始值，抵消了extern的作用

```c++
extern int i = 5; //定义
```

<span style="background-color: #FFFF00"> Variable must be defined exactly once but can be declared many times</span> 变量只能被定义一次，但可以被声明多次

**Nested Scopes**

<span style="background-color: #FFFF00"> 用 :: 访问global variable (explicitly request global variable) </span>

```c++
int reused = 42;
int main(){
    cout << resused <<endl; // 42

    int reused = 0; //新建局部变量，覆盖全局变量

    cout << resused <<" global " << ::resused <<endl; // 0 , 42

}
```




#### Compound Types

A **compount type** is a type that is defined in terms of another type, which is references and pointers

**Reference**

At here, reference is only lvalue reference not rvalue reference. 

<span style="background-color: #FFFF00"> reference must be assigned at initlization </span>. 程序把引用和初始值绑定(bind)到一起，而不是将初始值拷给引用, 引用无法绑定到另一个对象. <span style="color: red"> A reference is not an object. Instead, a reference is just another name for an already existing object </span>


```c++
int val = 1024;
int &refval = val, &r = i; // correct

refval = 2; //val = 2

int &refval2; //error

int &refval3 = 10 ;//error: initializer must be an object

double dval = 3.14;
int &refVal5 = dval; // error: initializer must be an int object
```

We can define multiple references in a single definition

```c++
int i2 = 2048; // i and i2 are both ints 

int i3= 1024, &ri = i3; // i3 is an int;ri is a reference bound to i3 

int &r3 = i3, &r4 = i2; // both r3 and r4 are references
```



**Pointer**

assign pointer 需要assign 的类型和被assign 类型compatible

```c++

double dval;
double *pd = &dval; //ok: initializer is the address of a doub;e

double *p2 = pd;//ok: initializer is a pointer to doub;e

int *pi = pd;//error: types of pi and pd differ, 一个int,一个double
pi = &dval; //error: assigning the address of a double to a pointer to int

//上面两个error 都会compile fail


int dval;
double *pi = &dval;//error: types of pi and pd differ, 一个int,一个double, 也是compile error

```

<span style="background-color: #FFFF00">It is error to copy or try to access the value of an invalid pointer</span>. As when we use an uninitialized variable, <span style="color: red">this error is one that the compiler is unlikely to detect(编译器不会检查access invalid pointer)</span>. The result of accessing an invalid pointer is undefined. 


& 赋值是改变等号左侧 pointer指代对象, \* 不改变指代对象，改变的是指代对象的值 
```c++
int r = 1;
int *p = &r;
int *p2 = p;
    
*p2 = 10; //change pointed value, aslo change value of the object pointer points to
cout << *p <<" , "<<*p2  <<" , "<< r <<endl; //print 10 ,10, 10

int c = 5;
p = &c; //change object that pointer points to
cout << *p  <<" , "<< r <<" , "<< c<<endl;//print 5, 10 , 5

```

Given two valid pointers of the same type, we can compare them use<span style="background-color: #FFFF00"> the equality(==) or inequality(!=) operator, Two pointers are equal if the yhold the same address (两个指针存放的地址相同) </span>


**void \* **