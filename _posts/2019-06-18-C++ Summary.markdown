---
layout:     post
title:      "C++ Primer - 笔记"
subtitle:   "C++ Primer Summary "
date:       2019-06-18 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - Batch
    - 学习笔记
---


![](/img/post/C++/type.PNG)

- function return reference 可以用non-reference 去接, non-reference 接的话借的是copy 
- namespace 中function 不是在class 但是声明了 static 是  give **internal linkage**, meaning that it is only accessible within the translation unit that contains the definition. Without static, it has external linkage, and is accessible in any translation unit. So you'd use static (or, alternatively, an unnamed namespace) when writing a function that's only intended for use within this unit; the internal linkage means that other units can define different functions with the same name without causing naming conflicts.

**iteral type**: (int, int pointer, int reference, double, enum, char, char array char pointer) scalar type, reference type, an array of literal type; <span style="color:red">注:string 不是literal type</span>

A class is a literal type
- has a trivial destructor(自己没有定义destructor 并且 non-static member object 也没有定义destructor )
- every constructor call and any non-static data member that has brace- or equal- initializers is a constant expression, ```int i = 4; int j {5};```
- is an aggregate type, or has at least one constexpr constructor or constructor template that is not a copy or move constructor, and
- has all non-static data members and base classes of literal types

```c++
struct B { ~B() {} };//not literal type

```
```c++
class X {
  int i = 4;
  int j {5};
public:
  X(int a) : i{a} {}  //initializes with a and 5
  
  X() = default;      //initializes with 4 and 5
  
};
```


陷阱: 1. constexpr, type Aliases under  [2. Variable and Basic Types](# 2. Variable and Basic Types) 2. Array: Pointer Arithmetic: 可以负数  [3. Strings, Vectors, and Arrays](# 3. Strings, Vectors, and Arrays). 4. Function only with top level and return difference error. 5. Function name lookup before type checking [6. Functions. d](#(6). Functions) 6.Function Names resolve and calculate [6. Functions. d](#(6). Functions) 7. function pointer parameter 和return type的转换[6. Functions. d](#(6). Functions) 8. ```*this``` is reference to object (not const reference) 7. const class object 不能call non const member function  8.const function 对于 const function is better match (因为不用转化lower const) 9.const function 只能返回 const reference （buneng） 10. const function 内不能call不是const的function. nonconst function 可以call const function.  11. constructor initializer list order 不会影响他们实际初始化的顺序. 11 static member可以用于default parameter

***

8.IO Library

- 为支持wider character, library 有 ```wchar_t```, 有```wcin```, ```wcout```, ```wcerr```, 也有```wifstream```
- ```ifstream```, ```istringstream``` 继承自 ```istream```
- No copy or assign for IO Object: 通过reference pass 给 function(<span style="color:red">注意不能是const, 因为改变state></span>), return must be reference. 
- state 
    - badbit: not possible to use when ```badbit``` set. ```s.bad()``` return true if badbit set
    - failbit: recoverable 比如expected numeric when meet char. ```s.failbit()``` return true if badbit and failbit set
    - goodbit: <span style="color:red">guaranteed to have value 0</span> 表示no failure
    - ```rdstate()```: current state, ```s.setstate(flag)```: reset condition of s to flags
- 每一个流都管理一个缓冲区(buffer), 用来hold data that program reads and writes. 
- Using a buffer 可以combine serval output operations into a single system-level write. 因为writing to device time-consuming. combine 多个到single write 可以 <span style="color:red">performance boost</span>
- Buffers Are not flushed if program crashes. 如果程序异常终止, 缓冲区不会刷新, 当一个程序崩溃(crash)后, 它输出的数据可能停留在输出缓冲区中等待打印. (所以debug 时候小心)
- 有几种条件导致换种刷新: 
    - program completed normally. buffers flushed as part of main
    - buffer become full 
    - flush buffer explicitly using manipulator ```endl```, ```ends```, ```flush``` 
    - ```unitbuf``` manipulator: ```cout << unitbuf; ``` 所有输出操作后都会立即刷新缓冲区. ```cout << nounitbuf;``` // returns to normal buffering  
    - Output stream might be tie to another stream. 当绑定的stream read or write, 会flush. 默认是```cin``` 和 ```cerrr``` 绑定到```cout```, reading to ```cin``` or writing to ```cerr``` flushes the buffer in cout. 
        - ```tie```: 一个版本是接受个pointer, ```cin.tie(&cout);```
        - ```tie```: 另一个版本是返回现在绑定的stream ```ostream* old = cin.tie(nullptr);```
- when we creat a file stream,  如果提供file name, ```open``` is called automatically.
- When an fstream object is destroyed, <span style="color:red">```close``` is called automatically</span>
- fstream constructor explicit
- when specify ```ofstream```, 没有specifiy, ```out``` and ```trunc``` implicitly. 只specify ```out```, ```trunc``` implicitly. 只specify ```trunc```, ```out``` implicitly
- when specify ```app``` on ```ofstream```, ```out``` implicitly
- ```app```	seek to the end before every write 每次写操作前均定位到文件末尾
- ```ate```	Seek to the end immediately after the open 打开文件后立即到文件末尾
- stringstream constructor is explicit, holds an copy of stream ```sstream strm(s)```
- ```getline```是从一个```ifstream```中读取数据.  <span style="color:red">```getline``` 不会跳过空格, 如果读取的string 第一个是空格，会保留空格</span>


***

9.Sequential Container

- list /forward 不支持random access, 花销大
- forward_list no size operation, no back, 但有end 
- STL Array support copy constructor/assignment, brace assignment/initilization, 但没有member 的 begin end, no iterator constructor, 但可以用 ```array<int,10>a; begin(a); end(a);```
- STL Array 不为空, default initialzer member是class, 必须有default constructor 
- assignment operator invalidate iterators, but swap not (internal structure swap)
- Assign 可以用于different but compatible type
- iterator constructor 不需要type exact match 比如double 到int
- const object 的iterator, is const iterator 
- deque add / remove element 从两边只invalidate iterator, 不invalidate reference 
- vector/string add invalidate all, delete 对删除之前的没有影响
- capacity (size before allocate) vs size 区别
- const char * -> string 必须null terminated
- insert 在p前插入, 返回插入第一个元素, erase 返回删除后一个元素的



***
 
10: Generic Algorithms
- Algorithm never execute container operations, 不会改变size, 但是会add / remove elements using inserters
- Algorithm not check write operations: 假设destionation 足够大hold elements, 如果空间不够, undefined behavior. 确保有足够空间用inserter
- equal 比较两个sequences hold the same value. 可以是不同容器, 一个是vector, 一个是list
- accumulate 可以用 ```string("")``` 作为第三个参数, 但不能用 ```""``` 因为no accumlate for ```const char*```, 因为char pointer 没有定义 ```+```
- unique 因为不能改变容器大小, 返回an iterator that denotes the end of the range of the unique value
- predicate can be returns a value used as condition
- **callable object**: ```e(args)```
- **lambda function**: ```[capture list] (parameter list) -> return type { function body }```
    - capture list capture local nonstatic varaibles 比如 ```cout``` 无需 capture
    - 可以省略 parameter list or return type 或两个都省略
    - <span style="color:red">不能有parameters has default value </span>
- lambda capture by value: 捕获指 是 创建时 而不是调用时的值, 随后修改被调用没有影响
    - <span style="color:red">如果想改变 capture value 的值， 加mutable, 有mutable 不能省略 parameter list. 但可以省略return type </span>
    - 若value is pointer, lambda copy 值和 外面的 值 指向一个object, object 改变, value的pointer object 值也变, 要确保pointer valid when 执行lambda function
- lambda capture by reference ```[&v1] ```, 必须确refereneced object 存在 当执行lambda function 时候
    - capture by reference 是否可以改变取决于 object 是不是const 
- Implicit capture: 让compiler 自己infer capture 的值, by value ```[=]```, by reference ```[&]```
- Mix: Implicit 必须放前面, explicit 放后面, 如果第一个是by value, 第二个必须是by reference ```[=,&c]```; 如果第一个是by reference, 第二个必须是by value```[&,c]```. 比如
- 尽量减少reference, pointer capture
- bind: ```auto newCallable = bind(callable, arg_list); ```, 
    - ```arg_list``` 可以有placeholder ```_1, _2``` 表示给```newCallable``` 第一/二个参数, 可以rearrange, ```_2``` 在 ```_1``` 前面
    - using declaration is ```using std::placeholders::_1```
    - 可以bind 传 reference. 用```ref```, 比如IO类
    - 可以用```bind``` 就根据一个predicate 同时来正向反向 sort, 方法是交换```_1``` 和 ```_2``` 的位置
- Insert Iterator: takes a container yields a iterator, 当像iterator 赋值, iterator call container operations to add elements. ```it=t``` call  相应的```push```, ```insert```, ```*it, ++it, it++```没有实际意义, 有back_inserter(call ```push_back```), front_inserter (call ```push_front```)，还有```inserter```
    - ```auto it = back_inserter(vec); ```, ```it=42``` 和 ```*it=42```是一样的 
- type use ```istream_iterator``` reads 必须有 ```>>``` input operator defined. ```ostream_iterator``` 使用对象必须有 ```<<``` defined
- ```istream_iterator``` lazy initialization: delay 读取, construct 不读取，只有```*it``` 才读取
    - ```istream_iterator```默认值是off-the-end value,```ostream_iterator``` 不存在off-the-end iterator
    - ```ofstream_iterator``` 的 ```++``` 是 read next value from input stream ```ofstream_iterator``` 的 ```++``` 没有实际作用
    - 例子 读取到```vector```, ```stream_iterator<int>in_iter(cin),eof;vector<int> vec(in_iter, eof);```
- ```reverse_iterator``` ```++it```移动到上一个, ```--it``` 移动到下一个
    - 获取reverse iterator ```rbegin```, ```rend```, ```crbegin```(最后一个element位置), and ```crend```(是在begin开始前的iterator)
    - ```base``` 是 next element to the ```reverse_iteartor``` pointing to
- Forward Iterator 跟 Birectional iterator 比 只多了 decrement(反向), 两个都是可以read and write, multi-pass, increment
- Input, output iterator 是 single pass 的, 用于比如find, accumulate, istream_itearator 
- Random-access iterators: 需要const-time access to any position, 像pointer 支持subscript operator: 跟forward, birectional iterator 比多 subtraction operator, 生成distance betweeen operators 
- 优先考虑 list 和 forward_list 自己的算法

***

14: Operator Overloading

- overloading parameter must at least one is class type 
- assignment, subscript, call```()```, access arrow, dereference, increment, decrement, compound-assignment```+=``` must be member functions
- input / output IO must be nonmember (因为如果是class member, left-hand operand是IO, must be IO class, 但是IO不能添加member)
- input 传入nonconst object, ouput 传入 const object
- assignment operator 可以把不同的类赋值, 比如赋值```initializer_list```
- subscript operator 最好定义 const 和 nonconst version (因为有可能可以改变值)
- postfix return value and use extra int call prefix ```p.operator++();```  postfix ```p.operator++(0);```
- prefix 需要检查 increment safe or not, postfix use prefix 
- ```operator->()``` 如果不返回pointer, 会持续recursion fetch result 是 pointer type. 当是pointer, 返回```&this->operator*()``` 
- 可以定义多个call operator, 参数类型 数量不同
- library function objects (like ```less<key_type>```, 比较地址) work for **pointers** 
- Lambda call operator default const function, 如果定义mutable, 不是const function 
- lambda function, compiler 是 unnamed object of unnamed class 含有 function-call operator, capture by values store value 但caputre by reference 不store
- 不能把一样名字的function overload(名字一样,signature 不一样的) 放进 ```function```
- conversion operator ```operator type()``` no parameter 和 return type, type 不能是array, void, function type 
- conversion operator should be const 不能改变object
- conversion operator(只能一步) 但 之前或者之后可以有 build-in conversion， 实现多步转换 
- explicit conversion operator:除了判断条件会implicit转换, 不允许implicit conversion,  只能用static_cast
- 不要定义mutual converion 比如 A constructor take B, B conversion operator 到 A, 也不要定义到多个算数类型转换 比如 A->int, A->double; int ->A, double -> A,
- 如果到多个type conversion 都available, 不会有rank 比较, 只有到一个type 的多个conversion 才会进行rank比较 

***

15.Object-Oriented Programming

- **dynamic-binding**: decision as to which version to run depends on the type of the argument, 在run time 选择函数版本 (when a virtual member function is called through a reference or a pointer to a base-class type)
- final, override 在parameter list, const, qualifier reference 之后
- virtual function in base class 是 implicit virtual in all derived class
- derived virtual function 跟base 不同signiture, 是不override base的
- 用scope operator prevent dynamic binding, 如果derived class 应该call base virtual, but fail to provide ```baseP->Base::fuc()```, infinite recursion
- object access virtual, pointer/reference access nonvirtual  bound at compile time, 只有pointer/reference access virtual run time
- static type vs dynamic type: static type known at compile time. dynamic type know at run time. static type of a pointer or reference to a base class may differ from its dynamic type.
- 只有reference/pointer call virtual function 才是runtime 决定的, reference/pointer call nonvirtual or object call virtual 都是compile time bound 
- pure virtual function 可以被定义, 但只能定义在class外面
- user 的 derived-to-base conversion 必须是public inheritance, derived的member and friend 无所谓, derived of derived可以用derived-to-base conversion 必须是public/protected的
- friend 不是 transitive 和 inheritance 的 (清楚这个概念例子)
- <span style="color: red">Derived class中 friend function, access base 的protected (base protected 也是derived protected) 成员能通过 derived-class object access, 不能通过base-class object</span>. A derived to B. B friend is C, C 只能用 B 获取A的protected, public, cannot use A 取获取 A
- <span style="color: red">class friend function 可以从class 的 derived class 中获取class member， 但不能获取derived member</span>. A friend is C, A derived to B, C 中可以用 B 获取A的值
- Name Lookup before type checking 
- 可以用using declaration ```Derived d; d.Base::memfcn();``` change access level (base protected 变成 derived 的 public, base 的被hide了)
- <span style="color:red">At Compile time: static type 决定什么member can be used</span> (也是virtual function定义在base 和 derived原因). 如果Derived 有 function ```fcn``` 而 Base 中没有, then ```Base *p = &d; p->fcn();```是error的， 因为static search scope, ```fcn``` 不在 ```Base``` 中
- Derived-to-Base conversion 也适用于 smart pointer, 
- 如没有virtual destructor, delete on pointer to base that points to derived object undefined
- constructor 顺序: base -> derived. Destructor 顺序(**reverse order**) : derived -> base.
- base constructor virtual call base version
- Compiler treat type changes during construction or destruction. 因为base constructor run, derived 未生成, base destructor run, derived 已被摧毁
- <span style="color: red">1. synthesize copy constructor 自动call base defined/sythesized copy constructor. 2. user defined copy constructor 不会自动call base defined / sythesized copy constructor, 而call base default constructor. 若call base copy construction 需要显式call in derivation list (有**derived-to-base** conversion)</span> 
- 如果default constructor, copy/move constructor, copy/move assignment constructr 在 base class 是deleted/inaccessible, 则相应的 derived class synthesized member is deleted 因为没法call based 的
- 如果 base destructor deleted,then derived class systhesized default,copy/move constructor is deleted
- 如果base copy construction 被deleted, base/derived move constructor 是不能生成的
- base 有destructor, derived/base class 没有move operation(copy operation deprecated)
- inherit constructor:
    - 可以inherit base constructor, 但不能inherit default, copy, and move constructor, assignment operator 因为compiler 会synthesize 如果不define
    - using declaration for constructor, generate code, ```using Base::Base``` 继承base all constructors
        - 不会change access level, derived class default intilizated 
        - 不能specify explicit or constexpr, same as base
        - default arguments 会生成多个递减argument constructor
        - 不会继承constructor with the same parameter, derived 代替base的
    - inherit constructor 不算user-defined constructor
- 可以定义lvalue / rvalue version of ```clone``` using reference qualifier. 



***
16.Templates and Generic Programming

- function template
    - T 可以用作 return type, function parameter type, variable declaration or cast
    - nontype parameter 是 value 而不是 type 
- template declaration and definition in the header file. 因为template generate code when instantiation
- function can deduce template parameter, but class cannot
- class template member function 只有被用到才被实例化
- 如果return type is template parameter, 定义在class 外面,not in class scope,need to specify if type defined inside class ```Blob<T>::type```
- inside class scope, 不用specify template parameter, 因为assume we use the same type as member's instantiation
- template parameter 会 hides any declaration of that name in outer scope
- 如果使用default template argument, 用的时候 用```Blob<>``` 
- Compilation Errors Are Mostly Reported during Instantiation
- 告诉compiler we use type not static member, use **typename**
- <span style="color:red">class(template / nontemplate) 的member template cannot be virtual</span>. class template parameter come first, then member parameter list. Member templates arguments 像function template 一样, 可以被deduces出来
-  explicit instantiation: ```extern```
    - 当compiler 看见 ```extern``` 不会generate code
    - extern declaration 必须出现在code 使用实例化之前
    - file 的 ```.o``` 文件不会包括 被定义了 extern template classs的instantiation
    - 必须link 有extern class 的定义 的```.o``` file 与 用到 extern template 的 file ```.o``` file 
    - explicit instantiation definition: compiler instantiates all member of that class. 所以要求types works for every member function
- function template argument conversion
    - top level const ignore
    - const conversion, 没有lower-const pointer / reference 给有lower-const pointer/reference 
    - array/function to pointer type (如果T是reference type ```const T&```, 不会有convert to pointer, <span style="background-color:#FFFF00">这种属于exact match conversion</span>)
    - 不可以 arithmetic conversion, derived-to-base conversion, and user-defined conversion
    - normal parameter 可以进行conversion 
- template/nontemplate class to template /nontemplate class friendship，只有one to one friendship 且friend class 是template 时候，<span style="color:red">需要forward declaration of template, 1 v 1比如 class-template, template to template(具有相同的实例化 instance 才是friend)</span>
- typedef 只能用于instantiated class,不能refer to a template 
- 每一个instantiation 都有自己的 class member 成员, 可以用实例化对象access or scope operator ```Foo<int>::sta``` 不可以 ```Foo::sta```
- template declaration 必须包括 template parameters
- Implicit instantiation: 只有用到时候才实例化: declare pointer(只是declare没有绑定) to class, 不会instantiate classs  比如```Foo<int>*a``` class defintiion不会instantiated. 或者当有derived-to-base pointer conversion时候 or  delete pointer
- <span style="color:red">如果class static member, 只有用static member时候才会实例化</span>
- 有时候compiler 不能deduced type(比如 return type or normal conversion) ，需要Function explicit arguments. explicit argument from left to right. ```long lng; compare(lng, 1024); ```, error 因为没有```compare(long,int)```, ```compare<long>(lng, 1024);``` correct, 1024 convert to long 
- Trailing Return Types：deduce ```decltype``` return type from parameters. 因为trailing return appears after parameter list
- header ```type_traits``` type tranformation for template parameter.  如果返回是```type_traits::type``` 必须加**typename**， 告诉compiler we use type 
    - 如果not possible to transform, ```type_traits::type``` is template parameter, 比如```remove_pointer<T>::type```, if ```T``` is ```int*```, return type is ```int```, 如果 ```T``` is ```int```, return type is ```int``` 
- assign or intialize a function pointer, compiler use type of pointer(等号右边)值 to deduce template. ```int (*pf1)(const int&, const int&) = compare;``` compare is template
- ```template <typename T> void f(T &p);``` 只能pass lvalue, <span style="color:red">如果```T``` 含有const, 只能是lower-level, not top level. </span>, 比如```const char * ```
- ```template <typename T> void f2(const T&p);``` <span style="color:red">parameter 的 const 可是top/lower level, 比如```const char * const &p``` T是 char to const object (T中的const 是 lower-level), ```const T&p``` 的 ```const``` 是 top level 指pointer is const pointer. 比如```const int&```, T是```int```, const 是lower level的</span>
- rvalue reference collasping
    - 可以pass 任何type to template function with rvalue reference
    - <span style="color:red">pass rvalue to ```T&&```, T is rvalue type (not reference)</span>
    - <span style="color:red">pass lvalue  to template function with rvalue reference 是, T是 lvalue reference</span>
    - reference collasping only applies 当 reference to reference is created indirectly 比如type alias or template parameter
    - 比如function paramter is ```T&& val```, function内 ```T t = val```; <span style="color:red">如果pass rvalue is copy value of val, 改变t, 不改变外面值 . 如果pass is lvalue(```T``` is reference type),  is binds reference to val, 改变t, 改变外面值 </span>
- ```move```: 返回的type是```remove_reference<T>::type&&```always return rvalue reference. 对于rvalue, cast does nothing, 对于lvalue, ```static_cast<remove_reference<T>::type&&> (t)``` t 是lvalue reference  
- ```forward<T>::type```
    - <span style="color:red">必须called with explicit argument type</span>
    - return rvalue reference (```T&&```) to that explicit argument type 
        - if argument is rvalue,  ```type``` is rvalue oridinary type. return rvalue reference
        - if argument is lvalue, ```type``` is lvalue reference, return ```Type& &&``` is lvalue reference
    - preserve all the type information by <span style="color:red">using rvalue reference and ```std::forward<T>(t)```</span>
    - 如果不用rvalue reference, 不work 的例子
    - 如果不用forward, 即使rvalue reference 也会被当做lvalue to pass 给 template function 内的另一个function 
- template matching rule:
    - 根据conversions 来排序 (array/function to pointer, lower const conversion), 如果several functions viable 
        - 如果有nontemplate function, 选nontemplate function 
        - 其次选择more specialized  比如 ```T* p``` more specialized than ```const T& p```
	- 看overloading match 例子
    - 注意string literal types```"Hi"``` is const char array, 所以有```const T&a``` 和 ```const T*a``` 都available 优先call pointer的, 因为 array to pointer conversion  属于exact match, ```const T*a``` 比 ```const T&a``` 更specialized
     - rvalue reference 只用于forwarding argument or template overloading
        - ```template <typename T> void f(T&&);``` binds to nonconst rvalues and lvalues
        - ```template <typename T> void f(const T&);```  const lvalues and rvalues, 因为有const conversion (不是top的)，所以上面的不是exact match
        - 如果同时```T&&``` 和 ```const T&``` 对于nonst lvalue, call ```T&&``` 因为更specialized 的	
	
- Variadic Templates: varying parameter is <span style="background-color:#FFFF00">**parameter pack**</span>, 大于等于0个不同类型 parameters
    - ```sizeof...(pack)``` 有多少个pack
    - **initializer_list** used varying number of parameter with the same type, **Variadic functions** used when different type
    - vardiadic function 通常是recursive的, process first one and call iteself on remaining 
        - 需要一个nonvariadic version stop recursion, 如果fail to declare before variadic, 无限的recursion
- Expand Pack: put ellipsis to right of the pattern
- Forward Pack: rvalue reference + forward: ```std::forward<Args>(args) ...```: expands both template parameter pack Args and function parameter pack args.
- specialization 
    - function: 必须为其提供arguments for every template parameter. 
    - function specialization is instantiation. <span style="color:red">不是overload function, 不影响function match</span>, 如果定义normal template 和 specialization, 选择specialization (其实只是一个实例化), (根据matching rule, more specialized)
    - 不可以partial specialized function template
    - class template 可以 partial specialized , 在class 名字后的 ```<>``` specify template parameter we are specializing, 与原模板中 的参数 按位置对应. 保留一部分template parameter, specialized 一部分 template parameter
    - 可以只specialize members 而不是whole class (比如```hash<Sales_data>```)
    - <span style="color:red">declaration for a specialization must be in scope before any code uses that instantiation, 否则compiler generate code using original template</span>
- ```hash<key_type>```: 必须定义
    - 1 call operator returns ```size_t``` and parameters is ```key_type```
    - 2 ```result_type``` (```size_t```) and ```argument_type``` (就是```key_type``` 比如 ```Sales_data```)
    - 3 default constructor and copy-assignment constructor (can be implicitly synthesized)
    - 必须specialized in namespace ```std``` as defined. 
    - 如果使用 key_type（```Sales_data```） 的 private member, 需要make ```hash<key_type>``` as ```Sales_data```friends
    - ```key_type``` 需要有 ```==``` 定义
    - ```hash<Sales_data>``` definition starts with ```template<>```, which <span style="color:red">indicates that we are defining a fully specialized template</span>
	
***

17.Specialized Library Facilities
- ```tuple<T1,T2,...,Tn>t``` are value initialized 
- ```tuple<T1,T2,...,Tn>t(t1,t2,...,tn)```: constructor is explicit (direct initialization 不能conversion constructed)
- ```make_tuple<v1,v2,...,vn)```: type inferred from types of initializer
- ```t1==t2```: <span style="color:red">member 必须有一样的数量</span>。 一旦发现不一样, 后面不用比较了
- tuple Relational operations: tuples 必须有一样数量member 
    - 因为tuple defines ```<```and ```== ```operators, 可以pass sequences of tuples to algorithms and use tuples as key type in <span style="background-color:#FFFF00">**ordered container**</span>
    - 如果同样位置type 不可比也是error, 比如 第2位置一个是string, 一个是int, 不可比
- ```get<i>(t)```: <span style="color:red">return reference</span>,如果```t``` is lvalue, result is lvalue reference, otherwise it is rvalue reference. 
    - ```i``` <span style="color:red">必须是 integral constant expression</span>
- 所有member of tuple 是 public
- ```tuple_size<tupleType>::value```: size_t type.  public constexpr static data member, 可以用于array declare, 比如 ```int a[tuple_size<..>:value]``` 
    - 如果tupleType 不知道, 可以用```decltype```
- ```tuple_element<i, tupleType>::type```: type of specified members in specified tuple type

- bitset possible to deal with collections of bits 大于 longest integral type
- bitset has <span style="color:red">**fixed size**</span> size must be constant expression
- **low-order bits**: 在0的位置, **high-order bits**:在最后位置
- 如果用的bitset 小于given number, 只有**lower-order bits** are used, higher order bits 大于size的 被丢弃
- initialize bits from string char pointer, char pointer lower index 给bitset high order，听起来绕口, 跟读数字顺序是一样的 
- ```bitset<n>b(u)``` **copy** of n low-order bits. Constructor 是 **constexpr** and **explicit**
- ```bitset<n>b(s, pos, m, zero, one)``` , ```bitset<n>b(cp, pos, m, zero, one)``` ```pos``` default 是 0,, ```m``` default 是 ```string::npos```, zero default to ‘0’, one default to ‘1’
- ```set```(set at pos for **bool value** ```v```), ```reset```(turn off bits), ```flip```, 是overloaded, 如果没有提供argument, apply to entire sequence  
    - ```~bitvec[0]```; 等于 ```bitvec.flip(0)```
- ```b.size()``` is constexpr .
- ```b.to_ulong() ``` 如果等号左边的range 小于 它, throw ```overflow_error```
- ```bitset<16> bits; cin >> bits;```: read up to 16 1 or 0 characters from cin, or encounter character 不是1 or 0, or it encounters end-of-file or an input error
- bitset subscript overloaded on const; const version： 返回bool if given index is on. nonconst version 返回type on bit lets us manipulate the bit value at the given index position
- ```regex_match```需要entire sequence match
- ```regex_search``` 只要有substring in the input sequence matches
- ```regex_search``` and ```regex_match``` 都返回bool, argument  ```(seq, m, r, mft)```, match object, match flag type optional, ```seq```是 string, iterator, or null-terminated array,
- ```regex``` operation:
    - ```regex r(re,f)```: re 可以是 string,iterators denoting a range of characters,  pointer to a null-terminated character array, a character flag f optional
- ```sregex_iterator``` call ```regex_search``` to iterate through matches,
    - constructor ```sregex_iterator it(b,e,r)```, ```b,e``` iterator(e.g.string), r object 
    - 是iterator adaptors bound to an input sequence and regex object, 当绑定后, <span style="color:red">自动定义位到first match in given string</span>
        - constructor call ```regex_search```
    - <span style="color:red">dereference iterator, get an ```smatch``` object</span> corresponding to results from most recent search
    - 当increment iterator, calls ```regex_search``` to find next match in string, prefix returns next match, postfix returns old value. 
    - iterater 比较, 如果都是off-the-end 则相等. 如果是绑定到same object and input sequence, 也相等
- ```smatch``` operation: ```ready()```(如果被set 到了```regex_search``` or ```regex_match```), ```prefix()```(sequence before match),```suffix()```, ```size()```(等于match 的 subexpression 个数加1)
    - 对```smatch``` subexpression 操作(是在```smatch``` object 上而不是 ```ssub_match``` object上): ```m.length(n)```, ```m.position(n)```(distance of nth subexpression from start of sequence), ```m.str(n)```, ```m[r]```(获取```ssub_match``` object)
- ```smatch``` for string, ```cmatch``` for char array, ```wsmatch``` for wide string, ```wcmatch``` wide char array
- first ```ssub_match``` from ```smtach``` index at 0 表示match entire pattern
- subexpression use parentheses to denote
- ```[-. ]``` match dash, dot  空格. note: dot in bracket no special meaning 
- Operation on ```ssub_match```
    - ```matched```: 表示whether ```ssub_match``` was matched, 比如optional ```?``` match了
    - ```first second``` : match range
    - ```length()```:  Returns 0 if matched is false
    - ```str()```:	string containing the matched portion
    - ```s=ssub``` : 等于 ```s = ssub.str()```, the convert operator is nonexplicit
- to escape, must use 双backslash, ```\\```
- 可以把regular expression 想成 simple programming language, not interpreted by C++ compiler, compiled at run-time. 
- regular expression 语法正确与否 evaluated at run time. very slow, constructor ```regex``` outside the loop
- ```reg_replace```: ```r```: regex object, ```fmt``` format, ```seq``` can be string or pointer to null-terminated array
    - ```regex_replace(dest, seq, r, fmt, mft)```: dest is output iterator
    - ```regex_replace(seq, r, fmt, mft)``` 返回string
    - ```$i``` <span style="color:red">表示第i个subexpression</span>
    
- ```rand```: uniformly distributed)的 伪随机数(pseudorandom integers), 0 到system-dependent maximum value(```RAND_MAX```): <span style="color:red">问题是当需要floating-point number or non-uniform distribution</span>. need to transform the range, type or distribution
    - ```rand()/RAND_MAX```: precision 低于random floating-number. some floating-point values that will never be produced
- An engine generates a sequence of <span style="color:red">unsigned random numbers</span>.
     -  function-object classes 定义了call operator takes no arguments and returns a random unsigned number
        - ```default_random_engine e1; e1()``` 
    - ibrary defines several random-number engines that differ in terms of their performance and quality of randomness. 
    - 大多数情况, the output of an engine is <span style="color:red">not directly used</span>
    -```e.min()```, ```e.max()``` range 最大值最小值
    - ```e.discard(u)```: <span style="color:red">advance engine</span> by u(unsigned long long) steps,
    - ```e.seed(s)```: reset state of engine using seed
        - 另一方法seed engine when create engine, e.g. ```default_random_engine e2(32767)``` 
        - 通常用 ```time()``` to provide seed,, <span style="background-color:#FFFF00">因此这种方式值用于生成种子 间隔为秒级 或更长的应用</span>
    - 即使是random, 每次return the same sequence of number, useful for debugging 
        -  <span style="background-color:#FFFF00">make that generator (both the engine and distribution objects) static</span>
- A distribution <span style="color:red">uses an engine to generate random numbers of a specified type</span>, in a given range, distributed according to a particular probability distribution.
    - engine pass to distribution, ```u(e)``` , 不可以是 ```u(e())```(是value passed to distribution)
    - 默认template argument: 用```<>``` after template name
        - ```double```: distribution 用于生成floating-point 
        - ```int```: distribution 用于生成integral  type
    -  ```normal_distribution<> n(4,1.5); ``` mean 4, standard deviation 1.5 
- ```bernoulli_distribution b``` is not template  <span style="color:red">是class</span>.  always return a bool value given probability
- C++ programs 不应该使用 ```rand```, 而使用 ```default_random_engine``` along with an appropriate distribution
- declare engine and distribution (may retain the state) outside loop 否则每次数都一样

***

## 2. Variable and Basic Types

<span style="background-color: #FFFF00">**Initialization is not assignment**</span>. Initialization happens when a variable is given a value *when it is created*.(创建变量时 赋予它一个初始值). **Assignment** obliterates an object's current value and replaces that value with a new one (
<span style="background-color: #FFFF00">把对象当前值擦除，用一个新值代替</span>)

#### (a). Initialization, Definition, Declaration, Scope
 
**(1). List Initialization**

```c++
//下面四种初始化都正确

int units_sold = 0;
int units_sold = {0};
int units_sold {0};
int units_sold(0);
```

<span style="background-color: #FFFF00">List Initialization will throw error if the initializer might lead to the loss of information. (编译器将会报错，如果使用列表初始化且初始值存在丢失信息的风险).</span> 如果不用List Initialization 就不会, 会implicit convert


```c++
long double id = 3.1415026536;
int a{ld}, b = {ld}; //error: 存在丢失信息风险

int c(ld), d = ld; // 转化执行，但是丢失了部分值 (truncated)

```

**(2). Default Initialization**

Most classess let us define objects without <span style="color: red">explict initializers</span>. Such classes supply an appropriate default value. e.g. ```std:string s```; ```s``` implicitly initialized to the empty string. 

**(3). Variable Declarations and Definitions**

 - <span style="background-color: #FFFF00">**A declaration makes a name known to the program. A definition creates the associated entity.**</span>
- A variable **declaration**  <span style="background-color: #FFFF00"> specifies the type and name of a variable</span>. A variable definition is a declaration. In addition to specifying the name and type, a **definition** also <span style="background-color: #FFFF00"> allocates storage and may provide the variable with an initial value</span>. 变量声明规定了变量的类型和名字，在这一点上定义与之相同. 但除此之外, 定义还申请存储空间, 也可能会为变量赋一个初始值
- <span style="background-color: #FFFF00"> Variable must be defined exactly once but can be declared many times</span> 变量只能被定义一次，但可以被声明多次
- 如果想声明一个变量而非定义它，在变量前添加extern

```c++
extern int i; //声明i而非定义i

int j; //声明并定义j
```

任何包含了显示初始化的声明既是定义. 给extern 表含的变量一个初始值，抵消了extern的作用

```c++
extern int i = 5; //定义
```

**(4). Nested Scopes**

<span style="background-color: #FFFF00"> 用 :: 访问global variable (explicitly request global variable) </span>

```c++
int reused = 42;
int main(){
    cout << resused <<endl; // 42

    int reused = 0; //新建局部变量，覆盖全局变量

    cout << resused <<" global " << ::resused <<endl; // 0 , 42

}
```




#### (b). Compound Types

A **compount type** is a type that is defined in terms of another type, which is references and pointers

1. reference, pointer:
    - <span style="background-color: #FFFF00">等号两边类型(type)必须相同 </span>, <span style="background-color: #FFFF00">除了一个特殊情况 const reference</span>
         - 比如 ```double dval = 3.14;,int &refVal5 = dval;//error``` 
2. 对于const非reference 非pointer, 等号左右两边等号类型可以不同. 
3. **对于const reference 等号两边可以不同类型，compiler会做转换**  ```const double pi = 3.14; const int & i = pi;```


**Reference** At here, reference is only lvalue reference not rvalue reference

- <span style="background-color: #FFFF00"> reference must be assigned at initlization</span>
- <span style="background-color: #FFFF00">non-const reference 不能assign rvalue, must be lvalue </span>. 
- 程序把引用和初始值绑定(bind)到一起，而不是将初始值拷给引用, 引用无法绑定到另一个对象. 
- <span style="color: red"> **A reference is not an object**. Instead, a reference is just another name for an already existing object </span>


```c++
int val = 1024;
int &refval = val, &r = i; // correct

refval = 2; //val = 2

int &refval2; //error

int &refval3 = 10 ;//error: initializer must be an object

double dval = 3.14;
int &refVal5 = dval; // error: initializer must be an int object
```

We can define multiple references in a single definition

```c++
int i2 = 2048; // i and i2 are both ints 

int i3= 1024, &ri = i3; // i3 is an int;ri is a reference bound to i3 

int &r3 = i3, &r4 = i2; // both r3 and r4 are references
```


**Pointer**

- assign pointer <span style="color:red">需要assign 的类型和被assign 类型compatible</span>. 
- <span style="background-color:#FFFF00">**Pointer is a object whereas reference is not object**</span>
- <span style="background-color: #FFFF00">It is error to copy or try to access the value of an invalid pointer</span>. As when we use an uninitialized variable, <span style="color: red">this error is one that the compiler is unlikely to detect(编译器不会检查access invalid pointer)</span>. The result of accessing an invalid pointer is undefined. 
-  Given two valid pointers of the same type, we can compare them use<span style="background-color: #FFFF00"> the equality(==) or inequality(!=) operator, Two pointers are equal if they hold the same address (两个指针存放的地址相同) </span>
- <span style="background-color: #FFFF00">修饰符 (type modifier \*)仅仅是修饰一个variable</span>,  而非修饰整行所有变量.  Each declarator can relate its variable to the base type differently from the other declarators in the same definition.```int* p1, p2```, p1 是 int pointer, p2 是int, , 如果两个都是pointer 用```int* p1, *p2```
- <span style="background-color: #FFFF00">**deference ```*``` 返回类型是reference**</span>,所以可以用```int *p = &i; *p = 5;//change object```

```c++
double dval;
double *pd = &dval; //ok: initializer is the address of a doub;e

double *p2 = pd;//ok: initializer is a pointer to double

int *pi = pd;//error: types of pi and pd differ, 一个int,一个double

pi = &dval; //error: assigning the address of a double to a pointer to int

//上面两个error 都会compile fail


int Ival;
double *dpi = &Ival;//error: types of pi and pd differ, 一个int,一个double, 也是compile error


```

<span style="background-color:#FFFF00">& 赋值是改变等号左侧 pointer指代对象, \* 不改变指代对象，改变的是指代对象的值 </span>
```c++
int r = 1;
int *p = &r;
int *p2 = p;
    
*p2 = 10; //change pointed value, aslo change value of the object pointer points to

cout << *p <<" , "<<*p2  <<" , "<< r <<endl; //print 10 ,10, 10

int c = 5;
p = &c; //change object that pointer points to

cout << *p  <<" , "<< r <<" , "<< c<<endl;//print 5, 10 , 5

```

```c++
int i = 1024, *p = &i, &r = i;// i is an int; p is a pointer to int; r is a reference to int

int* p1, p2;//p1 is a pointer to int; p2 is an int (not pointer), 

//上面的*， 仅仅修饰了p1, 而非让所有变量的类型一样都是int pointer

int *p1, *p2; // both p1 and p2 are pointers to int
```


**void pointer**: <span style="background-color: #FFFF00">A void* pointer holds an address, but the type of the object at that address is unknown:  </span>. Generally,we use a void* pointer to <span style="color:red">deal with memory as memory</span>, rather than using the pointer to access the object stored in that memory. 



**Pointers to Pointers**

```c++
int ival = 1024;
int *pi = &ival; // pi points to an int

int **ppi = &pi; // ppi points to a pointer to an int


cout << "The value of ival\n"
    << "direct value: " << ival << "\n" 
    << "indirect value: " << *pi << "\n"
     << "doubly indirect value: " << **ppi << endl;//print 1024, 1024, 1024

```

**References to Pointers**: A reference is not an object. Hence, we may not have a pointer to a reference. However, because a pointer is an object, we can define a reference to a pointer:


```c++
int i = 42; 
int *p; //p is a pointer to int

int *&r = p;  // r is a reference to the pointer p

//cannot write as  int &*r = p; 

//because reference(not object) don't have pointer, but pointer has reference


r = &i;// r refers to a pointer; assigning &i to r makes p point to i

*r = 0; 
// dereferencing r yields i, the object to which p points; changes i to 0

```

<span style="background-color: #FFFF00"> **离变量名最近的符号(symbol， 上面例子 &r 的符号& ) 对变量类型有最直接的影响, 因此r是一个引用;**</span>

#### (c). Const Qualifier

1. 非reference, 非 pointer,Const Initialize时候 等号两边type可以不一样, e.g. 
    - ```int a = 0; const double b = a;```
    - ```double a = 0; const int b = a;```
2. reference or pointer, Const Initialize时候 等号两边type 必须strictly 一样

**(1). Reference**

1. ```const```value 必须<span style="color:red">initialize when define</span> 
2. **Const Value-Value**: 
    - **non const -> const**  value e.g.```int val = 5; const int cst = val;```, <span style="background-color:#FFFF00"> 因为const value是通过复制生成，改变原来值，不会改变const value值</span> e.g. ```int val = 3; const int cstRef = val;val = 10;```, ```cstRef = 3``` , ```val = 10``` 
    - **const -> non const**  const (reference or without reference)  initilize non const value; ```const int & cstRef = 3; int val = cstRef```.
3. **Const Ref-Ref**:
    - **Const Ref -> Ref**  <span style="color:red">**Error**</span>  <span style="background-color:#FFFF00"> const reference 不能bind 到non-const reference，因为reference is not object </span> ```const int & ref = 3; int &i = ref; //error```,
    - **Ref -> Const Ref** ✔️ ```int val = 3; int & ref = val; const int &cstRef = ref;```
4. **Ref-Value**:
    - **Ref -> Const Value** ✔️, ```int val = 3; int & ref = val; const int cstRef = ref;```
    - **Const Value -> Ref** <span style="color:red">**Error**</span> ```const int cstRef = 3; int & ref = cstRef;```, 因为Referene 不是object, 这么做有更改Const 可能性
    - **Const Ref -> Value** ✔️, ```const int & cstRef = 3; int val = cstRef;```
    - **Value-> Const Ref** ✔️, ```int val = 3; const int & cstRef = val;```
    - **Const Ref -> Const Value** ✔️,```const int & cstRef = 5;const int val = cstRef;```
    - **Const Value -> Const Ref** ✔️,```const int val = 5;const int & cstRef = val;```
5. ```const reference```, 如果type 不匹配 or 用rvalue expression, 会生成一个**temporary object**, 这样如果改了原来的值, ```const reference```不会改 (因为```const reference```连得是temporary object) e.g. ```double val = 3.14; const int & cstRef = val; ```
    - 如果不是const reference, ```double val = 3.14; int & cstRef = val;  ``` 因为没有**中间值**生成, 改变```val```的值,有改变const reference 风险, <span style="color:red">**Error**</span>
6. ```const reference```生成后 <span style="background-color:#FFFF00">不能直接更改，但可能会被间接更改(没有temporary 中间值 生成)</span> ```int val = 3;const int & cstRef = val;val = 10;``` , ```val = cstRef = 10```


const value 必须initialize when define 

```c++
const int i = get_size(); // ok: initialized at run time 

const int j = 42; // ok: initialized at compile time 

const int k; // error: k is uninitialized const

```
 
const value 可以生成non const value (反之也可以), 但是const reference 不可以生成 nonconst reference (nonconst reference 可以生成const reference)
```c++
int val = 42;
const int cst = val; // ok: nonconst val -> const val

const int &  cstRef = val;
int jVal= cst; // ok:const val -> nonconst val

int & jRef = cstRef; //error const Ref -> non const Ref

int &jVal2 = val;
const int & cstRef2 = jVal2; //ok: non const Ref -> const Ref

```

```const int bufSize = 512;``` <span style="color: red"> the compiler will usually replace uses of the variable with its corresponding value during compilation.</span> That is, the compiler will generate code using the value 512 in the places that our code uses bufSize. Compiler会找到代码中所有用到bufSize的地方，然后用512代替。


```c++
//不能用非const reference 指向const object

const int ci = 1024;
int &r2 = ci;// error: non const reference to a const object

int i = 42;
```

**One exception for const references**: initailize const from any expression that can be converted to the type of the reference. <span style="background-color: #FFFF00">当initilize const reference, 我们可以用任意表达式. </span>

```c++
int i = 42;
const int &r1 = i; // we can bind a const int& to a plain int object 

const int &r2 = 42; // ok: r1 is a reference to const

const int &r3 = r1 * 2; // ok: r3 is a reference to const

int &r4 = r1 * 2; // error: r4 is a plain, non const reference

```
to understand this exception in initialization rules:

```c++
double dval = 3.14;
const int &ri = dval; //okay,

dval = 6.28;
cout<<ri << ","<<dval<<endl; //print 3, 6.14


int Ival = 5;
const int & ri2 = Ival; //okay,
const int & ri3 = Ival*2; //okay,
    
Ival = 30;
cout<<ri2<<" ,"<<ri3 << ","<<Ival<<endl; //print 30, 10, 30

```

上面例子中.To sure object to which ```ri``` is bound is an int, compiler transforms the code into something like (但不适用```ri2```, 因为initialize ```ri2```时, 没有生成temporary object). In this case, ```ri``` is bound to a **temporary object**. A temporary object is an unnamed object created by the compiler when it needs a place to store a result from evaluating an expression. 

```c++
const int temp = dval;//create a temporary const int from the double

const int &ri =temp;//bind ri to that temporary

const int temp2 = Ival*2;//create a temporary const int from the int

const int &ri3 =temp2;//bind ri to that temporary

```


**A Reference to const May Refer to an Object That Is Not const**: 当```const reference```initialized时, 并没有generate **temporary object**, 可能会被间接更改```const refernce```的value

```c++
int i = 60;
int&r1=i; //r1 boundto i

const int &r2 = i; //r2 also bound to i; but cannot be used to change i


r1=0; // r1 is not const; i is now 0
//r2 = 0;//error: r2 is a reference to const

cout<<i<< ", "<<r1<<", "<<r2<<endl; //print 0, 0 , 0

```

**(2). Pointer and const**

1. Level Const
   - **low-level const**(object is const): const <span style="background-color: #FFFF00">在pointer/reference 左面</span>表data is const, cannot change underlying data value. but can point to different underlying. ```const int & j = 5 ```是 low -level const 
   - **top-level const**(pointer is const): const <span style="background-color: #FFFF00">在pointer 右面有pointer在时候表示 pointer is const (**a const pointer**), 如果没有pointer 在表示数据const (```const int a = 0```</span>, 不能改变指向对象，但可以改变the value of underlying object)
2. <span style="background-color: #FFFF00">The distinction between **top-level** and **low-level** matters when we copy an object</span>. When we copy an object, **top-level consts can be ignored:** e.g. ```const * const int = const * int```
    -  <span style="background-color: #FFFF00">对于pointer之间的copy, 如果忽略Low Level const</span>, <span style="color:red">**Error**</span> 
       - **Pointer of Const -> Pointer**:  <span style="color:red">**Error**</span> e.g. ```int val = 42; const int * p3Low = val;int * p3 = p3Low;//error```
       - **Const Value -> Pointer**  <span style="color:red">**Error**</span> e.g. ```const double cstVal = 3.14; double *ptr = &cstVal; //error```
       - **Const Pointer -> Pointer**:✔️ 因为可以忽略top-level constant e.g. ```int i = 0; int * const p = &i; int *a = p;```
    - 对于value 到 const pointer 的copy, 可以忽略low-level const
       -  **Value -> Const Pointer** ✔️  e.g. ```int val = 1; int const * const pLowTop = & val;```
       -  **Const Pointer -> Value** ✔️ ```int j = 0; const int * cstPtr = & j; int val = *cstPtr;```
       -  **Pointer -> Const Pointer** ✔️ ```int i = 0, *a = & i; const int * const p = a;```
3.  The types of a pointer and the object to which it points must match(等号左右两边类型必须match). 


```c++
int i = 0;
int *const p1Top = &i; // const is top-level; we can't change the value of p1Top

const int ci = 42; //  const is top-level; we cannot change ci

const int *p2Low = &ci; //  const is low-level; we can change p2Low

const int *const p3LowTop = p2; // right-most const is top-level, left-most is not

const int &r = ci; // const in reference types is always low-level


//top level constant can be ignored

i = ci; // ok: copying the value of ci; top-level const in ci is ignored 

p2Low = p3LowTop; // ok: pointed-to type matches; top-level const in p3LowTop is ignored


```

<span style="background-color: #FFFF00">On the other hand, low-level const is never ignored.(lower-level 从不会被忽略)</span>.  When we copy an object, both objects must have the same low-level const qualification or there must be a conversion between the types of the two objects(拷贝 输出对象必须具有相同的底层const 资格). In general, we can convert a nonconst to const but not the other way round:

```c++
int *p = p3LowTop; // error: p3LowTop has a low-level const but p doesn't

p2Low = p3LowTop; // ok: p2Low has the same low-level const qualification as p3LowTop

p2Low = &i; // ok: we can convert int* to const int*

int &r = ci; // error: can't bind an ordinary int& to a const int object 

const int &r2 = i; // ok: can bind const int& to plain int

```

The first exception is that we can use a pointer to const to point to a nonconst object: 可以用const pointer指向non-const object

```c++
const double cstVal = 3.14; // pi is const; its value may not be changed

double *ptr = &cstVal; // error: ptr is a plain pointer

const double *cptrLow = &cstVal; // ok: cptr may point to a double that is 

*cptrLow = 42; // error: cannot assign value to *cptr

double dval = 3.14; // dval is a double; its value can be changed
 
cptrLow = &dval; // ok: but can't change dval through cptr

```

```c++
double pi = 3.14159;
const double *const pip = &pi; 
// pip is a const pointer (在pointer右边的const) to a const object

```

#### (d). Constexpr

A **constant expression**: value cannot change and can be evaluated at compile time. A **literal** is a constant expression. By declaring **constexpr**, we can ask compiler to verify that a variable is a constant expression.  

Const 的缺点, 有时候我们需要**constant expression**, 但用**const**, 生成却不是**constant expression**. 比如, 下面例子even though```sz``` is a ```const```, the value of its initializer is not known until <span style="color:red">run time</span>
```c++
const int limit = 20;
//limit is a constant expression

const int sz = get_size(); 
//sz is not a constant expression

constexpr int sz2 = get_size(); 
//只有当get_size() is a constexpr function, sz2才是constexpr function

```

The type we can use in a **constexpr** declaration are known as **literal types**.
- <span style="background-color: #FFFF00"> arithmetic, reference, pointer types are **literal types**</span>, 
- <span style="background-color: #FFFF00"> **string** types 不是**literal types**, 不能用于define varaibles as **constexpr**</span>. varaibles defined inside a function 因为没有fixed address, 不能用**constexpr**,
- The **address** of an object defined  <span style="color:red">outside</span> of any function is **constant expression**, and **some objects have fixed address** so may used to initialzie a **constexpr** pointer.

- **Pointers and constexpr**

```c++
const int * p = nullptr; 
//p is a pointer to a const int (low level)

constexpr int * q = nullptr
//q is a const pointer to int (top level)

```
p and q are quite different. The difference is ```constexpr``` imposes a ```top-level const``` on pointer

```c++
constexpr int * pTop = nullptr; 
//pTop is a constant pointer to int that is null

const int tempInt = 10;
pTop = & tempInt; //Error, cannot assign const int to int * const


int j = 0;
constexpr int i = 42; // i is const int

constexpr const int * pLowTop = &i; 
// pLowTop is const pointer to the const int i

constexpr int * p1Top = & j
//p1Top is a const pointer to the int j

constexpr int * pTop2 = &i; 
// error, fix it is const int * pLow = & i

```

#### (e). Type Aliases

**Type Alias** is a name that is a synonym for another type 

1. **typedef**: ```typedef double wages```, typedef can also include type modifiers (such as reference, pointer) that define compound types 
2. **using**: ```using SI = Sales_item;```

**Pointers, Const, and Type Aliases**

```c++
typedef char *pstring;
const pstring cstr = 0; 
//cstr is a constant pointer to char

//是pointer const， 而不是数据类型data type是const 

const pstring* ps; //ps is a pointer to a constant pointer to char

```

```const pstring```(不等于 ```const char * ```) is constant pointer to char, not a pointer to ```const char```, <span style="color:red">如果直接replace the alias with its correspoinding type 是错误的, **Error**</span>, 如果想要pointer to ```const char```, 需要重新定义```typedef const char * pstring```


#### (f). Auto 

- **auto** tells the compiler to deduce the type from the initializer. By implication, a variable that uses **auto** as its type specifier <span style="background-color: #FFFF00">must have an initializer</span>.
- **auto** can define multiple variables in single line, 但是initializers for all the variables in the declaration must <span style="background-color: #FFFF00">have types that are consistent</span>
- **auto** is not always exactly the same as initializer types. 当用auto时候，<span style="background-color: #FFFF00">top level const通常会被忽略, low-level const 会被kept</span>, <span style="color:red"> 
- 用```auto &``` or ```auto*``` to auto-deduced type, <span style="background-color: #FFFF00">会keep top level, low-level const</span>
- 不能用**auto** to deduce the type from a list of initializer ```auto a = {1,2,3}; //error```
- Deduce: 
   - 用```auto``` deduced ```int&``` or ```const int&``` is ```int```
   - deduce ```auto v = &i``` from reference is pointer
   - deduce ```auto v = *i``` from deference is value (因为deference 返回是reference,但是```auto```对于reference deduce是value)
   - 用reference 表示deduce 是reference type, 用pointer 表示deduce是pointer type, 会keep top-level const, ```auto & m = cval, *p = & cval;``` m是reference type, p是pointer type
   - <span style="background-color: #FFFF00">用```auto``` deduced array 是pointer type</span>

可以定义多个variables in single line, 但是需要都是一个类型(type)的
```c++
auto i = 0, *p = &i;
//okay i is int and p is pointer to int

auto sz = 0, pi = 3.14; 
//error: inconsistent type for sz and pi

```

忽略top-level const and keep lower-level const 
```c++
int i = 0, &ref = i;
auto a = ref; // a is an int


const int cval = i, &cstRef = cval;
auto b = cval; //b is an int (top-level const dropped)

auto c = cstRef; //c is an int (cr is an alias for cval whose top-level const dropped)

auto d = & i; //d is an int*

auto e = &cval; 
//e is const int * (& of a const is low-level const, 把top-level 转成low-level)

```

auto + reference
```c++
auto & g = cval; // g is a const int & 

auto & h = 42; //error, can't bind a plain reference to a literal

const auto & j = 42; //const reference

```

Deduced 的type 必须consistent 
```c++
auto k = cval, &l = i; // k is int, l is int& 

auto & m = cval, *p = & cval;
//m is const int&, *p 是  const int * (a pointer to const int)

auto &n = i, *p2 = & cval;
//error, n is int&, p2 is const int * (not int*)

```

#### (g). Decltype 

- **decltype**: compiler analyzes the expression to determine its <span style="background-color: #FFFF00">type</span> but does <span style="background-color: #FFFF00">not evaulate the expression </span>
- <span style="color:red">**decltype** array 是array type, 而不是pointer type</span>
- handles **top-level const** subtly different from **auto**
    - **variables**: <span style="background-color: #FFFF00">include **top-level const** and reference</span>
    - **expression**: we can get the type that expression yields. <span style="background-color: #FFFF00">注:Dereference operator(\*) yields type as reference</span>
    - **function**, ```decltype(functionName)``` 返回的是function return type, not a pointer to function type.
    - **decltype** and **auto** difference: deduction done by **decltype** depends on the form of its expression. 
        - <span style="background-color: #FFFF00">切记```decltype((variable))```结果永远是引用，```decltype(variable)``` 只有当variable 本身是引用时, 结果才是引用</span>

compiler 不会called ```f```, 但是uses the type that such a call would return as type of ```sum```. 

```c++
decltype(f()) sum = x; //sum has whatever type f returns 

```

use decltype for variable, returns type including **top-level const**

```c++
const int cval = 0, & cRef = cval;
decltype(cval) x = 0; //x is const int

decltype(cRef) y = x; //y is const int& 

decltype(cRef) z;//error: z is const int& which must be initalized

```

use decltype for expression. ```decltype(r)``` is a reference type. but ```r+0``` is an expression that yieds a **nonreference type**. **Dereference operator** is an example of an expression for ```decltype``` returns a **reference**. When we deference a pointer, we get the object to which the pointer points  ```decltype(*p)``` is ```int&``` not ```int```.

```c++
int i = 42, *ptr = & i, &ref = i;
decltype(ref + 0) b; //addition yields an int, b is int (uninitialized)

decltype(*ptr) c; //error: c is int& and must be initialized

```

当我们apply ```decltype``` wrap the variable's name in one ore more parentheses, compiler will evaluate the operand as an expression. A variable is an expression that can be the left-hand side of an assignment. As a result, ```decltype``` on such an expression yields a reference.


```c++
decltype((i)) d; //error: d is int& and must be initialized

decltype(i) e;//ok: e is an int (uninitialized)

```
***

<br/> <br/> <br/>

## 3. Strings, Vectors, and Arrays

很多需要dynamic memory can use a vector or a string to manage the necessary storage. <span style="background-color: #FFFF00">vectors and strings avoid the complexities involved in allocating and deallocating memory.</span>

#### (a). Namespace using Declarations

- ```std::cin``` use the **scope operator(::)** says want to use the name ```cin``` from the namespace ```std```
- ```using namespace::name``` : A **using declaration** let us use a name from a namespace without qualifying the name with a ```namespace_name:: ```prefix
- <span style="background-color: #FFFF00"> Headers should not not include using declarations</span>. 原因: the contents of a header are copied into the including program's text. If a header has a ```using``` declaraction. 那么every program that includes that header gets that same ```using``` declaraction. As a result, program didn't intend to use the specified library name <span style="color:red">might encounter unexpected name conflicts.</span>

#### (b). String 

**(1). Initialization**

- ```string s2(s1)``` ```s2``` is a copy of ```s1``` 
- ```string s2 = s1``` 与```s2(s1)``` 作用一样
- ```string s3("value")``` ```s3``` is a copy of **string literal**， not including the null(null在const char\*的结尾处)
- ```string s3 = "value"```, 与```string s3("value")```一样, copy of **string literal**
- ```string s4(n,'c')```, initialize ```s4``` with n copies of character ```c```

用```=``` 初始化叫做**copy initialization**, 忽略等号的初始化 是**direct initialization**

```c++
string s5 = "hiya"; //copy initilization 

string s6("hiya"); //direct initialization

string s7(10, 'c'); //direct initialization

```
**(2). Getline**

we can use ```getline``` function instead of ```>>``` operator. This function reads the given stream up to the end of the line (*not including the newline*) to store in string.  

```c++
string line 
//read input a line at a time untile end-of-file

while(getline(cin,line)) // or use while(cin >> line)
    
    if(!line.empty())
        cout << line << endl;
```

**(3). compare**

1. 如果两个strings 长度不一样 且 每个位置char都一样, 那么较短的string ```< ``` 较长的
2. 如果有位置不一样, 那么对比那个位置两个char, 根据字母表，靠前的char的string 更小

```c++
string str = "Hello";
string phrase = "Hello World";
string slang = "Hiya";
//str < phrase, phrase < slang 

```

**(4). Adding Literals and strings**

当我们用string + character literals时,<span style = "background-color:#FFFF00"> 必须保证```+```号左右两侧至少有一个是string type </span>

```c++
string s1 = "hello";
string s4 = s1 + ", "; // ok: adding a string and a literal 

string s5 = "hello" + ", "; // error: no string operand string

s6 = s1 + ", " + "world"; // ok: each + has a string operand string

s7 = "hello" + ", " + s2; // error: can't add string literals

//因为 s7 = ("hello" + "), " + s2; ("hello" + ") no strings

```

**(5). Dealing with char in string**

- ```isalnum(c)```: true if c is a letter or digit
- ```isalpha(c)```: true if c is a letter
- ```iscntrl(c)```: true if c is a control character. <span style="color:red">A control character is a character that does not occupy a printing position on a display. 比如换行 ```\n``` </span>
- ```isdigit(c)```: true if c is a digit
- ```isgraph(c)```: true if c is not a space but is printable, <span style="color:red">A graph character是可以用来打印的character, 除了空格</span>
- ```islower(c)```, ```isupper(c)```: true if c is a lowercase/upper letter 
- ```isprint(c)```: true if c is a printable character. <span style="color:red">printable character =  space + graph character </span>
- ```ispunct(c)```: true if c is punctuation character (不是control character, a digit, a letter or a printable whitespace)
- ```isspace(c)```: true if c is whitespace(i.e. a space, tab, vertical tab, return(回车符), newline(换行符), or formfeed)
- ```isxdigit(c)```: true if c is 十六进制(hexadecimal digit)
- ```tolower(c)```, ```toupper(c)```: 如果c是大/小写字母, 变小/大写, 否则不变

**(6). Change char in string**

use for loop and reference 
```c++
string s("Hello World!!!");
for (auto &c : s) // for every char in s (note: c is a reference)

    c = toupper(c); 
cout << s << endl;
```

#### (c). Vector

We can define ```vector``` to hold objects of most any type. Becauses <span style="background-color:#FFFF00"> references are not objects, **we cannot have a vector of references** </span>

**(1). Initialization**

- ```vector<T>v1```: vector hold objects of type T and v1 is empty 
- ```vector<T>v2(v1)```: v2 has a copy of each element in v1
- ```vector<T>v2 = v1```: v2 is copy of the each element in v1
- ```vector<T>v3(n,val)```: v3 has n elements with value val
- ```vector<T>v4(n)```: v3 has n copies of a  <span style="color:red">value-initialized object</span>(e,g, int 默认是0, string 默认是空)
- ```vector<T>v5{a,,b,c...}```: v5 has as many elements as initializers;  <span style="color:red">elements are initialized by corresponding initializers</span>
- ```vector<T>v5 = {a,b,c}```; 与上面一样

 
当我们提供两个数, 比如 对于```vector<int>```, 两个数可以表示size and value, 也可以表示size 为2的两个intial values, 用花括号或者方括号会有歧义. 这时<span style="background-color:#FFFF00">  ```()```are used to construct object whereas ```{}``` is use to initialize the object,</span> . 对于```vector<string>```, ```{}```,<span style="background-color:#FFFF00"> 如果compiler 发现```{}``` 不能initialize object, 会尝试去```()```来代替```{}```initialize</span> 

```c++
vector<int>v1(10,1); //initialize vector 10 个 1

vector<int>v2{10, 1}; //initialize vector 包括 10 和 1

vector<string>v3("hi"); //error


vector<string>v4{10}; //有10个默认的string

vector<string>v5{10, "hi"}; //有10个"hi"

//v4 and v5 the initializers can't be element initializers. 

//compiler looks for other ways to initialize the object from given values

```



如果用copy constructor, 需要type consistent,
```c++
vector<int>ivec;
vector<string>svec(ivec); //error

```

要使用```size_type```, 需要注明类型
```c++
vector<int>::size_type; //正确

vector::size_type; //错误

```

**(2) Vector Grow Efficiently***

**Key Concept: Vector Grow Efficiently**: 定义空的vector 更有效. <span style="background-color:#FFFF00">It is often unnecessary- can result in poorer performance—to define a vector of a specific size (例外是all elements actually need the same value).</span> It is more **efficient** to define an <span style="background-color:#FFFF00">**empty vector and add elements**</span> as the values we need become known at run time.

for loop vector 不能改变vector的大小(size) (add, delete)


#### (d). Iterators

All of library **containers** have **iterators**. but only a few of them support the subscript operator 

- ```begin``` returns an iterator that deontes the first element. <span style="background-color:#FFFF00">如果object是const, 返回的是```const_iterator```,如果object不是const, 返回的是```iterator```</span>
- ```end``` position **one past the end** (尾元素的下一个位置), does not denote an element, 所以 <span style="color:red">it may not be incremented or deferenced</span>
- if a vector is const, 只能使用 ```const_iterator```type. Within a non const vector , we can use either ```iterator``` or ```const_iterator```
- ```>, >=, <, <=``` Iterator 比较, 如果Iterator refer的element 另一个iterator 指得element 在前面出现, 就是小于

```c++
vector<int>::iterator it;
string::iterator it2;//it can read and write

vector<int>::const_iterator it3; //it3 can read but not writer


const vector<int>cv;
auto it1 = cv.begin(); //return vector<int>::const_iterator

auto it3 = v.cbegin(); // eturn vector<int>::const_iterator

```


**(1). Dereference and Member Access**

```(*it)->member``` is a synonym as ```it->member```

```c++
(*it).empty() //dereference it and calls the member empty on object

*it.empty // error: attempts to fech the the member empty from iterator 

//but iterator has no member named empty

```
**(2). Some vector Operations Invalidate Iterators**

比如vector insert 也许会invalidate iterators: It is import to realize 当用iterator loop 不要add remove elements to the container which iterator refer. 


#### (e). Arrays

- Unlike **vector**, <span style="background-color:#FFFF00">**array** have fixed size; we cannot add elements to an array. </span>
- 因为arrays have fixed size, they sometimes offer better run-time performance for specialized applications, 但是相应也损失了一些灵活性(flexibility)
- array size是part of array's type. The dimension must be known at compile time, which is [**constant expression**](#Constexpr)
- 默认值初始化会令数组含有未定义的值 (a default-initialized array of )
- As with vector, arrays hold objects. <span style="background-color:#FFFF00">Thus **there are no array of references**(array 不是objects), 但可以有reference to array</span>.
- <span style="background-color:#FFFF00">When define an array, we must specify a type. We cannot use **auto** to deduce the type from a list of initializers</span>

```c++
unsigned cnt = 42; //not constant expression

constexpr unsigned sz = 42; //constant expression

int arr[10]; // array of 10 ints

int *parr[sz]; // array of 42个 pointers to int 

string bad[cnt]; //error: cnt is not constant expression

string strs[get_size()]; //okay if get_size is constexpr, error otherwise

```

**(1). Initializaing Array Element**

- 如果用list initialize the elements in array, 可以忽略维度. 
    - <span style="background-color:#FFFF00">If we omit the dimension, the compiler infers dimension from the number of initializers, </span>
    - <span style="background-color:#FFFF00"> 如果specify a dimension, the number of initializers 不能超过 the specified size.</span>
- ```char arrays``` are special to have an additonal form. <span style="background-color:#FFFF00">can initialize from a string literal and string literals end with a **null character** </span>. That null character is copied into the array along with the characters in the literal. <span style="background-color:#FFFF00">用list initialization， 需要声明```\0```否则不会加上, 如果不用string literal, 会自动加上```\0``` </span>
- <span style="background-color:#FFFF00"> cannot initialize an array as copy of another array. 也不能assign one array to another </span> 有一些compiler 允许array assignment as a compiler extension. 但是最好不要用这种nonstandard方法


```c++
const unsigned sz = 3;
int ia1[sz] = {0,1,2}; //array of 3 inits with invalue 0, 1, 2

int a2[] = {0, 1, 2};  //array of 3 dimension3

int a3[5] = {0, 1, 2}; // equivalent to a[3] = {0,1,2,0,0}

string a4[3] = {"hi", "bye"}; // same as a4[] = {"hi", "bye", ""}

int a5[2] = {0,1,2}; // error: too many initializers

```

char array initialization
```c++
char a1[] = {'C', '+', '+'}; // list initialization, no null

char a2[] = {'C', '+', '+', '\0'}; // list initialization, explicit null 

char a3[] = "C++"; // null terminator added automatically

const char a4[6] = "Daniel"; // error: no space for the null!

```

不能用copy initialize, 也不能assign array to another 
```c++
int a[] = {0, 1, 2}; // array of three ints

int a2[] = a; // error: cannot initialize one array with another 

a2 = a; // error: cannot assign one array to another

```

**(2). Understanding complicated Array Declarations**

因为an array is an object, we can define both pointers and references to arrays. Define arrays that hold pointer 比较直接, defining a pointer or reference to an array 稍微复杂. <span style="color:red">简单方法是从inside括号 from outside 再从右向左度，离变量近的类型对变量有直接影响</span>

- ```int *arrayPtr[10];```,  是array, size 为10, 有10个 pointer to int
- ```int (*Parray)[10];```, 是pointer, 指向 size 为10 的 int array
- ```int (&arrRef)[10];```, 是reference, refer size 为10 的 int array
- ```int *(&arry)[10] = ptrs```, 是reference, refer size 为10的array, array hold pointer to int

```c++
int *arrayPtr[10]; //arrayPtr is an array of 10 个 pointers to int 

int &refs[10] = ...; //error: no arrays of references

int (*Parray)[10] = & arr; //Parray 是pointer points to an array of 10个 int

int (&arrRef)[10] = arr; //arrRef refers to an array of 10 个 ints

```

**(3). Access the Elements**

当我们use a variable to subscript an array, we should define variable to have type ```size_t```, it defined in the ```cstddef```header, which is the c++ version of ```stddef.h``` header from C library. The difference between array and vector subscript 是 subscript operator```[]```` used in vector 只能applies to operands of vector, 而array subscript operator 是C++ 语言自己定义的

```c++
unsigned scores[11] = {};
for(auot i: scores)
    cout<<i<<endl;
```

**(4). Pointers and Arrays**

- <span style="background-color:#FFFF00">when we use an array, compiler 通常converts the array to a pointer</span>
-  We can obtain a pointer to an array element by taking the address of that element using address-of operator(```&```); e.g. ```int nums[] = {1,2,3}; int * p = &nums[0];```
- <span style="background-color:#FFFF00">when we use an object of array type, we are really using a pointer to the first element in that array</span>, array实际上是指向第一个element的pointer, operations on pointer.
    - <span style="background-color:#FFFF00">当我们用array as an initializer, defined using auto, the deduced type is a pointer, not an array </span>
    - <span style="background-color:#FFFF00">但是用到```decltype```, 还是会deduced 出array, 不会是pointer</span>
- 可以用 pointer initialize vector ```int arr[] = {0,1,2,3,4,5}; vector<int>iv(begin(arr), end(arr)); vector<int>iv2(arr + 1, arr+4);```, ```iv2```的vector分别来自```arr[1], arr[2],arr[3]```


```c++
string nums[] = {"one", "two", "three"}; // array of strings 

string *p = &nums[0]; // p points to the first element in nums

string *p2 = nums; // equivalent to p2 = &nums[0]

```

用array as intializer for **auto**, deduced type是pointer, not array 

```c++
int ia[] = {0,1,2,3,4,5}; // ia is an array of ten ints

auto ia2(ia); //ia2 is an int* that points to the first element in oa

ia2 = 42; // error : ia2 is a pointer, can't assign an int 

auto ia3(&ia[0]); //now it's clear that ia3 has type int*

```

decltype(array) is array

```c++
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9}; // decltype(ia)  is array not pointer

int i = 0, *p = &i;
ia3 = p; // error: can't assign an int* to array 

ia3[4] = i; // ok: assigns the value of i

```

**(5). Pointers Are Iterators**

Pointers to array elements (array) support the same operations as **iterators** on vector and string. We can use pointers to traverse the elements in an array.Array的```begin``` 和 ```end``` 返回的是pointer of object


```c++
int arr[] = {0,1,2,3,4,5};
int *p = arr; // p points to the first element in arr

++p; // p points to arr[1]

int *begin = begin(arr);//pointer to the first element in arr

int *last = end(arr); // pointer one past the last element in arr

```

**(6). Pointer Arithmetic**

- 当add an integer to a pointer(array), the result is a new pointer, the new pointer points to the element the given number ahead of (or behind ) the original pointer. 当用两个pointers 相减, 得到the distance between those pointers. The pointers must point to elements in the same array 
- <span style="background-color:#FFFF00">我们可以比较两个指针, 当这两个指针来自于同一个数组</span> ```int * b = arr, *e = arr + 5; if(s<e)...```, 如果不来自同一个数组, 不能比较, 因为比较毫无意义
- 指针运算. The result of subtracting two pointers a library type named ```ptrdiff_t```, like ```size_t```, the ```ptrdiff_t``` type is a machine-specific type and is defined in the cstddef header, 因为相间可能有negative distance, <span style="background-color:#FFFF00">```ptrdiff_t``` is a signed integral type.</span> 
- 可以用pointer +/- 整数, 再deference resulting pointer, ```int last = *(arr + 4); ``` 括号是必须的当deference from pointer arithmetic
- <span style="background-color:#FFFF00">`**we can use subscript operator on any pointer as long as thet pointer points to  an element (or one past the last element) in an array, 可以用+/- number 用作subscript**</span>
    - Array 和 vector/string subscript operators 不同是, <span style="color:red">`the library types(vector/string) force the index with **unsigned**, 但是built-in subscript operator 可以是negative value(is not an unsigned type)</span>

```c++
constexpr size_t  sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip=arr; //equivalent to int *ip = &arr[0];

int *ip2 = ip + 4;//ip2 points to arr[4], the last element in arr

int *ip3 = ip + 10;//error : arr has only 5 elements

auto n = end(arr) - begin(arr); // n is 5, the number of elements in arr

```

比较指针

```c++
int *b = arr, *e = arr + sz; 
while (b < e) {
    // use *b ++b;

}

int i = 0, sz = 42;
int *p = &i, *e = &sz;
while (p < e)
    // undefined: p and e are unrelated; comparison is meaningless! 

```

上面的也同样适用于null pointer and for pointers that point to an object that is not an array(两个指针必须指向同一个对象or 该对象下一个位置). if ```p``` is null pointer, 可以加减integral constant expression whose value is 0 to p. 我们也可以用null pointer 减去null pointer = 0

Deference
```c++
int ia[] = {0,2,4,6,8}; // array with 5 elements of type int

int last = *(ia + 4); // ok: initializes last to 8, the value of ia[4]

//括号是必须的

int last2 = *ia + 4; // = 0(ia[0]) + 4 = 4
```

subscript operator
```c++
int arr[] = {0,2,4,6,8};
int *p = arr+2; //p points to the third element in arr

int j = p[1]; // p[1] = *(p+1); = arr[3] = 6;

int k = p[-2]; // p[1] = *(p-2); = arr[0] = 0;
```
 
**(7). C-Style Character Strings**

- C-style strings are not a type, 而是convention to use character strings. Strings that follow this convention 储存在character arrays and **null terminated \0** 
- C library string.h provides a set of functions 在C++中 functions 被定义在 ```cstring``` header
    - ```strlen(p)```: 返回p的长度, <span style="color:red">not counting the null</span>
    - ```strcmp(p1,p2)```: compares p1 and p2 for equality. Returns 0 if p1 == p2, a positive value if p1 > p2, a negative value if p1 < p2
    - ```strcat(p1,p1)``` : Appends p2 to p1. Returns p1. <span style="color:red">p1必须large enough to hold result </span>
    - ```strcpy(p1,p2)``` : copies p2 into p1. Returns p1. <span style="color:red">p1必须large enough to hold result</span>


<span style="background-color:#FFFF00"> 用strlen 必须有```\0``` terminate. 如果没有 null terminated, the result is undefined</span>. The most likely effect of  this is that ```strlen``` will keep looking through the memory THAT follows ```ca``` until it encounter a null character
```c++
char ca[] = {'C', '+', '+'}; // not null terminated

cout << strlen(ca) << endl; // disaster: ca isn't null terminated

```

Compare string: when we use an array, we really use a pointer to the first element in the array. 下面例子因为pointer do not address the same object, so the comparison is undefined. 我们可以用 ```strcp```对比const char array的content
```c++
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if (ca1 < ca2) // undefined: compares two unrelated addresses


if (strcmp(ca1, ca2) < 0) // same effect as string comparison s1 < s2

```

concat： 对于string, 可以直接用加号, 但是<span style="color:red">doing the same with two arrays would be an error.</span>. 因为expression tries to add two pointers which is illegal and meaningless.  如果largeStr不足够大, 很有可能引发error.如果我们更改largeStr, 又要重新检查它的size. Programs with suck ecode are **error-prone**
```c++
//对于string, 可以直接
string largeStr = s1 + " " + s2;

// disastrous if we miscalculated the size of largeStr

strcpy(largeStr, ca1); // copies ca1 into largeStr

strcat(largeStr, " ");  // adds a space at the end of largeStr

strcat(largeStr, ca2); // concatenates ca2 onto largeStr

```

**(8). Mixing Library strings and C-Style Strings**

- initialize string from a string literal  ```string s("Hello World")```
- **string -> const char pointer: c_str()** returns a a pointer to the beginning of a null-terminated character array that holds the same data in string```const char *str = s.c_str()```. It is not guaranteed to be valid indefinitely.  任何s的subsequent use 也许改变 s value 从而invalidate this array. <span style="background-color:#FFFF00"> 所以最好是先copy string 再call c_str(), 或者call c_str() copy 一份</span>


```c++
string s = "abc";
const char* p = s.c_str();s
s = "xyz";
cout<<p[1]<<endl; //print y

```


#### (f). Multidimensional Arrays

严格讲, no multidimensional arrays in C++, 实际上是refered to arrays of arrays. 

**(1).Initialization**
- initialize all elements to 0 ```int arr[10][20][30] = {0}; ``` 只能初始化0，不能初始化别的数
- initialize whole array ```int ia[2][2] = {\{0, 1},  {2,3}};``` or ```int ia[2][2] = { 0,1,2,3};```
- initialize 第一列的数 ```int ia[3][4] = {\{0}, {4}, {8}};```, 只有```ia[0][0] = 0```, ```ia[1][0] = 4```, ```ia[2][0] = 8```, 其他数都是0.
- initialize 第一行的数 ```int ix[3][4] = {0,3,6,9};``` 只初始化第一行，剩下都是0



```c++
int ia[3][4];

// array of size 10; each element is a 20-element array whose elements are arrays of 30 ints

int arr[10][20][30] = {0}; //initialize all elements to 0

int ia[3][4] = { {0, 1, 2, 3},  // three elements; each element is an array of size 4 

    {4, 5, 6, 7},   {8, 9, 10, 11} };
//The nested braces are optional , 等于下面的

int ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};

// explicitly initialize only element 0 in each row, 只初始化每行第一个元素，剩下是0

int ia[3][4] = { \{ 0 }, { 4 }, { 8 } };

// explicitly initialize row 0; the remaining elements are value initialized

int ix[3][4] = {0, 3, 6, 9}; 

int (&row)[4] = ia[1]; // binds row to the second 4-element array in ia

```

**(2). loop through array**

注意外层for loop, 我们用了reference, 因为我们避免 normal array to pointer conversion.因为<span style="background-color:#FFFF00"> auto deduced array type是pointer(指向该数组首元素的指针)</span>, 比如下面最后的例子不用reference, deduced to pointer, 无法compiled 

```c++
size_t cnt = 0;
for (auto &row : ia) // for every element in the outer array

    for (auto &col : row) { // for every element in the inner array 
    
           ++cnt; 
    }

for (const auto &row : ia) // for every element in the outer array

     for (auto col : row) // for every element in the inner array, col is int

        cout << col << endl;

//上面的array 如果不用reference, auto deduced type是pointer 

for (auto row : ia) //

     for (auto col : row) // 

        cout << col << endl;
```


**(3). Pointers and Multidimensional Arrays**

- 当程序使用多维数组名字时, <span style="background-color:#FFFF00">会自动将其转化成a pointer to the first element in the array</span>
- when you define a pointer to a multidimensional array, remember that a multidimensional array is a an array of arrays
- iterate 时候可以用auto 去deduced array type, deduced 的是一个pointer to 最外层的指针

```c++
int ia[3][4]; //有三行, 每行有4个

int (*p)[4] = ia; //p is a pointer 指向array of 4 ints 

//上面（）不能省去, int *p[4], 是array of size 4, hold int pointer

//ia指向的是第一行的array (size of 4)

p = &ia[2]; //p points to the last element in ia


//iterate

for(auto p = ia; p != ia + 3; ++p){
    //q points to the first element of an array of 4 ints, q points to an int

    //use auto to deduced array is pointer

    for (auto q = *p; q != *p+4; ++q)
        cout << * q << " ";
    cout<<endl;
}

for(auto p = begin(ia); p != end(ia); ++p){
    //q points to the first element of an array of 4 ints, q points to an int

    //use auto to deduced array is pointer

    for (auto q = begin(*p); q != end(p); ++q)
        cout << * q << " ";
    cout<<endl;
}

```

**(4). Type Aliases Simplify**

- ```using int_array = int[4];``` 
- ```typedef int int_array[4];```


```c++
typedef int int_array[4];
for(int_array * p = ia; p!= ia + 3; ++p)
    for(int * q = *p; q!=*p + 4; ++q)
        oout << *q <<endl;
```
***

<br/>  <br/>  <br/>

## 4. Expressions


**Overloading Operators**: the type of operands(运算对象的类型) and the result 取决于 how the opeartor is defined. 但是the number of operands and ther precedence(优先级) and the associativity (结合律) of the operator cannot be changed (运算对象个数, 优先级, 结合律不能改变)

#### (a). lvalue / rvalue 

- When use an object as **rvalue**, <span style="background-color:#FFFF00"> We use an object value(**its contents**)</span>. 当we use an object as **lvalue**,  <span style="background-color:#FFFF00">we use the object's identity (**its location in memory**). </span>
- <span style="background-color:#FFFF00">在需要rvalue时, 可以用lvalue替代; 但是当一个lvalue使用, 不能用rvalue来替代</span>. When we use lvalue in place of an rvalue, the object's contents(its value) are used 
- 具体使用: 
  - Assignment 等号左面需要(nonconst) lvalue as its left-hand operand and yields its left-hand operand as lvalue 
  - <span style="color:red">The address-of operator(&) requires an lvalue operand (运算对象), and returns a pointer to its operand as rvalue</span>
  - Built-in dereference ```*``` and subscript operators(vector, string), iterator dereference all yield lvalue 
  - Built-in 和 iterator 的 increment, decrement operators 也需要lvalue as operands
    - <span style="background-color:#FFFF00">prefix operators (```++i```) return the object itself as **lvalue**, postfix```i++``` return a copy of the object's original value as **rvalue**</span>, <span style="color:red">postfix may be costly. 因为要储存一个copy 再做increment/decrement</span>
    - <span style="background-color:#FFFF00">用```decltype```时候, 当我们apply ```decltype```时候, 假如```p```是 ```int*```, deference yields a lvalue```decltype(*p)``` is ```int&```. Address-of operator yields an rvalue, ```decltype(&p)``` is ```int**```

#### (b). Precedence and Associativity 

when Precedence and associativity matter

```c++
int ia[] = {0, 2,4,6,8}; 

int last = *(ia + 4); //6 + 4 = 10

last = *ia + 4; //0 + 4 = 4

```

- The precedence of postfix / prefix increment > deference 
    - ```*pbeg++``` is equivalent to ```*(pbeg++)```, ```pbeg++``` increment ```pbeg``` and return a copy of previous value as rvalue 
    - ```*++pbeg``` is equivalent to ```*(++pbeg)``` increment value and return as **lvalue** and dereference
- dot > deference 
    -   ```(*p).size()```如果我们忽略了括号, ```*p.size()``` error 因为pointer doesn't have member size. ```p->size()```<span style="background-color:#FFFF00"> yields an **lvalue**. The dot operator yields an lvalue if the object from which the member(成员所属对象) is fetched is an lvalue; otherwise the result is an rvalue. </span>
- The conditional operator/Assignment has fairly low precedence (比较对象优先级低). When we embed a conditional expression in a larger expression, 通常需要parathesize 
- Precedences specifies how the operands are grouped 但是 同一个expression <span style="background-color:#FFFF00">say nothing about order of operands evaluated.</span>  比如: ```int i = f1() * f2(); ``` 我们知道```f1``` and ```f2``` must be called before 乘法. 但是no way of knowing whether ```f1``` 先执行还是 ```f2``` 先执行
    -  **准侧**: 
        1. 当不确定时, 用括号,
        2. if you change the value of an operand, don't use that operand elsewhere in the same expression. (Exception： 有优先级存在且只用一次, ```*++iter```,  ```++iter``` 更改了```iter```本身, 再用deference operator, no issue. 因为```++``` 先于 ```*``` 运算, 且```iter``就用了一次)


The precedence of postfix / prefix increment 高于deference
```c++
auto pbeg = v.begin();
// print elements up to the first negative value 

while (pbeg != v.end() && *beg >= 0)
    cout<<*pbeg++<<endl; //print the current value and advance pbeg

```

The conditional operator has fairly low precedence
```c++
cout << ((grade < 60) ? "fail" : "pass");  // prints pass or fail


cout << (grade < 60) ? "fail" : "pass"; // prints 1 or 0!  取决于grade < 60 is true or false

cout << (grade < 60); // prints 1 or 0,

cout ? "fail" : "pass"; // test cout and then yield one of the two literals 

// depending on whether cout is true or false


cout << grade < 60 ? "fail" : "pass"; // error: compares cout to 60

cout << grade; //返回的是cout, less-than has lower precedence than shift, so print grade first

cout < 60 ? "fail" : "pass"; // then compare cout to 60!


```


Assignment has low precedence, 下面例子如果不用括号, the operands to ```!=``` would be evaluate first, then ```i = true / false```
```c++
int i;
while ((i = get_value()) != 42) {
    // do something ... 
    
}
```

For operators that do not specify evaluation order, <span style="color:red">it is an error for an expression to refer to and change te same object.</span> Expression that do so have undefined behavior 比如

```c++
int i = 0;
cout << i << ", " << ++i <<endl;// undefined 

//因为可能打印0, 1 or 1, 1

```

比如下面的, no guarantees whichfunctin are called first. 如果下面的function 是独立的 and do not affect the state of the same objects or perform IO, then it is okay. 如果functions do affect the same object（比如同一个class的不同function, 会change class state）. then expression in error and has undefined behavior.
```c++
f() + g() * h() + j()
```

#### (c). Arithmetic Operators

**overflow** happens when a value is computed that is <span style="color:red">outside the range of values</span>. 比如下面例子,shorts are 16 bits. maximum short is 32767. the value wrapped around. The sign bit which had been 0 is set to 1, resulting a negative value. 在其他system, the result might be different(也许会crash entirely).  On many systems, there is no compile-time or run-time warning when an overflow occurs. 

```c++
short val = 32767; //max value if shorts are 16 biys

val += 1; //this calculation overflows

cout << val; //print -32769

```

对于除法, C++11 新标准是商一律向0取整(truncate toward 0), ```(m/n)*n + m%n = m```, 比如m,n是正数,```(-m)/n``` 和 ```m/(-n)``` 都等于```-(m/n)```,  ```(-m)%n``` 和 ```m%(-n)``` 都等于```-(m%n)```, 

```c++
21%6;    /* resultis3 */    21/6; /* resultis3 */
21%7; /* resultis0 */       21/7; /* resultis3 */ 
-21%-8; /* resultis -5 */   -21/-8; /* resultis2 */ 
21%-5; /* resultis1 */      21/-5; /* resultis -4 */
```

**Logical Operator**

不可以写成 ```if(i<j<k)``` 因为```i<j```产生是true or false, 就变成```true/false < k```

#### (d). Assignment Operators

- Assignment is **right associative**. 

```c++
int ival, jval;
ival = jval = 0;//jval = 0 返回 jval 赋值给ival

int ival, *pval;
ival = pval = 0; //error: they are different type, multiple assignment must have the same type.

//and no conversion from int * to int  

```


```c++
//对于compound assignment, the left-hand operand is evaluated only once

+=  -=  *=  /=  %= // arithmetic operators

<<=  >>=  &=  ^= |= // bitwise operators


//对于普通的the operand evaludated twice: 第一次是右侧的expression, 第二次是赋值给左侧

a = a op b;//等同于

```

The problem is both left- and right-hand operands use beg and right-hand operand changes beg. The assignment is undefined. 因为更改了```beg```并且用了两次, 不知道是赋值时候是 ```*beg = ``` 还是 ```*(beg+1) = ```, 因为不知道是赋值先```*beg=toupper()``` 还是 ```*beg = *beg++```先

```c++
while (beg != s.end() && !isspace(*beg))
    *beg = toupper(*beg++); // error: this assignment is undefined


//可能会这样处理 or it may evaluate in some other way

*beg = toupper(*beg); // execution if left-hand side is evaluated first 

*(beg + 1) = toupper(*beg); // execution if right-hand side is evaluated first

```

#### (e). Bitwise Operators

- There are no guarantees for how sign bit is handled, we strongly recommend using unsigned types with bitwise operators (对于unsigned 没有要求, 建议使用signed)
-  Bitwise Shift operators yield a value that is copy of left-hand operand 但是 <span style="color:red"> right-hand operand must not be negative. </span> e.g. ```5<<-3``` <span style="color:red"> **Error**</span>
-  left shift operator ```<<``` insert 0-valued bit on the right. 而 right shift operator ```>>``` depends on the type of left-hand operand: 如果operand is unsigned, then operator insert 0 bits 在左侧, 如果signed, insert copies of sign bit or 0 bits 在左侧 
- <span style="color:red">Shift Operators (aka IO Operators) are **Left Associative**</span> ```cout << "hi" << " there" << endl;``` 等同于 ```( (cout << "hi") << " there" ) << endl;```
- The shift operators have mid level precedence: lower than the arithmetic operators but higher than the relational, assignment, and conditional operators. <span style="background-color:#FFFF00"> (位移低于算数，高于比较), 意味着我们经常需要括号去正确 group operators </span>

Example. 用每一个bit 表示学生通过or fail 测验, 看第27名同学

```c++
unsign long quiz1 = 0;
quiz1 |= 1 << 27 //记录第27名同学通过测验

quiz1 &= ~(1 << 27) //记录第27名同学fail测验

bool status = quiz1 & (1<<27) //学生27是否通过测验

```
#### (f). Sizeof Operators

- ```sizeof``` 返回一个类型大小 /表达式结果类型(return type)大小 所占字符数, returns the size  in bytes of an expression or a type name. ```sizeof (type)``` or  ```sizeof expr```
- ```sizeof``` is a <span style="background-color:#FFFF00">**constant expression**</span> of type ```size_t```. 
- The operator is right associative. 
- ```sizeof *p```, <span style="background-color:#FFFF00">p可以是invalid</span>
- result applying sizeof  
  - ```sizeof char``` = 1 guaranteed 
  - sizeof reference returns the size of 被引用对象
  - sizeof pointer 得到指针本身空间大小 (the size neeed hold a pointer)
  - sizeof a deferenced pointer, 返回指针所指对象的所占空间小, 指针不需要有效,因为指针实际上没有真正使用
  - sizeof an array is the size of the entire array (整个数组的size of entire array). 等于 sizeof element 乘以 the number of elements. <span style="background-color:#FFFF00">注意sizeof does not conver the array to a pointer.</span>
  - sizeof a string or vector<span style="background-color:#FFFF00">该类型固定部分的大小(the size of fixed part of these types)，不会计算对象中元素占用了多少空间 (does not return the size used by the object's element)</span> 

```sizeof *p;``` <span style="background-color:#FFFF00">```sizeof``` 满足右结合律 并且与 ```*```优先级一样 </span>, 从右向左顺序组合， 等价于 ```sizeof(*p)```

在C++11中，<span style="background-color:#FFFF00">可以用**scope operator** to ask the size of memeber of a class type. </span>, 因为sizeof 运算无须提供一个具体对象,
```c++
Sales_data data, *p;
sizeof(Sales_data); // 存储Sales_data 类型所占空间大小

sizeof data; // size of data's type, i.e., sizeof(Sales_data)

sizeof p; // size of a pointer

sizeof *p; // size of the type to which p points, 即 sizeof(Sales_data) 

sizeof data.revenue; // size of the type of Sales_data's revenue member 

sizeof Sales_data::revenue; // alternative way to get the size of revenue

```

```c++
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
int arr2[sz]; // ok sizeof returns a constant expression

int a[] = { 1,2,3,4,5 };
cout << sizeof(a) << ", " < , sizeof(*a) << endl; //print 20, 4

```

#### (g). Comma Operators

- comma operator 含有两个运算对象(operands), 从左向右顺序依次求值
- <span style="background-color:#FFFF00">guarantees the order of evaluation</span>
- <span style="color:red">从左向右计算依次求值,先求左侧的表达式的值，然后将结果丢弃掉</span>，the result of comma expression 是右侧的表达值. The result is an lvalue if the right-hand operand is an lvalue 

```c++
vector<int>::size_type cnt = ivec.size(); 
for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix, --cnt) 
    ivec[ix] = cnt;
```

#### (h). Type Conversions

**(1). Implicit Conversion**

The compiler 自动转化运算对象
- 如果算数运算或者关系运算对象有多种类型，需要准换成统一类型
    - 算数转化： 把类型转化成最宽的类型, 比如 一个类型是long double, 无关其他是什么类型，都被转化成long double. 如果有float, 那么整数型会被转化成float
    - In initializations, the initializer is converted to the type of the variable; In assignments, 右侧运算被convert to 左侧运算
    - 如果某个运算符运算对象不一致， 这些运算对象将转化成同一类型, 但是如果某个运算对象是unsigned, 结果就依赖于机器中各个整数类型相对大小了， 转化类型要么都是unsigned, 要么都是signed的
- **Integral promotions(整型提升)**: convert  small integral types to a larger integral type(小整型变成大的整型). The types ```bool```, ```char```, ```signed char```, ```unsigned char```, ```short```, and ```unsigned short``` are promoted to ```int``` if all possible values of that type fit in an int. Otherwise, the value is promoted to ```unsigned int```.
- 较大的char(```wchar_t,char16_t, char32_t```)提升成```int, unsigned int, long, unsigned long, long long, unsigned long long```, 前提是转化类型能容纳原来类型所有可能的值
- 一个signed, 一个unsigned 
    - when unsigned type 大于等于signed type ， signed -> unsigned. 如果signed 是负数, 有副作用(比如 -1 会变成255)
    - when unsigned type  小于signed type , 结果依赖于机器, 如果unsigned的值都可以存入signed, 则 unsigned -> signed, 如果不能, signed -> unsigned 
    - e.g. long, unsigned int, 如果int 和long 大小相同, 则long -> unsigned int. 如果long 类型占用空间大于int, unsigned int -> long 

```c++
int ival = 3.541 + 3; //the compiler migh warn loss of precision

3.1415159L + 'a' // 'a' -> int(97) -> long double 

float f; char c; short s;
f + c; //c -> int -> floatt

s + c; //s -> int, c-> int 


int i; unsigned int ui; unsigned short us;
long l;  unsigned long ul; 
i + ul; //i -> unsigned long 

us + i; //根据unsigned short 和int 所占空间大小比较

ui + l;//根据unsigned int 和 long 所占空间大小比较

```

- Array -> Pointer ```int ia[10]; int * ip = ia;```
    - <span style="background-color:#FFFF00">当Array 用在```decltype```, ```&```, ```sizeof``` 以及 ```typeid```中不会发转化, </span>, 或者当引用初始化数组也不会 ```int (&arrRef)[10] = &ia```
- Pointer Conversion:  <span style="background-color:#FFFF00">a pointer to any nonconst type can be converted to ```void*```, any a pointer to any type can be converted to a ```const void *```</span> 
- Pointer -> Bool: If pointer value is zero, the conversion yield false, otherwise true  ```char * cp = get_string(); if(cp)```
- to Const: 允许pointer to a non const type to a pointer to the const type and reference. 
- Conversion defined by Class Types: Class types 可以定义conversions that the compiler will aplly automatically. The compiler apply only one class-type conversion at a time. e.g. ```string s; while(cin >> s); ``` while 把 cin 转化成bool  


```c++
int i;
const int &j = i; // convert a nonconst to a reference to const int

const int *p = &i; // convert address of a nonconst to the address of a const 

int &r = j, *q = p; // error: conversion from const to nonconst 

```

**(2). Explicit Conversion**

Use **cast** to request explicit conversion. (有时候不得不用cast, 但是cast 这种方法本质上是非常危险的), cast 只有cast reference 不是copy, pointer, value都是copy

```c++
//const cast pointer 是copy value 
const char* cp = "123";
char * newp = const_cast<char*>(cp);
newp = "abc";
cout<< cp <<" , " << newp<<endl; //print 123, abc


double cp = 10;
double& newp = static_cast<double&>(cp);
double newp2 = static_cast<double&>(cp);
newp = 20;
newp2 = 30;
cout<< cp <<" , " << newp<<" , "<< newp2<<endl; //20, 20, 30 

```

**static_cast** is often use when a large arithmetic type is assigned to a smaller type. 一般来说 如果compiler 发现一个较大的类型试图赋值给较小的类型, 会generate warning.  <span style="color:red">但是当我们do a explicit cast, the warning message is turned off.</span> 

static cast is useful when perform a version that compiler不会自动转换的. 例如, <span style="background-color:#FFFF00">we can use static_cast to retrieve pointer value that was stored in a ```void*```pointer</span>


用```static_cast```强制转换原来类型时, 我们应该确保指针的值保持不变, 也就是说强制转化的结果与原始的地址相等. We must certain  that the type to which we cast the pointer is the actual type of that pointer. <span style="color:red">If the types not match, the result is undefined  </span>

```c++
void* p = &d; // ok: address of any nonconst object can be stored in a void*

 // ok: converts void* back to the original pointer type

double *dp = static_cast<double*>(p);
```



**const_cast** : change only a  <span style="background-color:#FFFF00">low-level const</span> in operand. cast away the const. 一旦cast away const, the compiler不会发出警告when writing to that object. If object is orginally not a const, using cast to obtain write access is legal. However using a const_cast in order to write to a const object is undefined.


```c++
const char *pc;
char *p = const_cast<char*>pc; //okay but writing through p is undefined, 因为pc是const

const char *cp;
// error: static_cast can't cast away const

char *q = static_cast<char*>(cp);
string txt = static_cast<string>(cp); // ok: converts string literal to string 

string txt = const_cast<string>(cp); // error: const_cast only changes constness

```



**reinterpret_cast**: generally performs a low-level reinterpretation of the bit pattern of its operands. 为运算对象的位模式提供较低层次上的重新解释

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
string str(pc); //result in bizarre run-time behavior.

//pc指的真实对象是int 而非char. 如果把pc当成普通char指针，就会发生running error

```

上面例子提供了使用reinterpret_cast非常危险, 类型改变了，但compiler没有任何警告或者错误的信息提示. 比如上面中```pc```实际指向```int *```, 但使用```pc```时候, 会认定它是```char*```类型. compiler没法知道它存放是指向int 的指针


When to use ```reinterpret_cast```: when interface with <span style="color:red">opaque data types(frequently occurs in vendor APIs over which programmer has no control)</span>. 下面例子是where a vendor provides an API for storing and retrieving arbitrary global data:

```c++
// vendor.hpp

typedef struct _Opaque * VendorGlobalUserData;
void VendorSetUserData(VendorGlobalUserData p);
VendorGlobalUserData VendorGetUserData();
```

static_cast won't work, must use ```reinterpret_cast```

```c++
//main 

struct MyUserData {
    MyUserData() : m(42) {}
    int m;
};

nt main() {
    MyUserData u;

    // store global data
    
    VendorGlobalUserData d1;
 //  d1 = &u;                                          // compile error

 //  d1 = static_cast<VendorGlobalUserData>(&u);       // compile error

    d1 = reinterpret_cast<VendorGlobalUserData>(&u);  // ok
    
    VendorSetUserData(d1);
        // do other stuff...

        // retrieve global data
	
    VendorGlobalUserData d2 = VendorGetUserData();
    MyUserData * p = 0;
 //  p = d2;                                           // compile error

 //  p = static_cast<MyUserData *>(d2);                // compile error

    p = reinterpret_cast<MyUserData *>(d2);           // ok

    if (p) { cout << p->m << endl; }
    return 0;
}

```


**old style cast**

```c++
type (expr); // function-style cast notation 

(type) expr; // C-language-style cast notation

char *pc = (char*) ip; // ip是指向整数的指针

//效果与使用reinterpret_cast一样

```
***

<br/> <br/> <br/>

## 5. Statements

The **null statement** is a empty statment ```;```

```c++
while(iter != svc.end()); //while 循环主体

    ++iter; //iter is not part of the loop, run after while
```

**Dangling(悬垂) else**: 规定了else与最近的if匹配, 比如下面的else 初衷是为跟外层的if 匹配,但是却跟内层匹配, 如果想让与外层if 匹配，需要花括号

```c++
if (grade > 6)
    if (grade  > 10 )
        cout <<" excellent";
else //与  if (grade  > 10 ) 匹配，实际上是6 < grade < 10进入这个else

//而不是grade < 6进入else

    cout << "fail"
```

**Do while**: 不要在条件部分定义变量, 然后在while 中判断
```c++
do{
    int i = 1;
}while( i != 1) // error: declaration in a do condition

```

**Break/continue** 只作用于最近的for, while, switch 
```c++
switch(buf[0]) { 
    case '-':
        for (auto it = buf.begin()+1; it != buf.end(); ++it)
        {
            if (*it == ' ')
                break;//作用于for, 不会break case

        } 
```

**Goto**:
-  与switch 类似, 不可以定义初始化的值 然后带出scope (cannot transfter control of initialized varaible 从初始化的scope到variable被用的scope)
- A jump backward over an already executed definition is okay(跳回一个已经执行的定义是ok). Jumping back to a point before a variable is defined destroys the variable and constructs it again

```c++
    goto end;
    int ix = 10; // error: goto bypasses an initialized variable definition

end: 
    // error: code here could use ix but the goto bypassed its declaration 

    ix = 42;

```
```c++
begin:
    int sz = get_size(); 
    if (sz <= 0) {
        goto begin;
    }
// Here sz is destroyed when the goto executes. 

//It is defined and initialized 一个新的sz when jump back to begin

```

#### (a). switch 

- switch 中的case, switch 必须是[integral constant expression](#constexpr) (整型常量表达式),<span style="background-color:#FFFF00"> 所以不能用string, double 作为switch 或者case 条件, 可以用simple char(not char*, not char array), int, enum, string\[index] (it's char)</span>
- 任何两个case 不能相同
- <span style="background-color:#FFFF00">如果没有break, 当一个case match， 会执行接下来所有的case until program explicitly interrupts it</span>, 但是最后一个case 不一定加break, 但为了安全最好加上, 如果有新的case, 这样不用担心前面break
- 有时候想两个或多个case 值共享一组操作(common set of actions), we omit a break, allowing program to fall through multiple case labels
- **default**: 如果没有任意match上, 进入default, 如果default 是空的, 加上default 也是有用的，因为告诉读者我们考虑了全部情况
- Variable Definitions inside the Body of a switch: 
    - <span style="color:red">如果定义并初始化的值, it is illegal to bring to outscope</span>
    - <span style="color:red">如果定义没有初始化，是可以的; </span>


```c++
int ival = 42;
char ch = getVal();
switch (ch){
    case 3.14: //error noninteger as case label

    case ival: // error nonconstant as case label

}

string a = "123";
switch(a) // error not integral constant expression

```

stack several case together with no break.只要ch是元音，都执行相同代码
```c++
unsigned vowelCnt = 0; 
switch (ch) {
    // any occurrence of a, e, i, o, or u increments vowelCnt

    case 'a':
    case 'e':
    case 'i':
    case 'o':
    case 'u':
        ++vowelCnt;
        break;
}

//因为case 之后不一定要换换换行

// alternative legal syntax

switch (ch)
{
    case 'a': case 'e': case 'i': case 'o': case 'u':
        ++vowelCnt;
        break;
}
```
当omit break时候, 会执行所有的case, 比如```ch = 'e'```,  ```eCnt```, ```iCnt```, ```oCnt```, ```uCnt```, ```d```, 都会加1

```c++
switch (ch) {
    case 'a':
        ++aCnt; // oops: should have a break statement

    case 'e':
        ++eCnt; // oops: should have a break statement

    case 'i':
        ++iCnt; // oops: should have a break statement

    case 'o':
        ++oCnt; // oops: should have a break statement

    case 'u': 
        ++uCnt;

    default:
        d++;
}
```

可以在别的case 中定义variable, 在别的case中使用; 但是不可以在别的case中 定义并初始化值, 然后在别的scope 使用
```c++
case true:
// this switch statement is illegal because these initializations might be  bypassed

    string file_name; // error: implicit初始化, file_name = ""

    int ival = 0;// error: control bypasses an explicitly initialized variable

    int jval; // ok: because jval is not initialized
    
    break; 

case false:
    // ok: jval is in scope but is uninitialized
    
    jval = next_num(); // ok: assign a value to jval

    if (file_name.empty()) // file_name is in scope but wasn't initialized

```


#### (b). Range for statment  

```c++
for (declaration : expression)
     statement
```

expression must represent a sequence(必须是一个序列), 例如 a braced initializer list({1,2,3}), an array, or an object such as vector or string (has iterator)


#### (c). Exception Handling

- when throw error, need to initialize error by give a string or c-style character style
- Each exception classes define a member function named ```what```：takes no arguments and return c-style character style (即 ```const char*```), 返回值是copy of string used to initialize the object; 对于没有初始值的exception,```what``` returns 由compiler 决定 
- If no appropriate catch is found, execution is transferred to a library function ```terminate```. 该函数行为与系统有关 but is guaranteed to stop further execution of the program

```c++
try{
    throw runtime_error("Data must refer to same object");
}catch(runtime_error err){
    cout <<err.what(); //print Data must refer to same objec

}
```

- ```exception``` header defines 最通用的 exception class, 它只报告exception occur 但没有额外信息
- ```stdexcept``` header files 几个general-purpose exception classes ```exception ```, ```runtime_error```,```range_error```, ```overflow_error```, ```underflow_error```, ```logical_error```, ```domain_error```, ```invalid_argument```, ```length_error```(试图建立一个超出该类型最大长度的对象), ```out_of_range```
- ```new``` header defines the ```bad_alloc``` exception type
- ```type_info``` header defines the ```bad_cast``` exception type 
- 只能用default initialization ```exception```,  ```bad_alloc```, ```bad_cast```  不允许提供initializer for these exception types


***
<br/> <br/>  <br/>

## 6. Functions

#### (a). Function Basic

**Calling a Function**. A function does 2 things. 1. <span style="color:red"> Initializes the function's parameter</span> from corresponding argument, and it <span style="color:red">transfer control</span> to function. 2. Execution of <span style="color:red">the *calling* function(主调函数) is suspended</span> and execution of <span style="color:red">the *called* function begins</span>(被调函数, 函数主题)

当function 执行完成: the return statement does 2 things. 1. return the value in the return 2. <span style="color:red">transfers control out of the *called* function back to the *calling function*</span>

**Parameters and Arguments(形参和实参)**<span style="color:red">Arguments are the initializers for a function’s parameters.</span> e.g. **int fact(int val); fact(5)**, 5 是argument and ```val```是parameter

**Function Parameter List**: A function's parameter list 可以为空, 但不能省略. Parameter names are optional. However, there is no way to use an unnamed parameter. 如果parameter unnamed, 表示function 没有使用它，但是called 时候不代表argument 会减少
```c++
void f1(){ /* ... */ } // implicit void parameter list

void f2(void){ /* ... */ } // explicit void parameter list

```

**Function Return Type**: return type can be void. <span style="background-color:#FFFF00">但是不能是array type, IO type, or function type.</span>, 但是可以return a pointer to array or a function. 

**local variable**: 如果局部变量和外面变量名字一样, <span style="color:red">
局部变量会hide declarations of the same name made in outer scope</span>

**automatic objects**: object exist only while a block is executing. 在执行完block, value of automatic objects 被销毁, the values of automatic objects are undefined.

**local static objects**: is intialized when the first time execution pass through object definitions. 直到program terminate destoryed. 如果不提供初始值, 将执行value initailized 意味着local statics of built-in type are initialized to 0 (内置类型的静态 被初始化为0) 

```c++
size_t count_calls(){
    static size_t ctr = 0; //value will persist across calls

    return ++ctr;
} 
```
**Function Declarations**: 可以被declared (声明)多次, 但只能定义一次. 声明不需要函数主体, 用一个分号代替即可(也可以省略parameter的名字) ```void pint(vector<int>&li);```

These 3 elements—return type, function name, and parameter types—describe the function’s interface. They specify all the information we need to call the function. Function declarations are also known as the function **prototype**.

#### (b). Argument Passing

**(1). Pointer Parameter**: nonreference type, <span style="background-color:#FFFF00">when we copy pointer, the value of the pointer is copied. After the copy, two pointers are distinct(pointer地址不同的, 但指向相同的对象, which means 如果更改function 内部的pointer 指代对象不会影响外面的pointer). </span>, 因为pointer give indirect access the object, 所以可以通过指针修改object的值

```c++
//case 1: pointer is different 

void reset(int *ip){
    int j = 10;
    ip = &j;
}

int i = 0, *p = &i;
reset(p);
cout << *p << " , "<<i<<endl; //print 0, 0 


//case 2: 可以改变object的值

void reset(int *ip){
    *ip = 10;
}
int i = 0, *p = &i;
reset(p);
cout << *p << " , "<<i<<endl; //print 10, 10 

```

**(2) Reference Parameter**: Can use Reference Parameters to return additional information

**(3). const Parameters and Arguments**: <span style="background-color:#FFFF00">when we copy an argument to initialize a parameter. top-level const are ignored. 顶层const被ignore</span> We can pass either a const or a nonconst object to a parameter that has a top-level const, <span style="color:red"> Error to write functions, only parameter top-level const不同</span>

因为顶层const 被忽略掉, 所以两个fun, 两个reset function是一样的function
```c++
void fcn(const int i) // 可以pass int or const int 

void fcn(int i) //也可以接受int, const int, compiler报错already has a body

void reset(int const * const ip); 
//可以pass const int * p, 也可以是pass const int * const p

void reset(int const * ip);
//是两个一样的reset function

//下面两个function 不一样, 因为不是top-level const

void fun(const int & i);
void fun(int & i);
```

**(4). Use Reference to const When Possible**：如果只pass reference without const，可能给读者错误导function可能改变value; 另外<span style="color:red">用reference, we cannot pass a const object, a literal, or an object requires conversion to a plain reference parameter </span>

```c++
find_char(string& str, char ch);
void isSentence(const string & s){
    return find_char(s, 'a'); //error 因为不能pass const reference to reference 

}
```

**(5). Array Parameters**

数组有两个性质: 1. cannot copy an array 2. when use array, it convert to a pointer. <span style="background-color:#FFFF00"> 因为不能拷贝, cannot pass by value. 因为array convert to pointer, 当pass array, we actutally pass a pointer to the array's first element.</span>. <span style="background-color:#FFFF00">当call function时, array size is irrelevant</span>

下面是几个函数declarations are equivalent; 每一个function 都是有一个parameter of type ```const int*```, 如果都在一个程序中写出下面三个function, compiler会显示<span style="color:red">redefintion error.</span> 
```c++
// each function has a single parameter of type const int*

void print(const int*);
void print(const int[]); //可以看出来, 函数意图是作用于数组

void print(const int[10]); //这我们期望有多少个元素, 实际不一定

int i = 0, j[2] = {0, 1};
print(&i); // ok: &i is int*

print(j); // ok: j is converted to an int* that points to j[0],

//the size of array is irrelevant

```

<span style="background-color:#FFFF00">function parameter 是 array, **size doesn't matter**</span>
```c++
void print(int arr[3]){
   cout << arr[0]<<endl;
}

int a [6] = {0,1,2,3,4,5};
print(a); //print 0

```	
	

因为arrays are passed as pointer, functions 通常不知道size of the array, caller必须提供额外的信息

方法一：Using a Marker to specify the extent of an Array. e.g. C-style character strings 有null character at the end. <span style="color:red">**缺点是**: not work well that don't have end-marker like ```int```</span>
```c++
void print(const char *cp)
{
    if (cp) // if cp is not a null pointer character

        while (*cp) // so long as the character it points to is not a null

            cout << *cp++; // print the character and advance the pointer

}
```

方法二: Using the Standard Library Conventions, pass pointers to the first and one past the last element in the array.
```c++
void print(const int *beg, const int *end)
{
    while (beg != end)
        cout << *beg++ << endl; // print element and advance pointer

}

int j[2] = {0,1};
print(begin(j), end(j));
```

方法三: Explicitly Passing a Size Parameter: which is common in C and older C++ programs. The function executes safely as long as the size passed is no greater than the actual size of the array.

```c++
void print(const int ia[], size_t size)
{
    for (size_t i = 0; i != size; ++i)
        cout << ia[i] << endl;
}

intj[]={0,1}; 
print(j, end(j) - begin(j));
```

**(6).Array Reference Parameters** 只有需要change the value, 采用Array reference, 如果不改变value, 用 pointer to const, 当有引用时, <span style="background-color:#FFFF00">只能传入与引用size 一样维度的array,**size matters**</span>, 比如下面的function, 只能传入size = 10的, <span style="color:red">只有当reference 传入时候才能用for_range loop 因为function pass的是array, 不是reference传入的 function pass的是pointer</span>  

<span style="background-color:#FFFF00">**Array 被当做reference 传入 不会转换为pointer type**</span>

```c++
void print(int (&arr)[10])
//括号不能少

//int &arr[10]: error, reference is not object, 不能定义array of reference

{ 
    for (auto elem : arr) 
        cout << elem << endl;
}

int i = 0, j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};
print(&i);// error: argument is not an array of ten ints 

print(j); // error: argument is not an array of ten ints 

print(k); // ok: argument is an array of ten ints

```

**(7). Passing a Multidimensional Array**: 实际上没有真正的多维数组. Multidimensional array is passed as a pointer to its first element (因为时多维数组, the first element 还是 a pointer to the first element). <span style="background-color:#FFFF00">The size of the second (and any subsequent) dimension is part of the element type and must be specified (**second dimension size matters**)</span>

```c++
void print(int (*matrix)[10], int rowSize) { /* . . . */ }
//declares matrix as a pointer to an array of ten ints.

// equivalent definition

void print(int matrix[][10], int rowSize) { /* . . . */ }
```

**(8). main: Handling Command-Line Options**: argv 第一个元素指向程序名字或者空的字符串, 接下来的传入argument provided by command line. <span style="color:red">最后一个element is guaranteed to 0</span>.

```c++
int main(int argc, char *argv[]) 
//也等于

int main(int argc, char **argv) 

//如果传入 prog -d -o ofile data0

argv[0] = "prog"; argv[1] = "-d"; argv[2] = "-o";
argv[3] = "ofile"; argv[4] = "data0"; argv[5] = 0;
```

**(9). Functions with Varying Parameters**: 处理不同数量argument: <span style="background-color:#FFFF00">如果argument类型相同, we can pass **initializer_list**的标准库, 如果函数类型不同, we need to a special kind of function (variadic template)</span>. 还有一个parameter type (ellipsis) 可以用于传入varying number of arguments. (注意ellipsis should be only used in programs that need to interface to C functions)


An **initializer_list** is a library type that represents an array of values of the specified type. This type is defined in the initializer_list header. 
- <span style="background-color:#FFFF00">unlike vector, element in **initializer_list**  are always ```const``` values, we cannot change the elements in **initializer_list** </span>
- When we pass a sequence of values to an initializer_list parameter, we must <span style="background-color:#FFFF00">enclose the sequence in curly braces```{}```</span>

| Syntax      | Description |
| :---        | :---    |  
| ```initializer_list<T>lst``` | Default initialization, an empty list of elements of type T |
| ```initializer_list<T>lst{a,b,c}``` | elements are copied of correspoding initializers. <span style="color:red"> elements in the list are const </span> | 
| ```lst2(lst)``` | copy or assigning an ```initailizer_list``` 但不会 一 一拷贝列表中元素. After the copy, the original and the copy share he elements. <span style="color:red">  shallow copy</span>| 
| ```lst.size()``` | number of elements in list | 
| ```lst.begin() / lst.end())``` | returns a pointer to the first / one past the last element in lst|

```c++
initializer_list<string> ls; // initializer_list of strings 

initializer_list<int> li; // initializer_list of ints

void error_msg(ErrCode e, initializer_list<string> il)
{
    cout << e.msg() << ": ";
    for (auto beg = il.begin(); beg != il.end(); ++beg) 
        cout << *beg << " " ;
}

error_msg(ErrCode(42), {"functionX", expected, actual});

```


**Ellipsis Parameters(省略符形参)**: Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named ```varargs```. 不能被用于其他目的. <span style="color:red">Ellipsis只能用于types ftht are common to both C and C++</span>(object of most class types are not copied properly when passd to an ellipsis parameter)

An ellipsis parameter 只能出现在parameter最后一个, and may take either of two forms
```c++
void foo(parm_list, ...);
void foo(...);
```

#### (c). Return Types 

Failing to provide a return after a loop that contains a return is an error(for loop 中有if 然后return, 但是程序fail 进入那个if，所以程序最后到达end of function without return). <span style="color:red">However, many compilers will not detect such errors</span>.

**(1). How Values Are Returned**: The return value is used to initialize a temporary at the call site(调用点), and that temporary is the result of the function call.
- 如果return是value (<span style="background-color:#FFFF00">returns are **rvalue**</span>), return value is copied to the call site. The function returns a copy of he return value. 
- 如果return是reference(<span style="background-color:#FFFF00">returns are **lvalue**</span>), reference is just another name for the object to which it refers

当function return 是 list initializing the return value, <span style="color:red">element inside brace list cannot have larger type which require **narrowning conversion**</span> 
```c++
vector<int>get(){
    return {3.14,5};//3.14->int illegal, 

}
```


**(2). Never Return a Reference or Pointer to a Local Object**: <span style="color:red">after a terminate, reference to local objects refer to memory that is no longer valid.</span>

```c++
const string & manip()
{
    string ret;
    if (!ret.empty()) return ret; 
    // WRONG: returning a reference to a local object! 

    else return "Empty";
    //WRONG: "Empty" is a local temporary string

}
```

<span style="background-color:#FFFF00">因为function reference 返回时lvalue, we can assign to the result of a function that returns a reference to nonconst </span>
```c++
char &get_val(string &str, string::size_type ix)
{ 
    return str[ix];
}
string s("a value");
get_val(s, 0) = 'A'; // changes s[0] to A 

cout << s << endl; // prints A value return 0;

```

**(3).Functions That Return Class Types and the Call Operator**: <span style="background-color:#FFFF00">call operator(call function() )的优先级和 dot and arrow operator 一样</span>, call operator is <span style="background-color:#FFFF00">left associative(assignment 是right associative)</span>. 所以if function returns a pointer, reference or object of class type, we can use the result to call a member of the resulting object

```c++
auto sz = shorterString(s1, s2).size();
```

**(4). Return from main**: The main function is allowed to terminate without a return. 如果control reaches the end of main and there is no return, <span style="color:red">compiler implicitly inserts a return of 0</span>. main的返回值看做状态指示器, 返回0表示执行成功, 返回其他值表示执行失败. 非0值得含义由机器而定. 为了使返回值与机器无关, ```cstdlib``` header中定义了2个预处理(preprocessor)变量 that we can use to indicate success or failure, <span style="background-color:#FFFF00">因为是预处理变量, 不能加上```std::```, 也不能```using``` 声明中出现.</span> <span style="color:red">注: main function may not call itself</span>

```c++
int main()
{
    if(some_failure)
        return EXIT_FAILURE; // defined in cstdlib

    else  
        return EXIT_SUCCESS; // defined in cstdlib
         
}
```

**(5). Return a Pointer to an Array**: <span style="background-color:#FFFF00">因为不能copy an array, a function cannot return an array. However, a function can return a pointer or reference to a array</span>


**方法一**: 为了straightforward, 可以用type alias

```c++
typedef int arrT[10]; //arrT is a synonym for the type array of 10 ints

using arrtT = int[10]; //跟上面一样的

arrT* func(int i); //returns a pointer to an array of 10 ints

```

without type alias,想定义一个函数 that returns a pointer to an array, <span style="background-color:#FFFF00"> dimension(维度)必须跟在函数名字之后, However, function parameter list which also follows the name. Parameter list 在dimension 前面. function 两端的括号必须在, 如果没有括号表示returns an array of pointers 但是array不能被copy</span>

```c++
Type (*function(parameter_list))[dimension]
//Dimension 表示数组的大小

//function 两端的括号必须在

int (*func(int i)) [10]; 
//function take a integer 

//返回a pointer to array of 10 ints

```

**方法二: Using a Trailing Return Type**: 在C++11中, 另一种简化function returns a pointer to array 是 using a **trailing return type**. <span style="background-color:#FFFF00">A trailing return types可以用于任何function, but are most useful for functions with complicated return types(such as pointers to array)</span>. Parameter list 在->左侧, 为了表示函数真的返回类型跟在parameter list 之后, we use ```auto``` for return type

```c++
// fcn takes an int argument and returns a pointer to an array of ten ints

auto func(int i) -> int(*)[10];

auto func(int i) -> string{
    return "val";
}
```

**方法三: Using decltype**: 

```c++
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
decltype(odd) *arrPtr(int i)
{
    return (i % 2) ? &odd : &even; // returns a pointer to the array 
    
}
```

注: ```decltype``` 并不负责把array 转化成pointer type. The type returned by ```decltype``` is an array type, 我们必须加上```*``` to indicate that ```arrPtr``` returns a pointer

#### (d). Overloaded Functions

- Functions有一样的名字但是parameter lists different and appear in the same scope are overloaded. <span style="color:red">When call these functions, compiler can deduce which function</span> we want based on argument type we pass
- <span style="color:red">main function 不能被overloaded</span>
- <span style="color:red">It is an error for two functions only return types different</span>(如果只有返回类型不同,error)
- <span style="color:red">It is an error for two functions only parameter top level const different</span>(如果一个function 有顶层const, 另一个没有顶层const, 两个function 是一样的)

```c++
Record lookup(const Account&);
bool lookup(const Account&);//error: only return type is different

```

Determine whether two parameter types differ
```c++
// each pair declares the same function 每一组function 都是一样的

Record lookup(const Account &acct);
Record lookup(const Account&); // parameter names are ignored


typedef Phone Telno;
Record lookup(const Phone&);
Record lookup(const Telno&); // Telno and Phone are the same type

```

顶层const 不影响传入函数的对象, 一个拥有顶层const和一个没有top level const的function 无法区分, 下面每组的function 第一个和第二个声明是一样的
```c++
Record lookup(Phone);
Record lookup(const Phone); // redeclares Record lookup(Phone)


Record lookup(Phone*);
Record lookup(Phone* const); // redeclares Record lookup(Phone*)

```

但如果const时候底层的, we can overload 如果指针or 引用 指向const or non const object. 下面的例子, <span style="background-color:#FFFF00">compiler can use the constness of the argument to distinguish which function to call</span> 因为const 不能转化类型, 所以只pass 给含有const 的function. <span style="background-color:#FFFF00">但是nonconst 可以转化成const,所以下面四个function 都可以被nonconst function call. 但是compiler **prefer the nonconst version** when we pass a **nonconst object** or pointer to nonconst</span>

```c++
// functions taking const and nonconst references or pointers have different parameters

// declarations for four independent, overloaded functions

Record lookup(Account&); // function that takes a reference to Account

Record lookup(const Account&); // new function that takes a const reference

//当Account是const call 第二个,当Account 不是const call


Record lookup(Account*); // new function, takes a pointer to Account

Record lookup(const Account*); // new function, takes a pointer to const

```

**const_cast**

```c++
//需要返回一个引用, 如果直接定义 string& shorterString(const string &s1, const string &s2)

//会报错，不可以把 const reference assign 给 reference, 需要const_cast 

const string &shorterString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString(string &s1, string &s2)
{
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast<string&>(r);
}
```   
首先cast argument to references to const. function returns a reference to const string, 再cast ```const string &``` back to plain string&

**calling an overloaded function**

当call overload function, 有三种可能的结果: 
- The compiler finds exactly one function that is a <span style="background-color:#FFFF00">best match</span> for the actual arguments and generate code to call that function 
- 找不到任何一个函数match the arguments in the call, 此时compiler <span style="color:red">发出error message no match</span>
- 如果有大于一个function matches and none of the matches is clearly best, 也发发生错误 <span style="color:red">ambiguous call</span>.

**Overloading and Scope**: <span style="background-color:#FFFF00">In C++ name lookup happens before type checking </span>. 当declare a name in an inner scope, that name hides use of that name declared in outer scope. 

下面例子, when call print, the compiler 首先 look for declaration of print, once the name is found. Compiler 会忽略掉外层scope 一样的命名的function, Instead, the copiler assumes that 在当前作用域中找到的就是the one for the name we are using 

```c++
string read();
void print(const string &);
void print(double); // overloads the print function 

void fooBar(int ival)
{
bool read = false; // new scope: hides the outer declaration of read 

string s = read(); // error: read is a bool variable, not a function 

// bad practice: usually it's a bad idea to declare functions at local scope

void print(int); // new scope: hides previous instances of print 

print("Value: "); // error: print(const string &) is hidden 

print(ival); // ok: print(int) is visible

print(3.14); // ok: calls print(int); print(double) is hidden

}

```


#### (e). Features for Specialized Uses

**(1). default Arguments**: are used for the right-most(trailing) argument of a call. <span style="background-color:#FFFF00"> 设计时让不怎么可能用default放前面, likely to use a default value appear first</span>
```c++
string screen(int ht = 24, int wid = 80, char backgrnd = ' ');
window = screen(, , '?'); // error: can omit only trailing arguments

```

另一种用default parameter的形式, names used as default arguments are resolved in the scope of function delcaration(<span style="color:red">名字在函数声明所在作用域内解析</span>), The value that those names represent is evaluated at the time of the call.(<span style="color:red">求值过程发生在函数调用时</span>)

```c++
int wd = 80;
char def = ' ';
size_t ht = 5;
string screen(int = ht, int = wd, char = def);

void screen(int a1 = ht, int a2 = wd, char a3 = def) { //与上面function是一样的

	cout << a1 << " , " << a2 << " , " << a3; //print 5, 80 , *
}

void f(){
    def = '*';  //change value of default argument

    int wd = 100; //hides the outer definition of wd but does not change the default

    string window = screen(); // calls screen(ht(), 80, '*')
    
}
```

**(2). Inline and constexpr Functions**

比如我们有个比较string 大小的function, 好处是如果我们修改比较方法,直接修改function, 而不用找比较表达式所有出现的地方修改conditon. 潜在缺点是: slower than evaluating the equivalent expression.  因为call function does a lot of work: 调用前先保存寄存器(registers) , 返回时恢复. 可能需要copy argument and program branches to a new location(程序转向一个新的位置继续执行)

**inline vs constexpr**
- inline functions, expression are always evaluated at the <span style="color:red">run time</span> and are request to compiler to expand(展开function) at compile time . 但是constexpr functions are evaluated at <span style="color:red">compiled time(not always)</span> 

```c++
constexpr long int fib(int n) 
{ 
    return (n <= 1)? n : fib(n-1) + fib(n-2); 
} 
  
int main () 
{ 
    // value of res is computed at compile time.  
    
    const long int res = fib(30); 
    cout << res; 
    return 0; 
} 

const long int res = fib(30);  // run time is 0.0003s;

long int res = fib(30); //run time is 0.017s;

```



**inline function** 在每个调用点上"内联"的展开 (expanded "in line" at each call) 比如下面函数, would expand during compilation into something in line, <span style="color:red">消除了函数运行时的开销(The run-time overhead of making shortString a function is removed)</span>
```c++
cout << shortString(s1,s2)<<endl;
//在编译过程中展开成类似于下面的形式

cout << (s1.size() < s2.size() ? s1 : s2 )<<endl;
```

- <span style="background-color:#FFFF00">The inline specification is only a request to the compiler. The compiler may choose to ignore this request.(inline 是向compiler 发送请求, compiler可以选择忽略这个请求)</span>
- <span style="background-color:#FFFF00">inline meachanism 用于规模小的, 流程直接, 频繁调用的函数, 不支持recursion</span>(optimize small, straight-line functions that are called frequently. Many compilers will not inline a recursive function.)<span style="background-color:#FFFF00"> 也不支持很多行的函数</span>(比如一个75行的函数很难被inline expanded)
- inline function defintion 最好放进header, 因为inline function 和 class compilation 需要在一个translation unit. Function 放进header must marked ```inline``` 否则every translation unit which includes the header will contain a definition of the function. linker will complain about multiple definition (违反了one defintion rule)

**constexpr function**: 
- <span style="background-color:#FFFF00">return type must be literal type</span> (int(reference, pointer), double, enum, char, char pointer, 但string 不是)
- <span style="background-color:#FFFF00">函数主体有且只有一个return statement</span>(function body must contain exactly one return statement, 不能有通过if 判断的多个statement),C++ 14 allows more than one statements.
- constexpr function can only call other constexpr function not simple function
- constexpr function should not be viod type and some operator like prefix increment (++v) are not allowed in constexpr function. 
- compiler will replace a call to constexpr funcion with its resulting value.(compiler 把constexpr 函数的调用换成其结果值)
- <span style="color:red">constexpr functions are implicitly inline </span>
- <span style="color:red">A constexpr function body 可以含有other statements 只要这个statement generate no actions at run time</span> (e.g. null statement, type aliases, and using declaractions)
- <span style="color:red">A constexpr function is not required to return a constant expression.</span>
- 如果需要constexpr function 返回constant expression, 需要function argument也是constant expression

```c++
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz(); // ok: foo is a constant expression

//compiler can verify new_sz return a constant expression at compile time

```

只要argument(cnt) 是constant expression, ```scale(arg)``` is a constant expression, 2 是constant expression, 所以compiler 会把所有的```scale(2)``` 用constexpr function resulting value 代替. 如果返回不是constant expression, compiler 会有error message
```c++
constexpr size_t scale(size_t cnt) { return new_sz() * cnt; }

int arr[scale(2)]; // ok: scale(2) is a constant expression

int i = 2; // i is not a constant expression

int a2[scale(i)]; // error: scale(i) is not a constant expression

```

**(3). Aids for Debugging**

**assert** is a **preprocessor macro(预处理器)**. 
- **assert** 是 **preprocessor macro**.
  - <span style="color:red">A preprocessor macro is a preprocessor variable that acts like inline function. </span>
  - 预处理器名字 由预处理器(preprocessor) 管理而不是compiler, 所以当使用preprocessor name directly, do not provide a using declaration or ```std::``` for them.
  - 和preprocessor variable 一样, **macro** names must be unique within the program. <span style="color:red">Program that include ```cassert``` header 不能有variable, function, or other entity named assert.</span>. 很多header 都包含了```cassert``` header, 所以即使没有include 它,也很有可能直接用
- ```assert(expr);``` in ```cassert``` header 中: evaluates ```expr``` and if expression is false, 输出信息并终止程序的执行, 如果表达式正确 什么也不做, 
  - assert 常用来检查不能发生的情况， ```assert(word.size() > threshold);```
- <span style="color:red">```assert``` 用来当做调试程序的辅助手段(aid) 而不能用作真正的run-time logic checks or error checking</span>

the preprocessor defines four other names that can be useful in debugging:

|  Preprocessor variables      | Description |
| :---        | :---    |  
| _ _FILE_ _ |  string literal containing the name of the file | 
| _ _LINE_ _ |  integer literal containing the current line number | 
| _ _TIME_ _ |  string literal containing the time the file was compiled | 
| _ _DATE_ _ |  string literal containing the date the file was compiled | 

```c++
if (word.size() < threshold)
    cerr << "Error: " << _ _FILE_ _
    << " : in function " << _ _func_ _
    << " at line " << _ _LINE_ _ << endl << " Compiled on " 
    << _ _DATE_ _ << " at " << _ _TIME_ _ << endl

// print 

// Error: wdebug.cc : in function main at line 27 

//    Compiled on Jul 11 2012 at 20:50:03

```


**NDEBUG Preprocessor Variable**
- assert的行为depends on the status of a **preprocessor variable** 名为 **NDEBUG**, <span style="color:red">如果**NDEBUG** is defined, ```assert``` does nothing.</span> By default, **NDEBUG** is not defined. <span style="color:red">So by default, ```assert``` performs a run-time check</span>
- We can turn off debugging by providing a ```#define``` to define ```NDEBUG```. 
  - 也有个compiler provide a command-line option that lets us define preprocessor variable ```CC -D NDEBUG main.cpp``` or ```/D``` with microsoft compiler has the same effect as writing ```define NDEBUG``` at the beginning of main.cpp
- 定义了```NDEBUG``` <span style="color:red">能避免各种条件所需的runtime 开销</span> (avoid run-time overhead involved in checking various conditions). <span style="color:red">no run-time check</span>
- 如果```NDEBUG``` is not defined, the code between the ```ifndef NDBUG``` and ```endif``` is executed. 如果```NDEBUG``` is defined, code is ignored. 

```c++
void print(const int ia[], size_t size)
{
#ifndef NDEBUG

// _ _func_ _ is a local static defined by the compiler that holds the function's name

// _ _func_ _  是局部静态变量,显示函数名字

cerr << _ _func_ _ << ": array size is " << size << endl; 

#endif

```

#### (f). Function Matching

- step 1: 选定a set of overloaded functions considered for the call. The function in this set are the **candidate functions**
  - candidate functions 是 function has the same named as the called function and declaraction is visibe at the point of the call 下面例子中有4个候选的function 
- step 2: 根据arguments,从candidate function 中选出可以被arguments调用的函数, 这些新选出的函数称为**viable function**. 下面例子有两个viable functions. To be viable function,: 
  - must have the same number of parameters as there are arguments int the call (parameter 数量必须跟调用的函数提供argument 数量一样)
  - 每个argument must match or be convertible to corresponding parameter 
  - If there are no viable functions, the compiler will complain that there is no matching function.如果没有找到可行函数, compiler 会报错
- step 3: find the best match: 这一过程是逐一检查argument in the call and 选择function parameter 与argument best match的viable function, 下面例子中当 call ```f(int)``` 需要```double -> int```, 而call ```f(double, double)```不用convert


```c++
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14); 
f(5.6); // calls void f(double, double)

```

**当有多个函数比配**: compiler以此检查argument by argument， 如果有一个function 满足下列条件，则比配成功: 
- 每个argument的匹配不劣与其他可行函数需要的匹配 (The match for each argument is no worse than the match required by any ohter viable function)
- 至少有一个arugment的match 优于其他的viable functions的匹配(There is at least one argument for which the match is better than the match provided by any other viable function)
- <span style="color:red">如果没有任何一个函数脱颖而出, 则call is error, the compiler will complain that the call is ambiguous</span>
    - 比如```f(42,2.56)```, ```f(int, int);``` 和 ```f(double, double);```是一样的, ambigous call. 
- 如果需要cast 才能找到最匹配的call, 是poorly design. Casts should not be needed to call an overloaded function. The need for a cast suggests that the parameter sets are designed poorly.


**compiler ranks the conversions thatconver each argument to the type of parameters**:

1. 精准匹配(exact match). An exact match happens when:
    - argument and parameter types are identical
    - The argument is converted from an array or function type to the corresponding pointer type.
    - top-level const is added or discarded from the argument (<span style="background-color:#FFFF00">添加或去掉top-level const</span>)
2. Match through a const conversion (通过const 转化实现)
3. Match through a promotion (通过类型提升实现, e.g. ```short->int```)
4. Match through an arithmetic or pointer conversion (通过算数或者指针转换 (e.g. pointer -> bool ```if(*cp)``` ))
5. Match through a class-type conversion. 

注:好的desgin 一般不会有functions with parameters 类似下面例子的

<span style="background-color:#FFFF00">small integral types always promote to int or to a larger integral type</span> e.g1: 一个function take parameter ```int```, 另一个take ```short```. Short 只有argument 是short的时候会被call, 即使有时是很小的整数值, 也会被promote to ```int```. whereas calling the ```short``` version would require a conversion. 

<span style="background-color:#FFFF00">所有arithmetic conversion 都是一个级别的, 从int 到unsigned int 转换不比从int 到double 转换级别高

```c++
void ff(int); 
void ff(short);
ff('a'); // char promotes to int; calls f(int)


void manip(long);
void manip(float); 
manip(3.14); // error: ambiguous cal

```

**Function Matching and const Arguments**: 

the compiler uses the <span style="background-color:#FFFF00">constness of the argument</span> to decide which function to call: 下面第二个例子, b to initialize a reference to either const or nonconst type.但是initializing a reference to ```const``` from a nonconst object <span style="color:red">require a conversion</span>. 但是<span style="background-color:#FFFF00">convert to const的级别低于exact match</span>, 因此non-const version is prefer

pointer works in similar ways, 如果argument is a pointer to const, the call will match function that takes ```const *```, otherwise, 如果argument is a pointer to nonconst, the function 有 a plain pointer is called


```c++
Record lookup(Account&); // function that takes a reference to Account

Record lookup(const Account&); // new function that takes a const reference


const Account a;
Account b;
lookup(a); // calls lookup(const Account&)

lookup(b); // calls lookup(Account&)

```

#### (g). Pointers to Functions

- a pointer that <span style="color:red">denotes a function rather than an object</span>. Like any other pointer, a function pointer points to a particular type.
- <span style="background-color:#FFFF00">函数类型(type) is determined by its return type and the types of it  parameters. 与函数名无关(function name is not part of its type)</span>
- we can directly use function pointer without dereference operator
- There is no conversion between pointers to one function type and pointers to another function type.(<span style="background-color:#FFFF00">不同的函数指针之间没有转换规则</span>)
- 可以assign ```nullptr``` or ```zero``` valued integer constant expression to a function pointer 表示function pointer 没有指向任何的function
- <span style="background-color:#FFFF00">function parameter can convert function to function pointer, 但是function return cannot convert function to function pointer</span>

function pointer 括号```(*pf)``` 必不可少, 否则的话是 function returns bool pointer

```c++
bool lengthCompare(const string &, const string &);
// pf points to a function returning bool that takes two const string references 

bool (*pf)(const string &, const string &); // uninitialized


pf = lengthCompare; // pf now points to the function named lengthCompare 

pf = &lengthCompare; // equivalent assignment: address-of operator is optional

pf = 0; // ok: pf points to no function


//三个等价调用

bool b1 = pf("hello", "goodbye"); // calls lengthCompare 

bool b2 = (*pf)("hello", "goodbye"); // equivalent call

bool b3 = lengthCompare("hello", "goodbye"); // equivalent call


string::size_type sumLength(const string&, const string&); 
bool cstringCompare(const char*, const char*);
pf = cstringCompare; // error: parameter types differ 返回类型不匹配

```

对于overloaded function,上下文必须指出选用哪个函数
```c++
void ff(int*);
void ff(unsigned int);
void (*pf1)(unsigned int) = ff; // pf1 points to ff(unsigned)

double (*pf3)(int*) = ff; // error: return type of ff and pf3 don't match

```

**Function Pointer Parameters**: we can write parameter that looks like a function, 但实际上是被treated as pointer.当pass a function as an argument, <span style="color:red">它将自动convert to a pointer</span>
```c++
// third parameter is a function type and is automatically treated as a pointer to function

void useBigger(const string &s1, const string &s2,
    bool pf(const string &, const string &));//it is a pointer

    
// equivalent declaration: explicitly define the parameter as a pointer to function

void useBigger(const string &s1, const string &s2,
    bool (*pf)(const string &, const string &));
```

可以用```typedef``` 来避免冗长(tedious), ```Func``` 和```Func2```是函数类型,  ```FuncP``` 和```FuncP2```是pointer类型,注 <span style="background-color:#FFFF00">```decltype``` returns the function type; 不会自动转换成指针类型</span>,如果我们想要pointer, 必须加上```*```
```c++
// Func and Func2 have function type, 是函数类型

typedef bool Func(const string&, const string&); 

typedef decltype(lengthCompare) Func2; // equivalent type


typedef bool(*FuncP)(const string&, const string&);

typedef decltype(lengthCompare) *FuncP2; // equivalent type


// equivalent declarations of useBigger using type aliases

void useBigger(const string&, const string&, Func); 
void useBigger(const string&, const string&, FuncP2);
```

**Returning a Pointer to Function**: 和数组类似，虽然不能返回函数, 但可以返回函数的指针, <span style="background-color:#FFFF00">we must write the return type as a pointer type, compiler will not 自动treat a function return type as pointer type(和function parameter 不一样) </span>

```int (*f1(int))(int*, int);``` <span style="background-color:#FFFF00">f1 is a function 返回的是pointer,返回的有parameter list, so pointer points to a function and that function returns an int</span>

```auto f1 (int) -> int(*)(int*, int);``` 可以用trailing return to make it clear

```c++
using F = int(int*, int); // F is a function type, not a pointer 

using PF = int(*)(int*, int); // PF is a pointer type

PF f1(int); // ok: PF is a pointer to function; f1 returns a pointer to function 

F f1(int); // error: F is a function type; f1 can't return a function

F *f1(int); // ok: explicitly specify that the return type is a pointer to function

```

**Using auto or decltype for Function Pointer Types**

如果我们知道函数返回是哪个一个, 可以用```decltype```简化书写. 需要注意的是,  <span style="background-color:#FFFF00">when we apply decltype to a function, it returns a function type, not a pointer to function type</span>. 需要add ```*``` to indicate that we are returning a pointer not a function

```c++
string::size_type sumLength(const string&, const string&); 
string::size_type largerLength(const string&, const string&);

//根据parameter, getFcn返回是pointer to largerLength or sumLength

decltype(sumLength) *getFcn(const string &);
```
***
<br/> <br/>  <br/>


## 7. Classes

The fundamental ideas behind classes are **data abstraction** and **encapsulation***(数据抽象和封装). Data abstraction is a programming (and design) technique that relies on the separation of interface and implementation. **Encapsulation** enforces the separation of a class’ interface and implementation, A class that is encapsulated hides its implementation. 一个user只能看见interface, 不能看见implementation

Benefit of Encapsulation: 
1. User code cannot inadvertently corrupt the state of an encapsulated object.用户不会无意间破坏封装对象
2.  The implementation of an encapsulated class can change over time without requiring changes in user-level code. 可以随时改变implementation without 影响用户

#### (a). This & Const


Functions defined in the classes are <span style="background-color:#FFFF00">implicitly inline</span>. 定义在class 内部的函数都是inline的. function声明必须在函数内部声明, we can define a member function’s body either inside or outside of the class body.

Ordinarily, nonmember functions that are part of the interface of a class should be declared in the same header as the class itself. (<span style="color:red">比如下面的print, read 不是class member 也应该与class 放入一个header</span>)

```c++
struct Sales_data {
    std::string isbn() const { return bookNo; }//定义声明在内部 

    //下面两个function, 声明在struct内部, 但是定义在外部
    
    Sales_data& combine(const Sales_data&); 
    double avg_price() const;

    std::string bookNo;
    unsigned units_sold = 0; 
    double revenue = 0.0;
  };

// nonmember Sales_data interface functions, 定义声明都在外部

Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&); 
std::istream &read(std::istream&, Sales_data&);
```

**this**: 
- ```this``` is a <span style="background-color:#FFFF00">const pointer</span>, we cannot change the address that ```this``` holds. <span style="color:red">```this``` is a constant pointer that holds the memory address of current object. ```this``` is not available in **static** member function </span> 
-  By default, the type of ```this``` is ```const``` pointer<span style="color:red"> to the non const version of the class type</span>(top level const, lower level nonconst).
    - ```*this``` 指<span style="background-color:#FFFF00">reference to object, 而不是const reference to object</span>, 因为```this```没有lower constness
- Member functions access the object through extra, <span style="color:red">implicit</span> parameter named **this**. **this** is initialized with<span style="color:red"> the address of the object</span> which the function (只限于nonstatic) was invoked.
    -  比如 ```total.isbn()``` compiler passes the address of ```total``` to the implicit ```this``` parameter. compiler 会等价的rewrite 为 ```Sales_data::isbn(&total)```(调用Sales_data的isbn的成员时传入total 的地址)
- 在class 函数内部的直接access member of the object, 因为any direct use is assumed to be an implicit reference through ```this```(任何对类成员直接访问都被看作this的隐式引用)
    - ```bookNo``` as if ```this->bookNo```
- It's illegal to define a parameter or variable named ```this```.

**const Member Functions**
- ```const``` is to modify the type of the implicit ```this``` pointer, 表示 <span style="background-color:#FFFF00">```this``` is a pointer to ```const```</span>. Member function that use ```const```被称为<span style="color:red">const member functions</span>
   - <span style="background-color:#FFFF00">const member functions cannot change the object on which they are called</span>. 因此const function 不能write to data members of the objects 只能read
- const function call 总结:
   - <span style="background-color:#FFFF00">不能在const function中call nonconst member function, 只能call const 的function</span>. 因为Cannot bind ```this```（this 没有low level const） to a ```const``` object (```this```没有lower const, lower const -> no lower const的 不可以) . 
       - 比如```const A a; a.get();//error when get is not const function``` 
       - 所以把不改变object 的<span style="color:red">function 设置成const, 可以提高函数灵活性</span>
   - <span style="color:red"> const object</span> 只能<span style="background-color:#FFFF00">call const function</span> 不能call nonconst function, <span style="background-color:#FFFF00">**Objects**</span> that are <span style="background-color:#FFFF00">**const**</span>, and <span style="background-color:#FFFF00">**references** or **pointers** to const objects</span>, may call <span style="background-color:#FFFF00">only const member functions.</span> 
- <span style="background-color:#FFFF00"> const member function that returns ```*this```</span> as a reference should have a return type ```const class & ```., 不能返回nonconst reference (因为```this``` is  a const reference, cannot convert to a const reference to nonconst reference ).
   - 但是如果不是返回```this```, 不必是const reference, 比如可以返回普通reference like ``` int&```(但若外面接用non const reference, 不能更改这个int, 因为是const function返回值, 不能更改object state)
- <span style="background-color:#FFFF00">可以overload function 基于是不是const </span> (match rule 跟function overloading match rule 类似)
  - <span style="color:red">const object 只能call const function, 不能call nonconst function</span>
  - <span style="color:red">nonconst object 可以call non-const 也可以call const version， 但是nonconst version 是better match(因为exact match 优于const version)</span>

**Defining a Function to Return “This” Object**: 下面例子```total``` 被绑定到```this```, ```rhs``` 被绑定到```trans```上, 


```c++
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
units_sold += rhs.units_sold; 
revenue += rhs.revenue; 
 return *this; // return the object on which the function was called

//use this to access the object as a whole

}

total.combine(trans); 
```


- inline member functions should be defined in the same header as the corresponding class definition
- **mutable Data Members**: <span style="background-color:#FFFF00">a mutable data member is never const even when it is a member of a const object(即使是const 对象成员,也不是const), a const member function of class may change a mutable member </span>


下面初始化Screen, class 内部初始化要么使用```=``` 在class内部初始化, or the direct form of initialization using ```{}```
```c++
class Screen{
public: 
    typedef std::string::size_type pos;
    Screen() = default; // needed because Screen has another constructor 
    
    // cursor initialized to 0 by its in-class initializer

    Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht * wd, c) { }
    //定义在class内部函数, inline, we don't need to specify inline, 但也可以specify


    char get() const // implicitly inline 定义在class 内部都是inline (implictly)

        { return contents[cursor]; } 

    inline char get(pos ht, pos wd) const; // explicitly inline

    Screen &move(pos r, pos c); // can be made inline later

private:
    pos cursor = 0;
    pos height = 0, width = 0; std::string contents;
    mutable size_t access_ctr; // may change even in a const object / const member function

}

std::vector<Screen> screens{Screen(24, 80, ' ') };

```

如果```move``` 和 ```set``` 返回都是class的reference(```*this```),
```c++
inline Screen &Screen::set(char c)
{
    contents[cursor] = c; 
    return *this;
} 

//则可以用

myScreen.move(4,0).set('#');
```
如果```move``` 和 ```set``` 返回都是value, 而不是reference
```c++
Screen temp = myScreen.move(4,0)
temp =  temp.set('#');
```
```const function```不能返回 nonconst的reference. const function内不能call non const function


```c++
//error

Screen& display(cout) const {
   return (*this);
}

//correct

const Screen& display(cout) const {
   return (*this);
}

Screen myScreen;
// if display returns a const reference, the call to set is an error 

myScreen.display(cout).set('*');
```

Const function overload, <span style="background-color:#FFFF00">object 是不是const, 决定call 哪个display function.</span>. 下面nonconst display 把 ```*this``` pointer implicit convert from ```Screen * const``` to ```const Screen * const``` 

```c++
class Screen { 
public:
// display overloaded on whether the object is const or not 

Screen &display(std::ostream &os)
    { do_display(os); return *this; } 
const Screen &display(std::ostream &os) const
    { do_display(os); return *this; }

private:
// function to do the work of displaying a Screen

void do_display(std::ostream &os) const {os << contents;} //inline implicitly 

//call这个function, 不会带来额外的开销(no run-time overhead)

};
```


#### (b), Friend and Encapsulation

A class may contain zero or more access specifiers(private, public), and there are no restrictions on how often an access specifier may appear.

The only difference between using class and using struct to define a class is the default access level and 继承是public and private. 

定义private encapsulation 的优点:
- 通过定义data private, 作者可以自由修改数据,只要interface 不变，用户代码不变，但是如果the data are public, then any code that used the old data members 也许brokern. 需要rewrite any code that relied on old representation 后才能使用
- 另一个定义private 优点.data are protected from mistakes that users might introduce, 防止因为用户原因数据被破坏, 如果发现bug corrupt object state, 发现bug位置是本地, 就去implementation差错, 而不用看用户的code, 降低了维护的难度


**friend**: 
- A class can allow another class or function to <span style="background-color:#FFFF00">access its nonpublic members</span> by making that class or function a **friend**. 
- <span style="background-color:#FFFF00">**Friend declarations**</span> may appear only inside a class definition. 友元声明只能在class 内部 (好的编程习惯是: 集中在程序开始或者结尾集中定义友元)
- <span style="color:red">如果Friend function定义在class 内部是**inline function**</span>
- <span style="background-color:#FFFF00">friend declaraction 仅仅specifies access, 而不是general declaration of the function</span>, 如果我们想要users able to call friend function. usually **declare each friend (outside the class)** in the same header as the class itself.
   - <span style="color:red">一个友元的outside declaration 必须在call 友元 的member function前面</span>, 所以用到友元的function 最好放在class 外面定义 (some compilers do not enforce the lookup rules for friends）

friend function 最好定义在class 外面, 定义在内部, 有的compiler 也可以pass, 算是declaration. Class Friend Function 不能通过class access
```c++
class Derived  {
protected:
   int j = 5;
public:
   friend void get(Derived& d) {
      cout << d.i << endl;
   }
};
Derived i;
d.get(i);//error 

get(i); //okay

```



**Friend Class**: 
- <span style="background-color:#FFFF00">friendship is not transitive</span>, 比如下面例子中 假如```Window_mgr```有自己的friends, those friends 没有access to ```Screen```
- 还用只声明一个class 的function 有friend 权限, Making a member function a friend 需要仔细设计程序, 比如下面例子中, ```clear``` 是 ```Window_mgr``` member 但用到 ```Screen``` 的 member
  - 首先定义class ```Window_mgr```. 其中声明但不定义```clear``` functinon，
  - 再定义class ```Screen```, including a friend declaration for ```clear```
  - 最后define ```clear``` 此时才可以使用```Screen```的成员
- Classes and nonmember functions need not have been declared before they are used in a friend declaration. When a name first appears in a friend declaration, that name is <span style="background-color:#FFFF00">implicitly assumed to be **part of the surrounding scope**</span>

```c++
class Screen{
    friend class Window_mgr; 
    //Window_mrg可以access Screen Class的所有数据


    friend void Window_mgr::clear(ScreenIndex); 
    //只声明class 一个clear function 有friend 权限, 但是clear需要declare before Class Screen 

}
```

下面函数
```c++
extern std::ostream& storeOn(std::ostream &, Screen &);//声明成友元

extern BitMap& storeOn(BitMap &, Screen &); 
//接受BitMap & 的storeOn, 对Screen 没有访问权限对private / public

class Screen {
// ostream version of storeOn may access the private parts of Screen objects

friend std::ostream& storeOn(std::ostream &, Screen &);
};
```

friend function scope
```c++
struct X {
    friend void f() { /* friend function can be defined in the class */ }
    
    X() { f(); } // error: no declaration for f;

    void h();
};
void X::g() { return f(); } // error: f hasn't been declared

void f(); // declares the function defined inside X 

void X::h() { return f(); } // ok: declaration for f is now in scope

```


#### (c). Class Scope


**Class Types**: 
- Every class defines a unique type, <span style="color:red">即使两个different types define the same members 他们也是不同类型的</span>. 
- 可以只声明class 而不定义class, like ```class Screen;```, 这种声明叫做**forward declaration**, class is <span style="color:red">considered declared (not yet defined) as soon as its class name has been seen</span>. 但在它声明之后 定义之前是一个**incomplete type**, 因为<span style="color:red">不清楚它包含哪些成员</span>
  - **imcomplete type**(只是这个class, 不算class内数据) can be **used** in limited ways: define <span style="color:red">**pointers**</span> or <span style="color:red">**references**</span> to such types, 也可以定义functions that use an incomplete type as a <span style="color:red">**parameter**</span> or <span style="color:red">**return type** </span>
  - 但是 <span style="color:red">a class cannot have members of its own type</span> 
- <span style="background-color:#FFFF00">A class 必须被**defined** 而不仅仅是声明before we creats objects of that type, acccess member type by using reference or pointer</span>. 因为compiler 需要know storage such objects need, 还 need to know 它有什么member
- 数据访问: class 外部访问public data/function，只能通过object, reference, pointer; <span style="color:red">type members(typedef) from the class 可以访问 using the scope operator.</span>
- 在class 外部定义function, 
   - 需要provide ```class name :: function name```. function内就可以随便用class member without using class name (因为everyname is seen in class scope)
   - function return type 声明在 class name 前, so return type is outside scope, 因此<span style="color:red">**return type需要specify class name** 和 ```::```, 如果return type is defined inside class</span>


```c++
struct First { int memi;
int getMem();
};
struct Second {
int memi;
int getMem();
};

First obj1;
Second obj2 = obj1; // error: obj1 and obj2 have different types

```

```c++
Sales_data item1; // default-initialized object of type Sales_data class 

class Sales_data item1; // equivalent declaration

```

数据访问, return type (如果定义在class内) not in class scope, 需要class name + scope operator

```c++
class Window_mgr { 
public:
    // add a Screen to the window and returns its index 

    ScreenIndex addScreen(const Screen&); 
};
// return type is seen before we're in the scope of Window_mgr

Window_mgr::ScreenIndex Window_mgr::addScreen(const Screen &s)
```

**(1).name lookup**: the process of finding which declarations match the use of a name
1. Look for declaration of the name in the block (before use of name) which the name was used. 只在名字出现在块中(使用之前的)查找
2. 如果名字没有发现, look in the enclosing scope（继续查找外层作用域)
3. if no declaration found, program is error

**class defintion are processed in order of** : 
1. memeber declarations are compiled (<span style="background-color:#FFFF00">**先编译成员声明**</span>)
2. function bodies/definitions are processed and compiled only after the entire class has been seen (<span style="background-color:#FFFF00">**直到class全部可见后,编译函数体**</span>)

- <span style="background-color:#FFFF00">因为函数体直到class 可见后 才compiled. 所以function 可以用任何name defined inside the class</span>. 假如function definition 和member declaration 同时进行, function只能用已经被看见的名字
- <span style="color:red">上面的two-step process 只适用于member function bodies</span>, Names used in declarations, 包括了<span style="background-color:#FFFF00">**return type** and types in **parameter** list 必须被看见before they are used</span>. 否则会报错
- <span style="color:red">tips:</span>: 定义type names (typedef, using) 通常在class beginning, 这样any member that uses that type will be seen after the type name has been already been defined

```balance```的```Money``` 来自于enclosing scope(外层作用域), return 的 ```bal``` 来自class内部而不是string
```c++
typedef double Money; 
string bal;
class Account { 
    public:
        Money balance() { return bal; }
    private:
        Money bal; 
};
```

**(2).Type Names Are Special**: 一般来说, inner scope can redefine a name from an outer scope (out scope names is hidden). 但是对于type 不行, <span style="color:red">class inner scope **cannot redefine a typename** </span> 如果这个type 被member function parameter/return 使用(typedef redefine 可以在VS中, 但不适用于linux) 

```c++
typedef double Money;
class Account {
public:
    Money balance() { return bal; } 
    // uses Money from the outer

private:
    typedef double Money; // error: cannot redefine Money

    Money bal;
};
```

比如下面的例子, in class and outside 都有typedef, 但是function 对同一个typedef用到不同的type, extremely confusing, 所以standard bans it 
```c++
using Foo = int;

struct X {
    Foo a;    // ::Foo, i.e., int
    
    void meow() { 
        Foo b = a; // X::Foo; error: no conversion from int to char*
	
    }
    using Foo = char*;
};
```

**(3). Normal Block-Scope Name Lookup inside Member Definitions**

A name used in the body of a member function is resolved as follows:(一般不建议use the name of another member as the name for function parameter, 不建议使用成员的名字用作函数参数)
1. 首先在member function内部寻找(在name 被使用之前部分)
2. 如果没有找到, 再到class 内部继续寻找declaration. All the members of the class are considered (class所有成员都被考虑)
3. 如果没有找到, look for a declaration that is in scope before the member function defintiion. (在函数定义前的作用域, 因为函数可能定义在class外部(in file) ) 

当compiler 处理dummy_fcn 的乘法时， 首先寻找 ```height```  in the scope of that function. 从parameter中找到
```c++
// note: this code is for illustration purposes only and reflects bad practice

// it is generally a bad idea to use the same name for a parameter and a member

int height; // defines a name subsequently used inside Screen

class Screen {
public:
    typedef std::string::size_type pos; 
    void dummy_fcn(pos height) {
        cursor = width * height; // which height? the parameter 
        
    }
private:
    pos cursor = 0;
    pos height = 0, width = 0;
};

```

上面例子中```height``` 隐藏了member named ```height```. 如果我们想override the normal lookup rules, 可以如下, 如果想使用outer class 外层作用域的, 可以用scope operator ```::```

```c++
//Case 1: class member height

// bad practice: names local to member functions shouldn't hide member names 

void Screen::dummy_fcn(pos height) 
{
cursor = width * this->height; // member height 

// alternative way to indicate the member

cursor = width * Screen::height; // member height

}

//Case 2: use class member 

// good practice: don't use a member name for a parameter or other local variable 

void Screen::dummy_fcn(pos ht) {
cursor = width * height; // member height 

}

//Case 3:  Use global

// bad practice: don't hide names that are needed from surrounding scopes 

void Screen::dummy_fcn(pos height) {
cursor = width * ::height;// which height? the global one 

}
```

注意 ```verify``` is not visible before the definition of the class screen. 但是第三步lookup includes the scope where member definition befores. 因为```verify```在```setHeight```前定义,因此找到
```c++
int height; // defines a name subsequently used inside Screen 

class Screen {
public:
    typedef std::string::size_type pos;
    void setHeight(pos);
    pos height = 0; // hides the declaration of height in the outer scope

};
Screen::pos verify(Screen::pos); 

void Screen::setHeight(pos var) {
// var: refers to the parameter

// height: refers to the class member

// verify: refers to the global function 

    height = verify(var);
}

```




#### (d). Constructors


**Constructors** 
- constructor  run whenever an object of a class type is created.只要class的对象被创建, 就会执行constructor
- Unlike other member functions, <span style="background-color:#FFFF00">constructor 不能被declared as const</span>. <span style="color:red">When we create a **const** object of a class type, the object 直到constructure completes the object's initialization 才获得constness 属性 </span>. constructors initialize const objects during their construction.
- Classes control default initialization by defining a special constructor, known as the **default constructor**: is one that takes no arguments.
  - <span style="background-color:#FFFF00">**default constructor** 是constructor work without any argument(either no parameters, or all parameters have default values)</span>; 错误的概念是constructor with no parameters; 比如```dog(string name = “Bob”); ```
  - 如果没有explicitly define any constructors, <span style="color:red">compiler will implicitly define and generate **synthesized default constructor**</span>, 对于大多数class, this synthesized constructor initializes each data member as follows: 
    - 如果there is an in-class initializer, 用default constructor 用初始值初始化成员 比如class 中```string a = "dog";```
    - Otherwise, default-initialize the member,比如class 中```string a;``` 默认初始化为空
    -  如果不支持默认初始化, your default constructor should use the <span style="background-color:#FFFF00">**constructor initailizer list**</span> to initialize every member of the class (e.g. ```sale(): a(0) {}```)
- constructor 不应该override in-class initializers except to use a different initial value.

**Some Classes Cannot Rely on the Synthesized Default Constructor**
- <span style="color:red">只有我们没有声明任何的constructor，compiler 才会generates **synthesized default constructor**, 如果有自己定义constructor， 除非自己定义default constructor, 否则不会生成
- 第二原因是: synthesized default constructor does the wrong thing, 比如数组或者指针对象被默认初始化, 他们值是未定义的
  - Classes that have members of built-in or compound 只当有 in-class initializers 才 should rely on the synthesized default constructor。
- <span style="color:red">有时候compiler is unable to systhesize one</span>. 比如一个class has member 没有default constructor, or const, reference 没有in-class initializer

<span style="color:red">library 比如vector or string, compiler generated 的 copy, assignment, destructor works correctly</span>, 因为the vector class takes care of copying or assigning the element. 当object is destroyed, the vector member is destroyed which 反过来destroys the elements in vector.


**(1). Constructor Initializer List**


Assignment 和 initialization 是不同的: <span style="background-color:#FFFF00">在class 中, Assignment是先初始化 再赋值， initialization是直接初始化</span>, 比如下面例子, How significant the distinction between initialization and assignment 由data member 类型决定

```c++
//is Initialization

class data{
    double revenue = 0.0; 
    string bookNo; 
};

//Is Assignment

class data{
    double revenue; 
    string bookNo;
    data(const string & a, double price){
        bookNo = a;
        revenue = price;
    } 
};
```

- <span style="color:red">必须用**constructor initializer list**  to provide values for members that are const, reference, or a class type that does have a default constructor</span>,const, reference 是必须initialized的
  - 如果member 有  <span style="background-color:#FFFF00">const or reference</span>, 不会有default constructor, 必须要<span style="background-color:#FFFF00">Initialized using constructor initialization list</span>
-  <span style="background-color:#FFFF00">class members are initialized 与他们在class 出现的顺序一致, **constructor initializer list** order 不会影响他们实际初始化的顺序</span>
   -  一般顺序不matter, 但是如果一个成员用另一个成员初始化后的值, order 就matter了 (有些compiler 会有warning)
   -  最好write **constructor initializer** in the <span style="color:red">**same order** as members are declared</span> in class. 其次避免using members to initialize other members
 
```c++
class ConstRef { 
public:
    ConstRef(int ii); 
private:
    int i, &ri;
    const int ci;
};

// ok: explicitly initialize reference and const members 

ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { }
```

Order of Initialization, 下边例子中, **constructor initializer list** 让 ```j``` is initialized then ```i```. <span style="color:red">但实际上是i先initialized, 但是当initialized 时 with the undefined value of j</span>
```c++
class X{
    int i;
    int j;
public: 
    // undefined: i is initialized before j

    X(int val): j(val), i(j){}
};

class want{
public:
	int a;
	int b;
	want(int x_, int y_) : b(x_), a(b) {}
};


list<int> l;
want a(10, 5);
cout << a.a << " , " << a.b << endl; //print 0, 10 

```

**(2) Delegating Constructor(委托构造函数)**: 

- <span style="background-color:#FFFF00">A **delegating constructor** uses another constructor from its own class to perform its initialization</span>
- In a delegating constructor, the member initializer list has single entry to call the same class another constructor. 
- When a constructor delegates to another constructor, 先run delegated-to constructor 之后才把control returned to the function body of delegating constructor

```c++
class Sales_data {
public:
    // nondelegating constructor initializes members from corresponding arguments 
    
    Sales_data(std::string s, unsigned cnt, double price):
            bookNo(s), units_sold(cnt), revenue(cnt*price) {}

// remaining constructors all delegate to another constructor

Sales_data(): Sales_data("", 0, 0) {} 
Sales_data(std::string s): Sales_data(s, 0,0) {} 
Sales_data(std::istream &is): Sales_data() {read(is, *this); }
};
```

**(2) Role of Default Constructor**: 

<span style="background-color:#FFFF00">The default constructor is used automatically whenever an object is default or value initialized</span>. Default initialization happens: 
1. when we define nonstatic varaibles or array without initializers
2. When a class that itself has members of class type uses the **synthesized default constructor**
3. When members of class type are not explicitly initialized in a constructor initializer list 

Value initialization happens: 
- Array Initilization, 当提供的初始值  fewer than its size
- <span style="background-color:#FFFF00">when we define a local static object without an initializer</span>
- 当我们书写```T()```的表达式explicitly request value initialization where ```T``` is the name of a type (比如vector constructor takes a single argument to specify vector's size) 

```c++
class NoDefault { 
public:
    NoDefault(const std::string&);
    // additional members follow, but no other constructors 

};

struct A { 
    NoDefault my_mem;
};
A a; // error: cannot synthesize a constructor for A 


struct B {
    B() {} // error: no initializer for b_member 
    
    NoDefault b_member;
};
```

错误declare object

```c++
Sales_data obj(); // error:  declare a function, not an object

//表示a function taking no parameters and return type is Sales_data

Sales_data obj;
```


**(3). Implicit Class-Type Conversions**

-  constructor that can be called with **single argument** defined an **implicit conversion** (有时候叫 **converting constructors**)
    - 定义了conversion from constructor's parameter type to class type.
- <span style="background-color:#FFFF00">只允许一步conversion</span>, 比如constructor take a string parameter, 我们不可以用```const char*``` 到string 再到class type
- **explicit**: prevents implicit conversion. <span style="background-color:#FFFF00">explicit meaningful only on constructor that can be called with a single constructor.</span>.
    - <span style="color:red">**explicit** is used only on constructor declaration inside the class.</span> It is not repeated on a definition outside class body.  
    -  对于constructor that require more arguments 不会perform implicit conversion,所以没有用explicit的必要性
    - **explicit** 只能用于direct initialization, 不能用于copy initialization 
    - compiler will not do implicit conversion for **explicit**, but we can use 有**explicit** constructor to <span style="color:red">**force a conversion**</span> (比如```static_cast```)

e.g. ```string -> Sales_data```, compiler automatically creates a temporary ```Sales_data``` object from ```string``` then pass to ```combine```. 因为```combine``` take const reference, we can pass tempoary object
```c++
struct Sales_data {
    Sales_data(std::string s): Sales_data(s, 0,0) {} 
    Sales_data(std::istream &is): Sales_data() {read(is, *this); }
    Sales_data& Sales_data::combine(const Sales_data &rhs)
    {
        units_sold += rhs.units_sold; 
        revenue += rhs.revenue; 
        return *this; // return the object on which the function was called 
		
    }
  };

string null_book = "9-999-99999-9";
item.combine(null_book);

// error: requires two user-defined conversions: 

// (1) convert "9-999-99999-9" to string

// (2) convert that (temporary) string to Sales_data 

item.combine("9-999-99999-9");

//one step implicit type conversion 

// ok: explicit conversion to string, implicit conversion to Sales_data

 item.combine(string("9-999-99999-9"));
 // ok: implicit conversion to string, explicit conversion to Sales_data 
 
 item.combine(Sales_data("9-999-99999-9"));
```

**explicit**
```c++
class Sales_data { 
public:
    Sales_data() = default;
    Sales_data(const std::string &s, unsigned n, double p):
        bookNo(s), units_sold(n), revenue(p*n) { } 
    explicit Sales_data(const std::string &s): bookNo(s) { } 
    explicit Sales_data(std::istream&);
};

item.combine(null_book); // error: string constructor is explicit 

item.combine(cin); // error: istream constructor is explicit

```

explicit 只用于declaration inside class, not for definition outside class 
```c++
// error: explicit allowed only on a constructor declaration in a class header 

explicit Sales_data::Sales_data(istream& is)
{ read(is, *this);}
```

<span style="color:red">explicit 只能用于direct initialization, not for copy initialization</span> 
```c++
Sales_data item1 (null_book); // ok: direct initialization

// error: cannot use the copy form of initialization with an explicit constructor 

Sales_data item2 = null_book;
```

可以用 有explicit constructor to <span style="color:red">force conversion</span>, ```static_cast``` to perform an explicit, rather than an implicit conversion. 用```static_cast``` uses the ```istream```constructor to construct temporary ```Sales_data``` object 
```c++
// ok: the argument is an explicitly constructed Sales_data object 

item.combine(Sales_data(null_book));
// ok: static_cast can use an explicit constructor

item.combine(static_cast<Sales_data>(cin));
```

**(4). Aggregate Classes**

An **aggregate class** gives users direct access to its members and has special initialization syntax. A class is an aggregate if 
- All of its data members are public (所有public)
- It does not define any constructors (没有定义任何constructor)
- It has no in-class initializers (没有class 内部数据初始值)
- It has no base classes or virtual functions. (没有base class 和 virtual)

An aggregate class 可以:
- An aggregate class can define member functions
- An aggregate class can overload operators.

Initialization: 
- we can initialize the data members of an aggregate class <span style="background-color:#FFFF00">by providing a braced list of member initializers</span>
- <span style="color:red">Initializer的**order** 必须与declaration of data members 一样</span>
- 如果提供的elements are fewer than class members, <span style="color:red">the trailing members are value initialized</span>

Aggregate class 的Initialization **Drawbacks**: 
1. Requires that all data members of class be <span style="color:red">**public**</span>
2. 将正确初始化的重任(burden)给了user. <span style="color:red">**error-prone**</span>, 因为用户容易忘记值, 或者提供一个不正确的初始值 
3. If a member is added or removed, all initialization have to be updated.


Example of aggregate class
```c++
struct Data{
    int ival;
    string s;
}

// val1.ival = 0; val1.s = string("Anna") 

Data val1 = { 0, "Anna" };
```

**(5). Literal Classes**

- A **literal type** is a type that can <span style="color:red">qualify as constexpr</span>. This is true for scalar types, references, certain classes, and arrays of any such types.
   - **scalar type** 包括了 
      - arithmetic (integral, float)
      - pointers: T * for any type T (比如pointer to a class is scaler type 但是这个class 本身不是scalar type)
      - enum
      - pointer-to-member (object pointer, function pointer, nullptr_t)


**literal clasess** 标准 if it is :
- a scalar type or  
- a reference type or 
- a array of iteral type or 
- a class types of following properites
    - all of its non-static data members and base classes are of literal types.
    - it is an aggregate type or has at least one ```constexpr``` constructor (至少有一个class type) or constructor template that is not a copy or move constructor, and
    - every constructor call and full-expression in the brace-or-equal-initializers for non-static data members (if any) is a constant expression 
    - it has a trivial destructor (default destructor 自己不定义destructor or use keyword ```default```)
    

<br/>
- 如果是**aggregate class**, 则class data members are of literal type is a literal class. 
- 如果 是nonaggregate class, 则需要满足下列要求: 
  - data members all must literal type
  - The class must have <span style="background-color:#FFFF00">at least one ```constexpr``` constructor</span> 
  - If a data member has an in-class initializer, the initializer for a member of built-in type must be a [constant expression](#Constexpr). 如果不是built-in type, the initializer must use the member's own ```constexpr``` constructor.  
  - The class must use default definition for its destructor (default destructor), which is the member that destroys objects of the class type.

```constexpr``` parameter 和 return type 必须是 **literal type**. class that are **literal type** 也许有funcition members that are **constexpr**(需要meet all requirements of ```constexpr``` function, 这些function 也是<span style="color:red">**implicitly const**</span>)

**constexpr Constructor**
- **constexpr constructor** can be declared as ```= default``` (or ```= delete```)的形式. 
- 如果没有用```=default```, <span style="background-color:#FFFF00">需要meet requirements of constructor(no return statment) and ```constexpr function```</span>(the only executable statement it can have is return statment(only one return)), <span style="color:red">所以通常上body of **constexpr constructor** (body)  is empty</span>
- <span style="color:red">**constexpr constructor** must initialize every data member.</span> The initializers 必须either **constexpr constructor** or a constant expression 
- A **constexpr constructor** is used to generate objects that are ```constexpr``` and for parameters or return types in constexpr functions(用于生成```constexpr```对象以及```constexpr``` 函数的参数或返回类型)

```c++
class Debug { 
public:
    constexpr Debug(bool b = true): hw(b), io(b), other(b) {}
    constexpr Debug(bool h, bool i, bool o):
        hw(h), io(i), other(o) {}
    constexpr bool any() { return hw || io || other; } 
    void set_io(bool b) { io = b; }
    void set_hw(bool b) { hw = b; }
    void set_other(bool b) { hw = b; }
private:
    bool hw; // hardware errors other than IO errors 
    
    bool io; // IO errors

    bool other; // other errors
};
```

```c++
constexpr Debug io_sub(false, true, false); // debugging IO

if (io_sub.any()) // equivalent to if(true)

    cerr << "print appropriate error messages" << endl;

constexpr Debug prod(false); // no debugging during production 

if (prod.any()) // equivalent to if(false)

    cerr << "print an error message" << e
```


Definitions of constexpr constructors must satisfy the following requirements(from IBM):

- The containing class must not have any virtual base classes(used in virtual inheitance).
- Each of the parameter types is a literal type.
- Its function body is = delete or = default; otherwise, it must satisfy the following constraints:
   - It is not a function try block.
   -  The compound statement in it must contain only the following statements(除了return的语句可以是):
         - null statements
         - static_assert declarations
         - typedef declarations that do not define classes or enumerations
         - using directives
         - using declarations
- Each nonstatic data member and base class subobject is initialized.
- Each constructor that is used for initializing nonstatic data members and base class subobjects is a constexpr constructor.
Initializers for all nonstatic data members that are not named by a member initializer identifier are constant expressions.
- When initializing data members, all implicit conversions that are involved in the following context must be valid in a constant expression:
   - Calling any constructors
   - Converting any expressions to data member types

#### (e). Static Members

- static member can be public or private. The type of ```static``` data member can be ```const```, reference, array, class type. 
- private static member 只能被member function call, 可以用来初始化static variable(见下面例子),不能被outside class用
- <span style="background-color:#FFFF00">**static members**</span> of a class exist <span style="background-color:#FFFF00">**outside any object**</span>.Object do not contain data associated with static data members. static member functions 不与对象绑定(bound)在一起. 只能是单向的: 从normal function 中call static varaibles/function 不可以从static function中call normal varaibles 
   - <span style="background-color:#FFFF00">static member function 不能declared as **const** function</span>. 
   - static member functions <span style="color:red">don't have ```*this``` pointer.不能用```*this```在static member 中</span>, This restriction适用于explicit use of ```this``` and implicit use of ```this``` by calling a nonstatic member.
   - <span style="color:red">static function 中不能call nonstatic variable 或者 nonstatic function</span>
   - <span style="color:red">但member function 可以用static function/variable</span> (without scope operator) 
- can use scope operator to access static member ```Account::initRate```, 也可以通过object, reference, pointer of class type to access 
- <span style="color:red">member function can use static member directly</span> without scope operator

```c++
class Account{
public:
   void calculate() { amount += amount * interestRate; }
   static double rate() { return interestRate; }
   static void rate(double);
private:
   std::string owner;
   double amount;
   static double interestRate;
   static double initRate();
   //银行利率 需要apply给所有user, 用static
   
};
```

```c++
double r;
Account ac1;
Account *ac2 = &ac1;
// equivalent ways to call the static member rate function

r = ac1.rate(); // through an Account object or reference

r = ac2->rate(); // through a pointer to an Account object

```

**Define Static Members**
- 因为static data members 不是 part of objects of class type, 他们并不是在create object是被定义的. They are <span style="color:red">not initialized by class constructor</span>, 
- 不能initialize static member inside class, 必须<span style="background-color:#FFFF00">define and initialize static data member outside class body</span>
- 和其他object一样,static data member<span style="background-color:#FFFF00">只能被定义一次</span> (好习惯是 把所有static member的definitions 和所有noninline member functions的定义放在一起)
- <span style="color:red">可以define static member function 在class内部或者外部</span>.如果在外部define, 不用加上 ```static``` keyword


下面例子initialize static ```interestRate```例子, Once the class name ```Account``` is seen, we can <span style="color:red">use ```initRate``` without scope operator</span> as the initializer for ```rate```. Note 尽管```initRate``` is private, 可以<span style="color:red">用它initialize ```interestRate```</span>. 
```c++
//不需要static keyword to define static member

void Account::rate(double newRate)
{
interestRate = newRate;
}

//initialize static data member

double Account::interestRate = initRate();
```

**In-Class Initialization of static Data Members**
- 通常static members不能intialized in class body. 但可以为static members 提供  <span style="color:red">**const integral type**</span>的in-class initialzers,  不过必须要求static members必须是 <span style="color:red">**constexpr of literal type**</span>.
   - initializer 必须是**constant expression**
- 如果某个static member 仅限于compiler可以替换它的值, then 一个初始化的const or constexpr static 不需要分别定义. 如果将它用于值不能替换的场景中, then 该成员必须有一个定义语句 
   - 例如下面例子中, 用到```period```的地方仅仅是```daily_tbl```, there is no need to define ```period``` outside class ```Account```, 但是程序细微的改变不能造成无法编译, 因为找不到该成员定义. e.g. pass ```period``` to a function that takes a ```const int&``` then peiord must be defined 
- 如果an initializer provided inside class, <span style="background-color:#FFFF00"> member definition outside class 不能specify an initial value</span>
- 好的编程习惯是: Even if a const static data member is initialized in the class body, that
member ordinarily should be defined outside the class.

```c++
class Account {
public:
   static double rate() { return interestRate; }
   static void rate(double);
private:
   static constexpr int period = 30;// period is a constant expression

   double daily_tbl[period];
};

// definition of a static member with no initializer

constexpr int Account::period; // initializer provided in the class

```

**static Members Can Be Used in Ways Ordinary Members Can’t**

- 因为static member 是不跟object 绑定, 所以static data member 可以是<span style="background-color:#FFFF00">**incomplete type**</span>. static data member 可以是the same type as the class type, A non-static member 不可以这样declared, 只可以declare reference or pointer to an object of its class
- we can use static member as <span style="color:red">**default argument**</span>. (非static data member不能被使用为default argument 因为its value is part of the object, 看见parameter时, class declaration 还没有完成, so is an error) 

```c++
class Bar {
private:
   static Bar mem1; // ok: static member can have incomplete type
   
   Bar *mem2; // ok: pointer member can have incomplete type
   
   Bar mem3; // error: data members must have complete type
   
};
```
拿static member as default argument 
```c++
class Screen {
public:
// bkground refers to the static member

// declared later in the class definition

   Screen& clear(char = bkground);
private:
   static const char bkground;
};
```
***
<br/><br/><br/>

## 8. IO Library

#### (a). IO Classes

|  Header     | Type |
|   ---      | :---    |  
| iostream |  istream, wistream reads from a stream <br/> ostream, wostream writes to a stream <br/> iostream, wiostream reads and writes a stream  | 
| fstream |  iftream, wifstream reads from a file <br/> ofstream, wofstream writes to a file <br/> fstream, wfstream reads and writes a file  | 
| sstream |  istringstream, wistringstream reads from a string <br/> ostringstream, wostringstream writes to a string <br/> stringstream, wstringstream reads and writes a string  | 

为了支持wide characters,library defines types and objects 用来操作 ```wchar_t``` data. e,g, ```wcin```,```wcout```, ```wcerr```. wider character types and objects 定义在same header, 所以比如 ```fstream``` 有```ifstream```, 也有```wifstream```.

- <span style="background-color:#FFFF00">ifstream and istringstream inherit from istream, 因次可以像使用istream对象一样使用```ifstream``` 和 ```istringstream```</span>, 同样, <span style="background-color:#FFFF00">ofstream and ostringstream inherit from ostream</span> , 所以他们用```cin```, ```cout```的方法都是一样的,


**(1). No Copy or Assign for IO objects**

- 因为IO 不能符号或者赋值, 所以 不能有parameter or return type 是 IOStream types. 对IO操作的function <span style="background-color:#FFFF00">通常通过reference的方式pass and return</span>
- <span style="color:red">因为Reading or writting IO object change its state</span>, 因此<span style="background-color:#FFFF00">reference must not be ```const```</span>

```c++
ofstream out1, out2;
out1 = out2; // error: cannot assign stream objects

ofstream print(ofstream); // error: can't initialize the ofstream parameter

out2 = print(out2); // error: cannot copy stream objects

```

**(2). Condition States**

- 因为IO操作会可能发生错误, 一些错误是可以恢复的, 而另一些错误已经到了系统深处(deep within the system),已经超过程序可以修改的范围. IO classes 定义了一些functions and flags 让我们access and manipulate the condition state of a stream
- 一旦stream 发生错误, 后续的IO 操作都失败, 比如```int a; cin>>a``` 却输入了string. 简单方法是check the stream is okay before attempint to use, 下面的while <span style="color:red">check the state of stream returned from ```>>``` expression</span> . 如果成功再继续
  - while 只告诉valid or not, not telling why invalid 
- ```iostate``` used to convey information about the state of a stream. <span style="background-color:#FFFF00">This type used the collection of bits.</span> IO 定义了四个```constexpr```values of type ```iostate```
  - 一旦```badbit``` set, 不能再使用stream了,
  - ```failbit``` set after recoverable error, 比如读了个char when nuemric expexted. Possible to correct problems and continue using the stream
  - ```goodbit``` guaranteed to have value 0, 表示no failures on stream.
  - 如果任何```badbit```, ```failbit```, or ```eofbit``` set, then condition that evaluates that stream fails.
  -  ```s.good()``` or ```s.fail()```(fail or bad) 是确定stream 总体状态的正确方法. 实际上, 把流当条件使用的代码等于```!fail()```, ```s.eof``` 和 ```s.bad``` 检查specific error


|  Syntax     |  Description |
|   ---      | :---    |  
| ```strm::iostate``` |  ```strm``` is IO的一种类型,像上面的表中一样，可以是```ios::```, ```fs::```, ```ss::```, ```iostate``` is a machine-dependent integral type that represents the condition state of a stream | 
| ```strm::badbit``` | indicate stream is corrupted(崩溃). It is not possible to use once ```badbit``` set |
| ```strm::failbit``` |  indicate IO operation failed(IO 操作失败了). ```failbit``` set after a recoverable error. 有可能fix error and continue using the stream. |
| ```strm::eofbit``` |  indicate a stream hit end-of-file (流已经到达了文件结束) |
| ```strm::goodbit``` |  indicate a stream is nt in error state. This value is guaranteed to be zero (流没有错误)  |
| ```s.eof()``` | return true if eofbit in the stream s is set (若流到达了eofbit位置) |
| ```s.fail()``` | return true if failbit or badbit in the sream s is set |
| ```s.bad()``` |  return true if badbit is in stream s in set | 
| ```s.good()``` |  return true if the stream s is in a valid state | 
| ```s.clear()``` | reset all condition values in the stream s to valid state. Return void |
| ```s.setstate(flag)``` | reset the condition of s to flags(根据条件状态对流s置位). type of flag 需要是上面几个state 的一种. Return void | 
| ```s.rdstate()``` | return current condition of s as a ```strm::iostate``` value | 

check the stream before use
```c++
while (cin >> word)
// ok: read operation successful . . .

```

Managing the Condition State
```c++
// remember the current state of cin

auto old_state = cin.rdstate(); // remember the current state of cin 

cin.clear();// make cin valid

process_input(cin); // use cin

cin.setstate(old_state);// now reset cin to its old state


// turns off failbit and badbit but all other bits unchanged 

cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);
```


**(3). Managing the Output Buffer**

- 每一个流都管理一个缓冲区(buffer), 用来hold data that program reads and writes. 比如```os << "please enter a value: ";```, literal string 也许会printed immediately, or operating system 也许store the data in a buffer to print later 
- Using a buffer 可以<span style="background-color:#FFFF00">combine serval output operations into a single system-level write</span>. 因为writing to device 可能time-consuimg, 如果let operating system combine several output operations into a single write 可以provide an important <span style="color:red">**performance boost**</span>.
- <span style="background-color:#FFFF00">Buffers Are not flushed if program crashes</span>. 如果程序异常终止, 缓冲区不会刷新, 当一个程序崩溃(crash)后, 它输出的数据可能停留在输出缓冲区中等待打印
  - when debug a program that crashed, 需要make sure any output you think should have been written was actually flushed. 否则可能花大量时间track through code 为什么没有执行. 而实际上已经执行了, 只是程序crash后缓冲区没有刷新(flush), 输出的数据没有打印而已(output pending)

有几种条件导致buffer刷新(buffer flushed - write to actual output device or file  ) 
  - The program completes normally. All output buffers are flushed as part of return from main. 
  - At some indeterminate time, the buffer can become full, it will flushed before writing next value (缓冲区满了)
  - flush the buffer explicitly using a manipulator(操作符) such as ```endl```
  -  after each output operation, 可以用 manipulator ```unitbuf``` 设置流内部状态(set the stream's internal state) to 清空缓存. 默认情况下, 对```cerr```是设置```unitbuf```的, 所以写到```cerr```的内容都是立即刷新的
  -  Output stream might be tie to another stream. 这种情况下, when tied stream is read or written, 关联的流的缓冲区会被刷新(flush). By default,```cin``` and ```cerr``` are both tied to ```cout```. 因此reading to ```cin``` or writing to ```cerr``` flushes the buffer in ```cout```.

Manipulators
- ```endl```: end current line and flush the buffer
- ```flush``` flush the stream and adds no character to the output
- ```ends``` inserts a null character into buffer and flush

```c++
cout << "hi!" << endl; // writes hi and a newline, then flushes the buffer

cout << "hi!" << flush; // writes hi, then flushes the buffer; adds no data 

cout << "hi!" << ends; // writes hi and a null, then flushes the buffer

```

**unitbuf Manipulator**: If we want to flush after every output, we can use the ```unitbuf``` manipulator. ```unitbuf``` tell the stream to do ```flush``` after every subsequent write. ```nounitbuf``` manipulator restores the stream to use normal, system-managed buffer flushing: 

```c++
cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区

 // 任何输出都立即刷新, 无缓冲

cout << nounitbuf; // returns to normal buffering

```

- 当一个输入流关联到输出流, 任何试图从输入流(intput stream)读取数据的操作 都会先刷新关联的输出流(output stream). 
  - The library ties ```cout``` to ```cin```. 因此 ```cin >> ival``` 会导致```cout```的缓冲区刷新(flush)
- interactive systems 通常应该关联输入流和输出流, 意味着, 用户提示的信息，都会在读操作前被打印出来

**tie**: has two overloaded versions. 
- one version takes no argument, 返回指向输出流指针. 如果this object is currently tie to output streams. 返回就是a pointer to the output stream。 
- 另一个version: take a pointer to an ```ostream```, 将自己关联到```ostream```上, ```x.tie(&o)```: tie the stream ```x``` to the output stream ```o```. 
- can tie either an ```istream``` or an ```ostream``` object to another ```ostream```

下面代码中, 将一个给定的流关联到一个新的输出流, 我们将新流的指针传递给```tie```。而彻底解开关联的流, we pass an null pointer. <span style="background-color:#FFFF00">每个流最多可以关联到一个流, 但是多个流可以关联到同一个```ostream```</span>
```c++
cin.tie(&cout); // illustration only: the library ties cin and cout for us 

// old_tie points to the stream (if any) currently tied to cin

ostream *old_tie = cin.tie(nullptr); // cin 不再与其他流灌流

// ties cin and cerr; not a good idea because cin should be tied to cout 

cin.tie(&cerr); // 读取cin 会刷新cerr 而不是cout 

cin.tie(old_tie); // reestablish normal tie between cin and cout

```

#### (b). File Input and Output

- ```getline```是从一个```ifstream```中读取数据.  <span style="color:red">```getline``` 不会跳过空格, 如果读取的string 第一个是空格，会保留空格</span>
- ```fstream``` 除了继承```iostream```的类型外, ```fstream```中定义的类型还增加了一些新的成员管理与流关联的文件. 如表中, 可以对```fstream```, ```ifstream```, ```ofstream``` 对象调用这些操作, 但不能对其他的```IO```类型调用这些操作
- when we creat a file stream, 可以选择性提供一个file name, associate that object with file. 如果提供file name, ```open``` is called automatically.
- 因为 ```fstream``` 除了继承```iostream```的类型, 可以用```fstream``` type 代替```iostream&``` tyes
- 如果关联一个流从一个file到另一个file, 需要先关闭```ifstream in(a); in.close()``` 再open ```in.open(name)```
- When an fstream object is <span style="background-color:#FFFF00">destroyed</span>, <span style="background-color:#FFFF00">close is called automatically</span>. 局部变量```fstream```离开作用域时, 关联文件会自动关闭

| Syntax | Description |
|  --- | :--- |
| ```fstream fstrm``` | 创建一个未绑定的流. ```fstream```是定义在```fstream``` header中的一种类型 |
|  ```fstream fstrm(s)``` | Creates an ```fstream``` and opens the file named s. ```s``` 可以是string or pointer to C-style character string. 这个constructor 是```explicit```的, 文件默认模式depends on the type of ```fstream``` |
|  ```fstream fstrm(s,mode)``` | 按照指定mode 打开文件 | 
| ```fstrm.open(s)``` | 打开名为s的文件, 并将文件与```fstrm``` 绑定.  ```s``` 可以是string or pointer to C-style character string. 这个<span style="color:red">constructor 是```explicit```的</span>, 文件默认模式depends on the type of ```fstream``` | 
| ```fstrm.close()``` | 关闭与```fstrm``` 绑定的文件，并返回void | 
| ```fstrm.is_open()``` | 返回一个bool 值,指出与```fstrm``` 关联文件是否成功打开且尚未关闭 | 

to verify if ```open``` succeeded is 好习惯
```c++
ifstream in(ifile); 

ofstream out; 

out.open(ifile + ".copy"); // open the specified file

if(out) // check that open succeeded 

    // the open succeeded, we can use the file

```

**(2).File Modes**

| syntax | Description |
| --- | :--- |
| ```in``` | Open for input | 
| ```out``` | open for output|
| ```app``` | seek to the end before every write 每次写操作前均定位到文件末尾 | 
| ```ate``` | Seek to the end immediately after the open 打开文件后立即到文件末尾 |
| ```trunc``` | Truncate the file | 
| ```binary``` | 以二进制方式进行IO operations |

The mode that we can specify have following restrictions: 
- ```out``` 只能对```ofstream``` or ```fstream``` object, ```out``` is default for ```ofstream```
- ```in``` 只能对 ```ifstream``` or ```fstream``` object, ```in``` is default for ```ifstream```
-  只有当```out``` is specified, 才能设定```trunc``` 模式
-  只要当 ```trunc``` 没被设定, 就可以设定```app``` 模式. 如果指定```app```, 即使没有explicitly specify ```out```, 文件也是以输出方式打开
-  By default, ```trunc```is default mode for ```out```(如果不设定, 默认是```trunc```).如果要保留文件内容, 需要specify ```app```, or specify ```in``` mode which file is open for both input and output 
- The ```ate``` and ```binary``` modes may be specified on any file stream , 且可以与任何其他文件模式组合使用

```c++
// 下面三行是一样的

ofstream out("file1"); // out and trunc are implicit

ofstream out2("file1", ofstream::out); // trunc is implicit 

ofstream out3("file1", ofstream::out | ofstream::trunc);

// to preserve the file's contents, we must explicitly specify app mode

//下面两行是一样的

ofstream app("file2", ofstream::app); // out is implicit 

ofstream app2("file2", ofstream::out | ofstream::app);
```

#### (c). String Streams

- ```sstream``` inherit frorm ```iostream``` header. 除了继承, ```sstream```中定义的类型还增加了一些成员管理```string```, 下面表中可以对```stringstream``` 对象调用这些操作, 但不能对其他的IO类型进行操作
- 即使```sstream``` and ```fstream``` share the the interface as ```iostream```. They have no other interrelationship. We cannot use ```open``` and ```close``` on a ```stringstream```. 也不能use ```str``` on an ```fstream```

| Syntax | Description | 
| --- | :--- | 
| ```sstream strm``` | ```sstream``` 是定义的在```sstream``` header 中一个类型, |
| ```sstream strm(s)``` | ```strm``` is an sstream tat holds a copy of string s. This constructor is explicit (不能pass c-character strings)|
| ```strm.str()``` | Returns a copy of string that ```strm``` holds | 
| ```strm.str(s)``` | copy the string s into strm. Returns void | 

**(1). istringstream**

当我们某些工作是对整行文本进行处理, 而其他一些工作是处理行内单个单词 可以用```istringstream```

e.g. 我们数据是如下类型，可以定义struct
```
morgan 2015552368 8625550123
drew 9735550130
lee 6095550132 2015550175 8005550000
```

下面code 中 ```while(record >> name)``` 与 ```while(getline(cin, line))``` 不同的是, loop reads data from ```string``` rather than the standard input. 当string completely read, "end-of-file" is signaled aand the next input operation on record will fail. 

```c++
struct PersonInfo {
    string name; 
    vector<string> phones;
};

string line, word;
vector<PersonInfo> people;
while(getline(cin, line))// or while (cin >> line)

{
    PeopleInfo info;
    istringstream record(line);
    record >> info.name;
    while(record >> word){
        info.phones.push_back(word);
    }
    people.push_back(info);
}
```

**(2). ostringstream**: is useful when一点点build up a output, 但是希望最后一起output

例如继续用上面```PersonInfo``` struct
```c++
for (const auto &entry : people) { 
    ostringstream formatted, badNums; 
    for (const auto &nums : entry.phones) {
        if (!valid(nums))
            badNums << " " << nums; 
        else
            formatted << " " << format(nums);
    }
    if (badNums.str().empty()) 
        os << entry.name << " " << formatted.str() << endl; 
    else 
        cerr << "input error: " << entry.name
            << " invalid number(s) " << badNums.str() << endl; 
}
```
***
<br/> <br/> <br/>
































## 9. Sequential Containers


**sequential containers** 为user 提供 control the order in which the elements are stored and accessed. Order 取决于元素加入容器(container)时的位置. By contrast, the ordered and unordered **associative containers** store theire elements based on the value of a key

#### (a). Overview

| Type | Description | 
| --- | :--- | 
| vector | Flexible-size array. Fast random access. Insert/delete elements other than at the back may be slow |
| deque | Double-ended queue. <span style="color:red"> Fast random access </span> Fast insert/delete at front or back|
| list | Double Linked list. Only bidirectional sequential access. Fast insert/delete at any pont in the list | 
| forward_list | Single Linked list. Only sequential access in one direction. Fast insert/delete at any point in the list <span style="color:red">(不支持reverse_iterator)</span> |
| array |  <span style="color:red"> **Fixed-size** array. Supports fast random access. **Cannot add or remove elements** |
| string | A specialized container, similar to vector that contains characters. Fast random ccess. Fast insert/delete at the back |

- the new library containers are <span style="color:red">dramatically faster</span> than previous release. <span style="background-color:#FFFF00">Modern C++ programs should use library containers</span>
- **string** and **vector** hold their elements in <span style="background-color:#FFFF00">contiguous memory</span>.由下标计算其地址很快, 但是一次插入或者删除后,<span style="background-color:#FFFF00">需要移动插入/删除位置之后的所有元素, 来保持连续存储(maintain contiguity)</span>; 而且添加一个元素可能需要分配额外的存储空间. At the case, every element must be moved into the new storage. 
- **list** and **forward list** designed to fast to add / remove element anywhere in container. 作为代价，<span style="color:red">**不支持random access**</span>. 而且与**string**,  **deque**
,**array** 相比, <span style="color:red">memory 开销(overhead) 也很大</span>
-  与build-in array相比, An **array** 是更安全容易使用的. 与build-in array一样,是fixed size的,不支持add/remove element.
- **forward_list**  不支持```size``` operation 因为storing or computing its size 多出额外的开销compared to handwritten list.


**Deciding Which Sequential Container to Use**
- If your program has lots of small elements and <span style="color:red">space overhead matters, don’t use **list** or **forward_list**</span>.
- If the program needs to insert or delete elements：
   - Insert/Delete in the  <span style="color:red"> middle</span> of the container, use a **list** or **forward_list**.
   - Insert/Delete elements at the  <span style="color:red"> front and the back</span>, but not in the middle, use a **deque**.
   - Insert into the  <span style="color:red"> middle</span>, consider using a **list** for the input phase. Once the input is complete, copy the list into a **vector**.
- 如果程序需要random access , insertion and deletion. 决定取决于 <span style="color:red"> Random Access VS Insertion/Deletion </span>  relative cost of accessing elements in a **list** or **forward_list**   VS  cost of inserting/ deleting in **vector** or **deque**
- 如果不确定使用哪个, 可以在程序中只使用 operations common to both **vector** and **list**. <span style="background-color:#FFFF00">**Use iterators, not subscripts and avoid random access to elements**</span>

#### (b). Container Library Overview

**(1). Array**

- 除了```array``` which is fixed-size(不能add / delete), 剩下的container provide efficient, flexible memory management, growing and shrinking the size.
- <span style="color:red">**Array**: size is part of its type</span>. 当define array, 需要specify element type and size ```array<int, 42>```. 
- 不支持normal container constructor 因为这些constructor need the size of the container. 
    - 不像其他container, <span style="color:red">A default-constructed array is not empty: It has as many elements as its size(elements are **default initialized**)</span>
    - 如果提供initializer,必须提供equal or less than size. 如果fewer initializers than size, remaining value是value initialized. <span style="background-color:#FFFF00">如果array element type is class type, class 必须有default constructor.</span>
    - array 支持<span style="background-color:#FFFF00">**copy assignment** 和 **copy construct**</span>, 只要type (size, element type) matches, ```array<int, 10>a3(a2);```
    - array 支持 **braced list assignment**(新版C++17支持), 也支持**braced list initialization** ```array<int,10>a1; a1 = {0}; ```
    - array <span style="background-color:#FFFF00">不支持 iterator constructor</span> (Array没有no ```begin```, ```end```), ```Assign``` function 

 
Array initialization
```c++
array<int, 10> ia3 = {42}; // ia3[0] is 42, remaining elements are 0

int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; // error: no copy or assignment for built-in arrays 

array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};

array<int, 10> copy = digits; // ok: so long as array types match


array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9}; p
array<int, 10> a2 = {0}; // elements all have value 0

a1 = a2; // replaces elements in a1

a2 = {0}; // okay: assign to an array from a braced list C++17

```   

- The constructors that <span style="background-color:#FFFF00">take a size are valid only for sequential containers</span>; they are not supported for the associative containers. e.g. ```vector<int> a(10)```





```c++
// assume noDefault is a type without a default constructor

vector<noDefault> v1(10, init); // ok: element initializer supplied 

vector<noDefault> v2(10); // error: must supply an element initializer

```


**(2). Containner Assignment Operatior**

- <span style="background-color:#FFFF00">**Assign operations**</span> not valid for associative containers or array。 Assignment related operations <span style="background-color:#FFFF00">**invalidate** iterators</span>, references, and pointer into the left-hand container。除了string 和array 外,而<span style="background-color:#FFFF00">```swap``` 操作不会导致iterator, 引用，指针失效 </span>
- Excepting array, swap does not copy, delete, or insert any elements and is <span style="background-color:#FFFF00">guaranteed to run in constant time</span>.
    - elements themselves are not swapped; **internal data structures** are swapped.
    - <span style="background-color:#FFFF00">但是swap arrays 会真正交换他们的element</span>. 因此After swap, pointers, references, and iterators remain <span style="color:red">bound to the same element</span> they denoted before the swap, . 但是<span style="color:red">值已经与另一个array中交换了</span>(e,g,iterator 指向一样的```ivec[1]```,只是```ivec[1]```的值已经换成另一个了)
- 在library 有both mmber and nonmember version of ```swap```，好习惯是使用nonmember version of ```swap```

| Syntax | Description | 
| --- | :--- | 
| ```c1 = c2``` | Replace element in ```c1``` with copies of elements in ```c2```, ```c1``` 与```c2```类型必须一样 |
| ```c = {a,b,c}``` | Replace elements in ```c1``` with copies of elements in initializer list  |
| ```swap(c1,c2)```<br/> ``` c1.swap(c2)``` | <span style="background-color:#FFFF00">Swap 会比copy elements 快的多</span> | 
| ```seq.assgin(b,e)``` | Replaces elements in seq with those range denoted by iterators ```b``` and ```e``` |
| ```seq.assign(il)``` | Replaces elements in seq with those in **initializer list** ```il``` |
| ```seq.assign(n,t)``` | Replaces elements in seq with n elements with value t |



Syntax common to all sequential container

| Syntax | Description | 
| --- | :--- | 
| ```difference_type``` | signed integral type big enough to thold the distance between two iterators |
| ```C c(b ,e)``` | copy elements from range denoted by iterators b and e (<span style="color:red">not valid for array</span>) |
| ```c.max_size()``` | C 可保存最大的数目 | 



**Iterators**
- 对于一个```reverse_iterator``` 进行 ```++``` operation, 得到上一个element
- <span style="color:red">对一个const object 调用iterator时, 普通的iterator 会convert to ```const_iterator```</span>
- <span style="background-color:#FFFF00">除了```array```以外, every container type defines a default constructor.</span>, 且都可以接受argument that specify size and initial values
- create a container as copy another container, 两个container类型必须匹配 ```C c(a)```. 如果pass iterators```C c(begin, end)```,两个containers 类型不用相同 (只要可以convert elements to the initialized type)

对一个const object, 普通iterator 会转换成 ```const_iterator```
```c++
list<string>::iterator it5 = a.begin();
auto it7 = a.begin(); // const_iterator only if a is const

```

<span style="background-color:#FFFF00">**Assign 可以用于different but compatible type**</span>

```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; // error: container types don't match

// ok: can convert from const char*to string 

names.assign(oldstyle.cbegin(), oldstyle.cend());


// equivalent to slist1.clear();

// followed by slist1.insert(slist1.begin(), 10, "Hiya!");

list<string> slist1(1); // one element, which is the empty string 

slist1.assign(10, "Hiya!"); // ten elements; each one is Hiya !

```

**swap** : with the exception of string, iterators, references, and pointers into the containers are not invalidated(仍然有效). 比如had ```iter``` denoted the string at ```sevc1[3]``` before swap, swap之后, ```iter```指的是```svec2[3]```
```c++
vector<string> svec1(10); // vector with ten elements 

vector<string> svec2(24); // vector with 24 elements 

swap(svec1, svec2);
```

**(3).比较container**

- **Relational Operators**:(>, >=, <=, <=, ==, !=), 必须保证right- and left-hand operands 必须是<span style="background-color:#FFFF00">**same kind of container**</span> and hold elements of <span style="background-color:#FFFF00">**same type**</span> (e.g. 不能拿```vector<int>``` compare to ```list<int>```), 比较two container 实际上是perform pariwise comparision of the elements, 与string比较方式类似
    - 两个container size 一样, element也一样，则相等, 否则不等
    - 两个container size 不一样, 但是较小的每个元素 和size 较大都一样, 则较大size 的大
     - If neither container is an initial subsequence of the other, 取决于第一个不一样的element 
- 只有当type 定义了relational operator 才可以进行比较. 比如```vector<Sales_data> storeA, storeB; if (storeA < storeB);``` 有可能是error,如果```Sales```没有定义 ```<``` operator


```c++
vector<int> v1 = { 1, 3, 5, 7, 9, 12 };
vector<int> v2 = { 1, 3, 9 };
vector<int> v3 = { 1, 3, 5, 7 };
vector<int> v4 = { 1, 3, 5, 7, 9, 12 };
v1 < v2 // true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]

v1 < v3 // false; all elements are equal, but v3 has fewer of them;

v1 == v4 // true; each element is equal and v1 and v4 have the same size() 

v1 == v2 // false; v2 has fewer elements than v1

```

#### (c). Sequential Container Operations

**(1).Add, Access, Delete**
- 像一个```vector``` or ```string``` 添加元素可能会引起entire object to be reallocated. <span style="background-color:#FFFF00">Reallocating an object requires allocating new memory and moving elements from the old space to the new.</span>
- ```array```不支持任何 add /delete operation 因为会改变size
- ```emplace(front, back)```construct elements in the container. The arguments must match a constructor for the element type. 
- The Access Members <span style="background-color:#FFFF00">Return **References**</span> (```back()```, ```front()```, ```c[n]```, ```c.at(n)```), e.g. ```auto & v = c.back(); v = 1024;```, 
    -  ```at```与下标的区别是如果越界, ```at```throw out_of_range error 如果invalid, （subscript operator 不会check index）



**Add Element**

| Syntax | Description | 
| --- | :--- | 
|  |```forward_list``` 有自己的```insert``` and ```emplace```  |
|  |```forward_list``` 不支持```push_back``` and ```emplace_back```  |
|  |```vector```, ```string``` 不支持```push_front``` and ```emplace_front```  |
| ```c.push_back(t)``` <br/>  ```c.emplace_back(arg)``` | 在尾部创建一个值为t或者由args 创建的元素 |
| ```c.push_front(t)``` <br/>  ```c.emplace_front(arg)``` | |
| ```c.insert(p,t)``` <br/>  ```c.emplace(p,args)``` | p is iterator, <span style="color:red">**在p之前插入**</span>，返回iterator 指向新添加元素 |
| ```c.insert(p,n,t)```  | <span style="color:red">**在p之前**</span>,, 插入n个t, 返回指向<span style="color:red">新添加的**第一个**元素的iterator,</span> 若n为0, 返回p |
| ```c.insert(p,b,e)```  | <span style="color:red">**在p之前**</span>,, 插入由iteartor b 和e返回内的元素, 返回指向<span style="color:red">新添加的**第一个**元素的iterator</span>, 若range 为空, 返回p |
| ```c.insert(p,il)```  | il是一个braced list of element values. 在p之前插入, 返回指向<span style="color:red">新添加的**第一个**元素的iterator</span>, 若列表为空, 返回p |

**Delete Element**

| Syntax | Description | 
| --- | :--- | 
|  | <span style="color:red">这些操作改变容器大小, 不适合```Array```</span> |
|  |```forward_list```有特殊的 ```erase```, 不支持```pop_back()```  |
|  |```vector```, ```string``` 不支持```pop_front```  |
| ```c.pop_back()``` <br/> ```c.pop_front()```  | return void |
| ```c.erase(p)``` | p is iterator, 删除p,<span style="color:red">返回**删除元素之后**的元素的 iterator</span>，如果p is end, undefined |
| ```c.erase(b,e)``` | b,e is iterator of range, 删除p,<span style="color:red">返回**删除元素**之后的元素的 iterator</span>，如果e is end, return end iterator; if ```b= e```,是安全的,删除一个空范围没有不良后果  |
| ```c.clear``` | return all element, returns void |




理解下面insert的返回值,每次返回都是begin, 指向新的元素
```c++
list<string> 1st;
auto iter = 1st.begin(); 
while (cin >> word)
    iter = 1st.insert(iter, word); // same as calling push_front

```

删除元素
```c++
list<int> lst = {0,1,2,3,4,5,6,7,8,9}; 
auto it = lst.begin();
while (it != lst.end())
    if (*it % 2) // if the element is odd 

        it = lst.erase(it); // erase this element

    else
        ++it;
```

**(3).Resize**

- 如果```resize``` 缩小容器, then iterators, references, and pointers to the deleted elements are invalidated; ```resize``` on a vector, string, deque potentially invalidates all iterators, pointers, and references.

| Syntax | Description | 
| --- | :--- | 
| ```c.resize(n)```  | if n < c.size(), 多的元素被丢弃, 如果必须添加新的元素, value initialized |
| ```c.resize(n,t)```  | Resize c to have n elements of t  |



**(4). How a vector Grows**

- **vector** 和 **string** 通常会分配比新的空间需求更大的内存空间，holds this storage in reserve and use it to allocate new elements as they are added. 因此而不会每次添加元素的是都reallocate 
- vector implementation strategy 是 doubling the current capacity each time it has to allocate new storage.(1->2->4->8->16...)
- ```capacity``` 告诉我们how many elements the container can hold before it must allocate more space. ```size``` is the number of a elements the container already holds 
- ```reserve``` 允许我们通知container how many elements it should prepare to hold.  ```reserve``` 不改变容器中元素的数量，<span style="background-color:#FFFF00">仅影响预先分配多大的内存空间</span> (how much memory the ```vector``` preallocates )
  - 如果request space > current capacity, ```reserve``` allocates at least as much as requested amount
  - 如果request size 小于 或者 等于 existing capacity, ```reserve``` does nothing. 
  - <span style="background-color:#FFFF00">```reserve``` never reduce the amount of space that container uses.</span>. 如果想减少memory, 可以call ```shrink_to_fit``` Calling ```shrink_to_fit``` is only a request; there is no guarantee that the library will return the memory.比如当size == capacity
  - 对于 deque, vector, or srtring; <span style="color:red">```resize``` 只改变容器中元素数目, 而不改变its capacity</span>


| Syntax | Description | 
| --- | :--- | 
| | ```shrink_to_fit``` valid only for vector, string, deque |
| | ```capcity()``` and ```reserve``` valid only for vector, string |
| ```c.shrink_to_fit(n)```  | Request to reduce ```capacity()``` to equal to ```size()```|
| ```c.capacity(n,t)```  | 不重新分配的话，c可以保存多少元素  |
| ```c.reserve(n)``` | Allocate space for at least n elements | 

用光预留空间
```c++
vector<int> ivec;
while (ivec.size() != ivec.capacity())
    ivec.push_back(0);
```

#### (d). Invalidate Iterators

- Invalidate iterator, pointer, or reference is serious <span style="color:red">run-time error</span>
- After Options that add elements: (Iterators, pointers, and references aka IPR)
  - IPR to vector or strings are <span style="color:red">invalid 如果 container **reallocated** </span>. 如果没有reallocate, 插入元素之前的IPR有效, 插入元素之后的IPR 无效
  - 对于 **deque**, add elements in the middle, IPR都invalid; <span style="background-color:#FFFF00">在 front or back, Iterators are invalidated, but references and pointers to existing elements not affected</span>
  - Adding (insert) elements to ```vector```, ```string```, ```deque``` 会invalidates all existing IPR
  - 对于 **list**, **forward_list** IPR都 都有效
- After we remove element
  -  **list**, **forward_list** IPR 都 remain valid 
  -  对于 **deque**, remove elements  in the middle IPR都invalid; <span style="background-color:#FFFF00">如果删除是back or front, begin/off-the-end itertor(end) is invaldiated, front/back的reference, pointer有效, 其他middle的IPR 都有效 （unaffected) </span>
  -  IPR to **vector** or **string** remain <span style="background-color:#FFFF00">valid对于**删除元素之前**</span>的, 注意: 当我们删除元素时, off-the-end iterator is always invalidated when we remove elements
- Avoid Storing the Iterator Returned from end 因为add / remove elements 总会把```vector``` or ```string``` 的```end``` iterator invalid



```c++
// silly loop to remove even-valued elements and insert a duplicate of odd-valued elements

vector<int> vi = {0,1,2,3,4,5,6,7,8,9};
auto iter = vi.begin(); // call begin, not cbegin because we're changing vi

while (iter != vi.end()) { 
    if(*itera%2)
        iter = vi.insert(iter, *iter); // duplicate the current element

        iter += 2; // advance past this element and the one inserted before it

    } else
        iter = vi.erase(iter); // remove even elements

        // don't advance the iterator; iter denotes the element after the one we erased

}
```

**Avoid Storing the Iterator Returned from end**: 不要特地的保存```end```, 下面的代码行为是未定义的, 会导致代码无限循环
```c++
// disaster: the behavior of this loop is undefined 

auto begin = v.begin(),
    end = v.end(); // bad idea, saving the value of the end iterator 

while (begin != end) {
    // insert the new value and reassign begin, which otherwise would be invalid 

    ++begin; // 想在此元素后插入元素

    begin = v.insert(begin, 42); // insert the new value 
    
    ++begin; // advance begin past the element we just added

}


//正确做法

while (begin != v.end()) {
    ++begin; // advance begin because we want to insert after this element 
    
    begin = v.insert(begin, 42); // insert the new value
    
     ++begin; // advance begin past the element we just added

}

```


#### (e).Forward_list Operations

![](/img/post/C++/forward_list.png)

-  ``forward_list```
    - 没有```back```,因为不支持```reverse_iterator```, 
    -  也不能```--```递减```forward_list```的iterator, 但可以call ```forward_list```的```end()```
    - 不支持```push_back``` 
    - 有自己的```insert``` and ```emplace```

因为```forward_list``` 是single linked list, 如果add/remove element 需要访问前一个元素(prepocessor),但是forward_list是单向,不能访问前一个元素, 所以定义insert emplace, erase 都是after, e.g. 我们想删除```elem3``` 需要call ```erase_after``` on iterator ```elem2```. To support 这种操作, ```forward_list``` 也定义了一个```before_begin``` returns off-the-begining (首前) iterator

| Syntax | Description | 
| --- | :--- | 
| ```c.before_begin()``` <br/> ```c.cbefore_begin()```  | 不存在的元素在列表首前, <span style="color:red">不能用dereferenced</span> |
| ```c.insert_after(p,t)``` <br/> ```c.insert_after(p,n,t)```  <br/> ```c.insert_after(p,b,e)```  <br/> ```c.insert_after(p,il)```  | p is iterator, t is object, n is count, b 和 e是iterator, il is braced list. <span style="color:red">返回**last insert** element</span> 如果range is empty returns p, <span style="color:red">Undefined if p 是off-the-end iterator (end)</span>  |
| ```c.emplace_after(p, args)``` | 返回the iterator to new element, Undefined if p 是off-the-end iterator (end) |
| ```c.erase_after(p)``` <br/>  ```c.erase_after(b,e)``` | 删除p后面的一个elements or 删除(b,e)之间的元素 (不包括b,e). <span style="color:red">返回an iterator to the element **after the one deleted**</span>, or 返回off-the-end iterator(如果不存在这样的element), Undefined if p 是off-the-end iterator (end) |

当删除elements in ```forward_list``` 必须关注两个iterator, the one we checking and the one to that element's predecessor.

```c++
forward_list<int> flst = {0,1,2,3,4,5,6,7,8,9};
auto prev = flst.before_begin(); // denotes element "off the start" of flst

auto curr = flst.begin();
while (curr != flst.end()) { // while there are still elements to process

    if (*curr % 2)
        curr = flst.erase_after(prev); // erase it and move curr

    else {
        prev = curr;
        ++curr;
    }
}
```




#### (f).String Operations

**(1). 其他构造string 的方法**

| Syntax | Description | 
| --- | :--- | 
|  | n, len2, pos2 are all unsigned values |
| ```string s(cp, n)```  | s is a copy of the first n character in <span style="color:red">**array**</span> which cp points. Array 必须有至少n个char|
| ```string s(s2, pos2)```  | s is a copy of characters in the <span style="color:red">**string**</span> s2 starting from the index ```pos2```. Undefined if ```pos2>s2.size()``` |
| ```string s(s2, pos2, len2)``` | s is a copy of characters in <span style="color:red">**string**</span> s2 \[pos2, pos2+len2 \), 不管len2多大， 最多copy ```s2.size() - pos2```个chars| 


- 当create a string from a ```const char*```, <span style="color:red">array 必须是 **null terminated**.</span>, copy 遇到null 停止. or pass a count , array 可以不用以null 结尾
    - <span style="color:red">但是如果不pass count and no null terminated, 或者given count 大于size of array, operation is undefined</span>
- 当pass的起始值pos2 大于size, 会throw ```out_of_range``` exception. 
- library copies up to the size of string or null 结尾的char array

```c++
const char *cp = "Hello World!!!"; // null-terminated array

char noNull[] = {'H', 'i'}; // not null terminated

string s1(cp); // copy up to the null in cp; s1 == "Hello World!!!"

string s2(noNull,2); // copy two characters from no_null; s2 == "Hi" 

string s3(noNull); // undefined: noNull not null terminated

string s4(cp + 6, 5);// copy 5 characters starting at cp[6]; s4 == "World" 

string s5(s1, 6, 5); // copy 5 characters starting at s1[6]; s5 == "World" 

string s6(s1, 6); // copy from s1 [6] to end of s1; s6 == "World!!!" 

string s7(s1,6,20); // ok, copies only to end of s1; s7 == "World!!!" 

string s8(s1, 16); // throws an out_of_range exception

```

string operation 

| Syntax | Description | 
| --- | :--- | 
| ```s.substr(pos, n)``` | pos起始点, n 是从起始点copy 多少个, \[pos, pos+n\), 会throws an out_of_range exception 如果pos超过size |
|  |定义了member function  ```assign```, ```erase```, ```insert``` | 
| ```s.append(args)``` | | 
| ```s.assign(args)``` |  replace chararcters in s = args | 
| ```s.erase(pos,len)``` | 删除\[pos, pos+len\), 如果没有提供len, 表示 删除\[pos, end\), return a reference to s |
| ```s.insert(pos,args)``` | pos 可以是下标 or iterator, 在p之前插入args, 接受index的版本 返回reference to s; 接受iterator的返回an iterator 表示第一插入的character |
| ```s.replace(range,args)``` | 删除range 内的字符, 替换成args指定的字符, range 可以是一个下标或者一个长度, or a pair of iterators into s. returns a reference to s |

上表的arg 可以是如下的形式
| Syntax | Description | 
| --- | :--- | 
| ```str``` | string str |
| ```str, pos, len``` | Up to len characters from ```str``` starting at ```pos``` |
| ```cp, len``` | Up to len characters from the <span style="color:red">**character array**</span> pointed by ```cp``` |
| ```cp``` | Null-terminated array pointed to by pointer cp |
| ```n,c``` | n copies of <span style="color:red">**char**</span> ```c``` | 
| ```b,e``` | Characters in range formed by iterators ```b``` and ```e``` | 
| *initializer list* | Comma-separated list of characters enclosed in braces | 

**(2). String Search Operations**

- 有6中search的functions, 每个function 提供4个overloaded functins. 每一个search 返回 ```string::size_type``` value that is the index of where match occurred 如果没有match, function 返回一个 ```static``` member named ```string::npos```.  Library defines ```npos``` as a ```const string::size_type``` 初始值 -1. 因为```npos```是unsinged type.  意味着```npos```等于任何```string```最大可能的值得大小

![](/img/post/C++/string_search.png)

```c++
string river("Mississippi");
auto first_pos = river.find("is"); // returns 1 

auto last_pos = river.rfind("is"); // returns 4

```

**(3). Compare Functions**

```compare``` function 类似于 C library的 ```strcmp``` function. Like ```strcmp, s.compare``` 返回0(等于), positive(大于) or negative(小于) value 

| Syntax | Description | 
| --- | :--- | 
| ```s2``` | Compare s to s2 |
| ```pos1, n1, s2``` | 将s中 \[pos1, pos1 + n1) compare to s2 | 
| ```pos1, n1, s2, pos2, n2``` | 将s中 \[pos1, pos1 + n1 ) compare to s2 的\[pos2, pos2 + n2 )   | 
| ```cp``` | compares s to null-terminated array pointed to by cp | 
| ```pos1, n1, cp``` | 将s中 \[pos1, pos1 + n1) compare to cp | 
| ```pos1, n1, cp, n2``` | 将s中 \[pos1, pos1 + n1) compare to n2 characters starting from pointer cp | 

**(4).Numeric Conversions**

- 如果string 不能转换为一个数值, 转换 functions 会 throw an ```invalid_argument``` exception. 如果转换得到数值无法用任何类型来表示, throw ```out_of_range```

| Syntax | Description | 
| --- | :--- | 
| ```stoi(s, p, b)``` <br/>  ```stol(s, p, b)``` <br/>  ```stoul(s, p, b)``` <br/>  ```stoll(s, p, b)``` <br/>  ```stoull(s, p, b)```  | b表示numeric base for the conversion(几进制), p is a pointer to a ```size_t``` in which to put index of first non-numeric character(非数值的) in s` |
| ```stof(s,p)``` <br/> ```stod(s,p)``` <br/> ```stold(s,p)``` | p跟上面的作用一样 | 


#### (g). Container Adaptors
- 除了 sequential containers, 还定义了sequential container adaptors: ```stack```, ```queue```, and ```priority_queue```. An adaptor 是 general concept. 
- container adaptor <span style="color:red">**takes an existing container type**</span> and makes it act like a <span style="color:red">**different type**</span>.
- Each adaptor defines two constructors: the default constructor that creates an empty object, and a constructor that takes a container and initializes the adaptor by copying the given container. 
- 默认情况下, ```stack```and ```queue``` are implemented in terms of ```deque```, 而```priority_queue```是在```vector```上实现的
    - e.g. 假定```deq```是一个```deque<int>```, ```stack<int>stk(deq);``` 从deq拷贝元素到stk,
    - e.g. override default container type by naming a sequential container as a second type argument. ```stack<string, vector<string>>str(svec)```
- <span style="background-color:#FFFF00">All adpator 需要the ability to add / remove elements. 因为they cannot be built on ```array```. 同样的, 我们也不能用```forward_list```, 因为adaptor需要具有add, remove, access the last element (back) ability. </span>
- ```stack```仅需要有```back```, ```push_back```, ```pop_back```,所以用于除了```array``` 和 ```forward_list```以外所有容器 (list. deque,vector,string)
- ```queue```需要有```back```,```push_back```, ```front```, ```push_front```的能力,所以只能建立在```list``` or ```deque```上而不能在```vector```上. 
- ```priority_queue``` 需要有random access in addition to ```front```, ```pusk_back```, ```pop_back```, 所以只能用于```vector``` or ```deque```, 不能用于```list```
- 每一个container adpator defines 自己的操作类型 in terms of 底层容器的操作类型. 只能使用adaptor自己的操作类型,不能用underlying container type的操作类型. 
    - ```intStack.push(ix);``` calls ```push_back``` on the ```deque``` on which ```intStack``` is based,尽管```stack```是基于```deque```实现的, 但我们不能使用```deque```操作, 不能call ```push_back```, 只能call ```push```

***
<br/><br/><br/>






















## 10. Generic Algorithms


#### (a). Overview

Kep Concept: <span style="background-color:#FFFF00">Algorithms Never Execute Container Operations</span>. They operate solely in terms of iterators and iterator operations. 有个重要的implication: <span style="color:red">Algorithm never change the size of the underlying container</span>, Algorithm 可能改变container中的值, 可能会move elements within the container。 但是never add or remove elements directly. A special class of iterator is **inserter** 会插入elements, 但是算法自身itself never does so

#### (b), First Look at the Algorithm

- **Read-Only Algorithms**： 
    - never write to element
    - it is best to use ```cbegin()``` and ```cend()``` with algorithms that read, but do not write
    - Algorithm that take a <span style="background-color:#FFFF00">single iterator</span> denoting a <span style="background-color:#FFFF00">second squence</span>, <span style="background-color:#FFFF00">都假定 second sequence is at least as large at the first(至少一样长)</span> 
        - 比如```equal```中的第二个sequence 没有第一个长, 程序会报错
    - 一些算法从两个序列(containers)中读取元素, <span style="background-color:#FFFF00">不一定要求两个container 是一样类型, 也不要求element types are indentical</span>. e.g. 见表中的```equal```
- **Algorithms That Write Container Elements**
    - Some algorithms assign new values to the elements in sequence, 必须确保序列原大小 必须大于 我们要求写入的 元素数目。<span style="background-color:#FFFF00">算法不执行container operations, no way to change the size of a container</span> 
    - Algorithms Do Not Check Write Operations: Algorithms that write to a destination iterator <span style="color:red">assume the destination is large enough to hold the number of elements</span> being written. 会假定container 有足够的size (容量)来操作 比如```fill_n```, 如果空间不够, undefined behavior
    - 还有一些算法 so called "copying" version, 这些算法compute new element values, but instead of putting them back into input sequnce, 算法创建一个新序列保存这些结果, 例如```replace_copy```
- 一种确保algorithm has enough elements to hold is to use **insert iterator** (right-hand value is added to container)
    - **back_inserter**: takes a <span style="background-color:#FFFF00">reference to a container</span> and <span style="background-color:#FFFF00">returns an insert iterator bound to that container</span>. 当assign through that iterator, assignment calls ```push_back``` to add an element with the given value to the container

Read-only Algorithm

| Syntax | Description | 
| --- | :--- | 
| ```accumulate``` | accumulate第三个类型决定了使用哪个加法运算符和返回类型(注意：不可以传入empty string as string literal) <br/> ```string sum = accumulate(v.cbegin(), v.cend(), string(""));```  |
| ```equal``` | 判断两个sequences hold the same value, compare each elements, return true 如果一样, 否则false; equal 不一定需要两个cointainer 一样 类型也一样, 可以是<span style="color:red">不同的container</span>, 不同的类型, 只需可以用```==```来比较来自两个序列的元素 |

```c++
//accumulate

int sum = accumulate(vec.cbegin(), vec.cend(), 0);
string sum = accumulate(v.cbegin(), v.cend(), string(""))
// error: no + on const char*

string sum = accumulate(v.cbegin(), v.cend(), "");

//equal

// roster2 should have at least as many elements as roster1 

equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());

list<int> a = { 1,2,3,4,5 };
array<int,5> b = { 1,2,3,4,5 }; 
cout << equal(a.begin(), a.end(), b.begin());//print 1

``` 

<span style="background-color:#FFFF00"> accumulate 可以用于 self-defined class, 只要class **overload addition operator**, pass 到 accumulate 需要pass as **functor(rvalue) with constructor**</span>

```c++
class myobj {
public:
     int a = 0;
     myobj(string s) {}
     myobj& operator+(const myobj& l) {
          this->a += l.a;
	  return (*this);
     }
};

myobj a("1"); myobj b("2");
a.a = 1; b.a = 2;
vector<myobj> vec = { a,b };

myobj c = accumulate(vec.begin(), vec.end(), myobj("whatever string"));
cout << "c value " << c.a << endl; //print 3

```


Algorithm that write element

| Syntax | Description | 
| --- | :--- | 
| ```fill``` | 将给定的值赋予序列中每个元素, 有点像```resize```, ```assign```,但不会像它们一样改变size |
| ```fill_n``` | ```fill_n(dest, n, val)``` takes a iterator, a count and a value. 从iterator声明的位置开始, fill n 个 元素 value.  <span style="color:red">assumes that dest refers to an element and that there are at least n elements in the sequence starting from dest.</span> |
| ```copy``` | 接受三个iterator, 前两个表示input range, 第三个表示beginning of the destination sequence: copy from input range to destinaion. 很重要的是: destination passed to ```copy``` 至少跟input range 一样长, The value returned by copy is the (incremented) value of its destination iterator.(就是完成copy后的下一点) |
| ```replace``` |  接受4个参数， 前两个是iterator, 表示输入序列, 后两个一个是要搜索的值, 一个是replace的值  |
| ```replace_copy``` | 跟```replace```想法一样,只不过不更改input sequence, 接受5个参数， 前两个是iterator, 表示输入序列, 第三个表示write的destination, 后两个一个是要搜索的值, 一个是replace的值  |


```c++
//fill

fill(vec.begin(), vec.begin() + vec.size()/2, 10);

//fill_n: Do Not Check Write Operations

vector<int> vec; // empty vector

// disaster: attempts to write to ten (nonexistent) elements in vec 

fill_n(vec.begin(), 10, 0);//The result is undefined.


//copy

int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1)/sizeof(*a1)]; // a2 has the same size as a1

// ret points just past the last element copied into a2

auto ret = copy(begin(a1), end(a1), a2); // copy a1 into a2

// ret will point just past the last element copied into a2.


//replace 

replace(ilst.begin(), ilst.end(), 0, 42);//把所有的0 替换成42

// use back_inserter to grow destination as needed 

replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), 0, 42);

//把范围内所有的0替换成42, 并push_back到ivec

``` 



**Algorithms That Reorder Container Elements**


| Syntax | Description | 
| --- | :--- | 
| ```sort``` |  |
| ```stable_sort``` | 与```sort``` 不同的是, ```stable_sort```会维持相等元素原有的序列 | 
| ```unique``` | 消除相邻的重复(如果不相邻一样的，不会删除), <span style="background-color:#FFFF00">因为算法不对容器进行操作, 不能直接添加/删除元素</span>, 返回an iterator that denotes the end of the range of the unique value |

```c++
vector<int>  = {10,20,20,20,30,30,20,20,10};   // 10 20 20 20 30 30 20 20 10

  // using default comparison:

std::vector<int>::iterator end_unique = std::unique (myvector.begin(), myvector.end());   

// 10 20 30 20 10 ?  ?  ?  ?

                  ^
                  |
                end_unique                              
```

#### (c), Lambda / Bind

- A **predicate** is an expression that can be called and that returns a value that can be used <span style="color:red">as a condition</span>. Has two version:
    - **unary predicate**: they have a single parameter
    - **binary predicates**: they have two parameters, 比如```sort```
- 算法call the given predicate on the elements in the input range. 因此, must be <span style="color:red">possible to convert</span> the element type to the parameter type of the predicate



**(1). Lambdas**: 
- 可以pass any kind of **callable object** to an algorithm. A object or expression is callable if we can apply the call operator to it. ```e(args)```. 
- **lambda expression** 可以想成是inline function, ```[capture list] (parameter list) -> return type { function body }```
    - ```capture list``` is 局部变量(所在函数内部,lambda外部)列表 defined in the enclosing function(通常为空). <span style="color:red">A lambda may use a variable local to its surrounding function only if the lambda captures that variable in its capture list.</span>
        - The capture list is used for <span style="color:red">**local nonstatic variables**</span> only; lambdas can use local statics and variables declared outside the function directly(比如```cout```)
    - return type:
        - 如果specify return type的话, unlike ordinary functions, a lambda must use a trailing return (尾置返回) to specify its return type.
        - <span style="background-color:#FFFF00">如果忽略返回类型, lambda 根据函数体的代码推断出返回类型</span>. 
    -  can <span style="color:red">omit either or both of the parameter list and return type</span> but must always include the capture list and function body ```auto f = [] { return 42; };``` 定义了```f``` callable object that takes no arguments and returns 42.```cout << f() << endl; // prints 42```
    - parameter:
        - lambda中忽略parameter list 等于指定一个empty parameter list.
        - lambda 不能有<span style="color:red">默认参数</span>. 因此call lambda 的参数永远与lambda 的参数一样多
    - When we define a lambda, <span style="color:red">the compiler generates a new (unnamed) class type that corresponds to that lambda and **an unnamed object** of that type</span>. 使用```auto``` 定义一个lambda 变量的初始值时, define an **object** of the type generated from that lambda.
        - 类似普通data members of any class, <span style="color:red">the data members of a lambda are initialized when a lambda object is created</span>.
    - can also <span style="color:red">return **a lambda** from a function</span>.  The function might directly return a **callable object** or the function might return **an object of a class that has a callable object as a data member**(functor). 如果Function returns a lambda, 不能return a reference to a local varaibles (<span style="background-color:#FFFF00">不能有reference captures</span>)

Capture: 
- **Capture by value** ```auto f = [v1] { return v1; };```. 前提是变量必须是可以copy的，Unlike parameters, 被捕获的值是在lambda <span style="color:red">**创建时copy**</span> 而不是在被调用(call)时copy,因此随后的对其修改不会影响到lambda 内对应的值
    -  If we want change the value of a captured variable, we must follow the parameter list with the keyword ```mutable```. 
        - lambda that are mutable<span style="color:red">不能省略parameter list</span> ```auto f = [v1] () mutable { return ++v1; };```, 不加```mutable```不能更改
        
- **Capture by Reference**: ```auto f2 = [&v1] { return v1; };```when use the variable inside the lambda body, 使用的是引用所绑定的对象, 比如返回```v1```, 返回的是```v1``` 指向对象的值
    - 必须确保 the referenced object exists at the time the lambda is executed(<span style="background-color:#FFFF00">被引用对象在lambda 执行时候是存在的)</span>.<span style="color:red">因为捕获的都是局部变量</span>. 这些变量在函数结束后就不存在了,如果lambda 可能在函数结束后执行, 捕获引用指向的局部变量已经消失
    - 捕获引用是有必要的, 比如函数接受一个```ostream```的引用,
    - 一个variable captured by reference 是否可以改变 depends only on whether that reference refers to a ```const``` or nonconst type (如果variable 指向const object不能修改, 如果不是const 可以修改);
    	- ```const int a = 0; auto j = [&a] {cout << a << endl; };``` 不能在lambda 中 修改 a 的值
- **Implicit Captures**: 可以让compiler根据lambda中代码infer which variables we use from the code. To direct the compiler to infer the capture list, we use an ```&```(capture by reference) or ```=```(capture by value) in the capture list.
- **Mix implicit and explicit Capture**: 
    - 必须确保the first item in capture list is ```&```or ```=```
    - <span style="background-color:#FFFF00">Explicit capture variables must use the alternate form(显示捕获和隐式捕获必须是不同的方式)</span>: 如果隐式捕获是引用(```&```), 则显示捕获必须是值, 不能在显示名字前加上```&```; 如果隐式捕获是值方式, 则显示捕获必须用引用方式 (加上```&```)

![](/img/post/C++/lambda_capture.png)

Implicit Capture
```c++
// sz implicitly captured by value

wc = find_if(words.begin(), words.end(),    
    [=](const string &s) { return s.size() >= sz; });
```

we can mix implicit and explicit captures:

```c++
void biggies(vector<string> &words, vector<string>::size_type sz,
        ostream &os = cout, char c = ' ')
{
// os implicitly captured by reference; c explicitly captured by value

for_each(words.begin(), words.end(),
        [&, c](const string &s) { os << s << c; });

// os explicitly captured by reference; c implicitly captured by value 

for_each(words.begin(), words.end(),
        [=, &os](const string &s) { os << s << c; });
}
```

**Mutable Lambdas**: 也显示了capture by value时, 如果 值lambda 建立后, 在call function 前改变了, 不影响lambda function 内值 
```c++
void fcn3()
{
    size_t v1 = 42; // local variable

    // f can change the value of the variables it captures

    auto f = [v1] () mutable { return ++v1; }; 
    v1 = 0;
    auto j =f();// j is 43

}

void fnc4()
{
    size_t v1 = 42; // local variable

    // v1 is a reference to a non const variable

    // we can change that variable through the reference inside f2

    auto f2 = [&v1] { return ++v1; }; 
    v1 = 0;
    autoj=f2();// j is 1

}
```



Capture Advise: 需要keep your lambda captures simple
- A lambda capture stores information between the time the lambda is created (i.e., when the code that defines the lambda is executed) and the time (or times) the lambda itself is executed (捕获保存信息从定义到执行).
- Capture ordinary variable 比如```int```, ```string```, or nonpointer type - by value is usually straightforward. 这种情况下, 只需关注在捕获时有我们需要的值就可以了
- 如果捕获pointer, iterator, or capture by reference, 必须ensure pointer, iterator, or reference  <span style="background-color:#FFFF00">still exists whenever the lambda executes</span>. 还可能是, 在指针或引用被捕获时候, 绑定对象的值是我们期望的, 但在lambda执行时, 该对象的值可能完全不同了
- if possible, avoid capturing pointers or references.


```c++
void biggies(vector<string> &words, vector<string>::size_type sz,
ostream &os = cout, char c = ' ')
{
// statement to print count revised to print to os 

for_each(words.begin(), words.end(),
    [&os, c](const string &s) { os << s << c; });
}
```


**Specifying the Lambda Return Type**

- 默认情况下, 一个lambda body contains any statement 除了return, that lambda is assumed to return void. lambdas inferred to return void may not return a value.
- When we need to define a return type for a lambda, we must use a **trailing return type**

```c++
//error: cannot deduce the return type from the lambda(新版C++ 是可以的)

transform(vi.begin(), vi.end(), vi.begin(),
    [](int i) { if (i < 0) return -i; else return i; 
});

transform(vi.begin(), vi.end(), vi.begin(), [](int i) -> int
    { if (i < 0) return -i; else return i; });
```



**(2).Binding Arguments**:

- Lambda expression are most useful for 只在一两个地方使用的简单操作, 如果在很多地方使用相同操作, 通常定义一个函数
- 比如```find_if```函数，如果不用捕获, 无法让只接受一个argument的predicate 接受另一个```size_type```的variable, 可以用```bind```(in ```functional``` heade)来解决这个问题,It takes a **callable object** and generates a new **callable** that “adapts” the parameter list of the original object.
- ```auto newCallable = bind(callable, arg_list);``` : the general form of a call to ```bind```
    -  ```newCallable``` is itself a callable object
    - ```arg_list``` is 逗号分隔的参数列表,对应给```callable```的parameter
        - 也许include names of the form ```_n```, n是整数, 这些参数是"placehorders"(in ```functional``` header),表示```newCallable``` parameters. They stand "in place of" the arguments that will be passed to ```newCallable```: ```_1``` 为```newCallable```第一个参数,```_2``` 为```newCallable```第二个参数
        - The _n names are defined in a namespace named ```placeholders```(in ``std```), using declarations, for ```_1``` is ```using std::placeholders::_1;```, 表示我们要使用命名```_1```
        - Must provide a separate using declaration for each placeholder name that we use. 这么写容易出错<span style="color:red">**error-prone**</span>, 我们可以用```using namespace std::placeholders;```表示all the names from namespace accessible to our program
    - 当调用```newCallable```, ```newCallable```会调用```callable```, 并传递给它```arg_list```中的参数
- can use bind to bind or rearrange the parameters in the given callable
- **Binding Reference Parameters** 有时we have arguments that we want ot bind by reference or we want to bind an argument that has a type that we cannot copy, 用```ref```:
    - ```ref``` returns an object that contains the given reference and that is itself copyable.标准库中还有另一个```cref```: generates a class that holds a reference to const, 生成一个保存```const```的引用类
        - Modern C++ programs should use bind. 旧版C++提供了```bind1st``` 和 ```bind2nd```有更多限制,已经被deprecated 在新版中 

下面的function bind has only one **placeholder**, which means that ```check6``` takes a single argument。The placeholder appears first in arg_list 对应 ```check_size```的第一个参数 (```const string&```),表示调用```check6```必须一个string 参数
```c++
bool check_size(const string &s, string::size_type sz)
{ return s.size() >= sz; }

// check6 is a callable object(可调用对象) that takes one argument of type string

 // and calls check_size on its given string and the value 6
 
auto check6 = bind(check_size, _1, 6);

string s = "hello";
bool b1 = check6(s); // check6(s) calls check_size(s, 6)


//使用bind可以改变原来的lambda的find_if

auto wc = find_if(words.begin(), words.end(), [sz](const string &a) 

auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));
```

can use bind to bind or rearrange the parameters in the given callable. 比如assume ```f``` is a callable object that has 5个参数, ```g```is the callable that takes 2 arguments, 传递给```g```的参数按顺序绑定到placeholder, 第一个参数绑定到```_1```, 第二个参数绑定到```_2```, 第一个参数将被传递给```f```的最后一个参数, 第二个参数将被传递给```f```的第三个参数
```c++
// g is a callable object that takes two arguments 

auto g = bind(f, a, b, _2, c, _1);

//calling g(X, Y) calls

f(a, b, Y, c, X)
```

**Using to bind to Reorder Parameters**: use bind to invert the meaning of isShorter by writing
```c++
// sort on word length, shortest to longest

sort(words.begin(), words.end(), isShorter);
// sort on word length, longest to shortest

sort(words.begin(), words.end(), bind(isShorter, _2, _1));
```

**Binding Reference Parameters**: 比如```ostream``` , 因为IO 对象不能拷贝, 

```c++
// os is a local variable referring to an output stream 

// c is a local variable of type char 

for_each(words.begin(), words.end(),
    [&os, c](const string &s) { os << s << c; });

ostream &print(ostream &os, const string &s, char c)
{
    return os << s << c;
}

// error: cannot copy os

for_each(words.begin(), words.end(), bind(print, os, _1, ' '));

for_each(words.begin(), words.end(), bind(print, ref(os), _1, ' '));
```

#### (d). Iterators

1. **Insert iterator**: 这些迭代器被绑定到一个容器上, 可以像容器插入元素
2. **Stream iterator**: 这些迭代器被绑定到输入或者输出流上, 可以用来iterate through the associated IO stream
3. **Reverse iterator**: 这些迭代器向后(backward)而不是向前移动. Container 除了 ```forward_list``` 都有reverse iterators
4. **Move iterator**: 不是拷贝其中的元素而是移动它们

**(1). Insert Iterator**

<span style="color:red">An inserter is an iterator adaptor</span> that takes a container and yields an iterator that adds elements to the specified container. 当赋值给insert iteartor, the iterator calls a container operation to add an element at a specified positon in the given container.


| Syntax | Description | 
| --- | :--- | 
| ```it=t``` | 在```it```指定的当前位置插入```t```, 假定```c```是```it```绑定的容器, 依赖于插入迭代器的不同种类, 此赋值会分别调用 ```c.push_back(t)```, ```c.push_front(t)```, or ```c.insert(t,p)```, 其中```p```为传递给```inserter```的iterator position |
| ```*it, ++it, it++``` | 此操作虽然存在, 但不会对```it```做任何事情. 每个操作都返回```it``` | 

有三种````Insert inserter````: we can use **front_inserter** only if container has ```push_front```. 同样 use ```back_inserter``` only if it has ```push_back```
- **back_inserter**: creates an iterator use ```push_back```
- **front_inserter**: creates an iterator use ```push_front```
- **inserter**: creates an iterator uses ```insert```. 此函数接受第二个参数, 这个参数必须是指向给定容器的iterator, 元素将被插入到给定iterator的前面连续插入elements, ```inserter(c,iter)```, 会插入到```iter```所指向元素的前面, ```c``` 是container
  - 如果```it``` is an iterator generated by ```inserter```, then an assignment as ```*it = val;``` 等于 ```it = c.insert(it,val); ++it;```

```c++
list<int> lst = {1,2,3,4};
list<int> lst2, lst3; // empty lists


 // after copy completes, 1st2 contains 4 3 2 1

copy(lst.cbegin(), lst.cend(), front_inserter(lst2));
// after copy completes, 1st3 contains 1 2 3 4

copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));

//or 

insert_iterator<list<int>>insert_it(lst3, lst3.begin());
copy(lst.begin(), lst.end(), insert_it);
```

```c++
list<int> l;
auto it = inserter(l, l.begin());
it = 1; it = 2;

copy(l.begin(), l.end(), ostream_iterator<int>(cout, ","));//print 1, 2,
	
```

**back_inserter**; apply to ```fill_n```: 因为we passed an iterator returned by ```back_inserter```(back_iterator返回的迭代器), each assignment will call ```push_back``` on ```vec```
一点主意下面例子的```copy``` 用于 ```ostream_iterator``` 而for_each 不用于 ```ostream_iterator``` 因为```for_each```最后一个argument 是 ```fn```, 要pass to argument to ```_Func(*itr);```, 而```copy``` 最后一个argument 是 ```iterator```, ``` *result = *first;``` 

```c++
vector<int> vec; // empty vector

auto it = back_inserter(vec); // assigning through it adds elements to vec

it = 342; // vec now has one element with value 42, size = 1

*it = 42; // vec now has one element with value 42, size = 2

//因为*it = 会call push_back, 向后推, it iterator 不会前进，


//用到fill_n 

vector<int> vec; // empty vector

// ok: back_inserter creates an insert iterator that adds elements to vec 

fill_n(back_inserter(vec), 10, 0); // appends ten elements to vec

```

**back_insert** class, C++14, ```addressof``` C++14 新feature
```c++
template <class Container> class back_insert_iterator :
	public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  Container* container;
public:
   explicit back_insert_iterator (Container& x) : container(std::addressof(x)) {}
  back_insert_iterator<Container>& operator= (const typename Container::value_type& value)
    { container->push_back(value); return *this; }
  back_insert_iterator<Container>& operator= (typename Container::value_type&& value)
    { container->push_back(std::move(value)); return *this; }
  back_insert_iterator<Container>& operator* ()
    { return *this; }
  back_insert_iterator<Container>& operator++ ()
    { return *this; }
  back_insert_iterator<Container> operator++ (int)
    { return *this; }
};
```

**insert_iterator**: 

```c++
template <class Container>
  class insert_iterator :
    public iterator<output_iterator_tag,void,void,void,void>
{
protected:
  Container* container;
  typename Container::iterator iter;

public:
  typedef Container container_type;
  explicit insert_iterator (Container& x, typename Container::iterator i)
    : container(std::addressof(x)), iter(i) {}
  insert_iterator<Container>& operator= (const typename Container::value_type& value)
    { iter=container->insert(iter,value); ++iter; return *this; }
  insert_iterator<Container>& operator= (typename Container::value_type&& value)
    { iter=container->insert(iter,std::move(value)); ++iter; return *this; }
  insert_iterator<Container>& operator* ()
    { return *this; }
  insert_iterator<Container>& operator++ ()
    { return *this; }
  insert_iterator<Container> operator++ (int)
    { return *this; }
};
```



**(2). iostream Iterator**

- ```istream_iterator```: reads an input stream,  ```ostream_iterator```: writes an output stream
- with stream iterator, we can use the generic algorithms to read data from or write data to **stream objects**.
- need to specify type of objects that the iterator will read or write. like ```istream_iterator<int> int_it(cin);```
- ```istream_iterator``` use ```>>``` to read a stream. 
    - the type that an ```istream_iterator``` reads must have an input operator defined. (比如```int```, ```string``` 都有input operator defined)
    - 当我们create an ```istream_iterator```, we can bind it to a stream (绑定到流上).
    - 还可以使用默认initialize iterator constructor, which creates an iterator that we can use as the off-the-end value (可以当尾后使用的迭代器)
    -  An iterator bound to a stream is equal to the end iterator(用默认```iostream_iterator```constructor 生成的iterator) once its associated stream hits end-of-file or encounters an IO error.
    - ```istream_iterators``` Are Permitted to Use Lazy Evaluation: 当绑定流到 ```istream_iterator```, 不保证it will 立即 read the stream. The implementation is permitted to delay reading the stream until we use the iterator. 我们保证的是: 在一次dereference the iterator前, the stream will have been read. 
        - 对于大多程序, 何时读取没有差别, 但是如果我们创建一个```istream_iterator```， 没有读取就销毁了, 或者我们从两个不同的对象同步读取the same stream，那么何时读取就很重要了
- ```ostream_iterator```: 可以对任何具有输出运算符的(```<<```)的对象定义```ostream_iterator```,当创建```ostream_iterator```, 可以提供一个a character string as second argument, 在输出每个元素后都会打印这个字符串, 字符串必须是C-style character string (string literal or a pointer to a null terminated array)
    - 必须将```ostream_iterator``` 绑定到一个指定的流上
    - <span style="background-color:#FFFF00">There is no empty or off-the-end ostream_iterator</span>
- 实际上```*``` 和 ```++``` operator 对```ostream_iterator```没有任何影响


| Syntax | Description | 
| --- | :--- | 
| ```istream_iterator<T>in(is)``` | ```in```从输入流```is```读取类型为```T```的值 |
| ```istream_iterator<T>end``` | 读取类型为```T```的值的```istream_iterator``` iterator, 表示尾后位置 | 
|  ```in1 == in2 ```<br/>  ```in1 != in2```  |  ```in1``` 和 ```in2```必须读取相同类型. 如果他们都是尾后iterator, 或绑定到相同的input stream则他们相等 | 
| ```*in``` | 返回从流中读取的值 | 
| ```in->mem``` | 与```(*in).mem``` 含义相同 | 
|   ```++in ```<br/>  ```in++``` | Reads the **next value** from the input stream using the ```>>``` operator for the element type. 通常上prefix version returns a reference to the incremented iterator. The postfix version returns the old value |


| Syntax | Description | 
| --- | :--- | 
| ```ostream_iterator<T>out(os)``` | ```out```将类型为T的值写到输出流```os```中 |
| ```ostream_iterator<T>out(os, d)``` |  ```out```将类型为T的值写到输出流```os```中, 每个值后面都输出一个```d```, d points to a null-terminated character array |
|  ```out = val```  | 用```<<``` 运算符将val 写入到 out 绑定的 ostream 中,val的类型必须与 out 可写的类型 兼容 | 
|  ```*out```<br/>  ```++out``` <br/> ```out++``` |  这些运算符是存在的, 但不对```out```做任何事情, 每个运算符都返回```out``` |



下面第二个例子是从```cin``` 读取int值, 保存到```vec```中, 每个循环检查```in_iter```是否等于```eof```, ```eof```被定义为空的```istream_iterator``` which is used as the end iterator
```c++
istream_iterator<int> int_it(cin); // reads ints from cin end iterator value

istream_iterator<int> int_eof; // end iterator value

ifstream in("afile"); 
istream_iterator<string> str_it(in); //reads strings from "afile"


//从标准输入读取数据

istream_iterator<int> in_iter(cin); //read ints from cin 

istream_iterator<int> eof; //istream 尾后iterator

while(in_iter!=eof) // while there's valid input to read

// postfix increment reads the stream and returns the old value of the iterator 

// we dereference that iterator to get the previous value read from the stream 

    vec.push_back(*in_iter++);
```

可以将上面程序重写，construct ```vec``` from a pair of iterators that denote a range of elements. <span style="background-color:#FFFF00">This constructor reads ```cin``` until it hits end-of-file or encounters an input that is not an ```int```.</span> 
```c++
istream_iterator<int>in_iter(cin), eof; //read ints from cin 

vector<int> vec(in_iter, eof); //construct vec from an iterator range

```

**Using Stream Iterators with the Algorithms**

```c++
istream_iterator<int> in(cin), eof; 
cout << accumulate(in, eof, 0) << endl;
```

**ostream_iterator**: 下面程序将每个元素写到```cout```, 每个元素后面加一个空格. Each time we assign a value to ```out_iter```, the write is committed. 推荐下面第一种写法,That loop uses the iterator consistently with how we use other iterator types. 
```c++
ostream_iterator<int> out_iter(cout, " "); 
for (auto e : vec)
    *out_iter++ = e; // the assignment writes this element to 

cout cout << endl;

//方法二: 实际上可以忽略解引用 和 递增运算，和上面作用一样的

for(auto e: vec)
    out_iter = e;//赋值语句将元素写到out

cout<<endl;

//方法三:

copy(vec.begin(),vec.end(), out_iter);
cout << endl;
```

work with class 

```c++
istream_iterator<Sales_item> item_iter(cin), eof; 
ostream_iterator<Sales_item> out_iter(cout, "\n"); 
// store the first transaction in sum and read the next record Sales_item 

sum = *item_iter++;
while (item_iter != eof) {
    // if the current transaction (which is stored in item_iter) has the same ISBN 
    
    if (item_iter->isbn() == sum.isbn())
        sum += *item_iter++; // add it to sum and read the next transaction

    else {
        out_iter = sum; // write the current sum

        sum = *item_iter++; // read the next transaction 

    }
} 
out_iter = sum; //打印最后一组记录的和

```


**(3). Reverse Iterators**

- A **reverse iterator** is an iterator that traverses a container backward, from the last element toward the first.
- ```++it```: move the iterator to the previous element, ```--it``` moves the iterator to the next element.
- 除了```forward_list``` 所有container 都支持 reverse iterators
- obtain a **reverse iterator** by ```rbegin```, ```rend```, ```crbegin```, and ```crend```: to last element and one "past" the beginning of the container
- 下面例子只中```[line.crbegin(), rcomma）``` 和 ```[rcomma.base(), line.cend())``` 指向相同的元素范围, 所以```rcomma``` 和 ```rcomma.base()``` 必须生成相邻而不是相同的位置. ```crbegin()``` 和 ```cend()```也是如此
    - When we initialize or assign a reverse iterator from a plain iterator, the resulting iterator does not refer to the same element as the original.

找到从结尾到最后一个逗号之间的词, 但注意reverse_iterator会反向打印```line```的内容, 需要用```base``` 完成这一个转换
```c++
auto comma = find(line.cbegin(), line.cend(), ','); 
cout << string(line.cbegin(), comma) << endl;

auto rcomma = find(line.crbegin(), line.crend(), ',');
// WRONG: will generate the word in reverse order

cout << string(line.crbegin(), rcomma) << endl;

FIRST,MIDDLE,LAST
then this statement would print TSAL!

// ok: get a forward iterator and read to the end of line

cout << string(rcomma.base(), line.cend()) << endl;
```

可以看到```base``` 和不加base指向不同元素

![](/img/post/C++/iterator.png)

iterator 到 reverse_iterator, reverse_iterator 会像前推一位
```c++
vector<int> v = { 0, 10, 20, 25,30,60};
ostream_iterator<int>os(cout, ",");
using RevIt = reverse_iterator<vector<int>::iterator>;
{
	const auto it = v.begin() + 3;
	RevIt r_it(it);
	cout << " base ";  *os = *it; cout << endl;
	//print 25; 
	
} {
	RevIt r_end(v.begin());
	RevIt r_begin(v.end());
	for (auto i = r_begin; i != r_end; i++) {
		*os++ = *i;
	}
	//60,30,25,20,10,0, 
	
}
```
	


#### (e). Structure of Generic Algorithms

Iterator Categories, 有五种: Each algorithm specifies what kind of iterator must be supplied 作为 its iterator parameters.
1. **Input iterator**: Read, but not write; single pass, increment only
2. **Output iterator**: Write, but not read; single pass, increment only
3. **Forward iterator**: Read and write, multi-pass, increment only
4. **Birectional iterator**: Read and write, multi-pass, increment and decrement
5. **Random-access iteator**: Read and write, multi-pass, full iterator arithmetic

- The standard specifies the minimum category for each iterator parameter of the generic and numeric algorithms: 算法需要iterator 的最小类别
  - 比如```find``` 需要one pass, read-only traversal sequence, 最小需要 input iterator. 比如```replace_copy``` 前两个iterator最小是Forward iterator, 第三iterator至少是output iterator
  - 如果传递iterator of a lesser power is an error
  - Many compilers will not complain when we pass the wrong category of iterator to an algorithm.
  
**Input iterator** 必须支持
- 用于比较相等或者不等的运算符 ```==```, ```!=``` 
- Prefix and postfix increment (```++```)
- Dereference operator ```*```` to read element, dereference may appear only on the right-hand side of an assignment
- arrow operator ```->```, same as ```(*it).member``` dereference the iterator and fetch member from underlying object

**Input iterator**  用于顺序访问(sequentially).  ```*it++``` is 保证 valid, 但是递增它可能导致所有其他指向流的iterator 失效, 因此no guarantee that we  can save the state of input iterator and examine an element through that saved iterator. 只能用于single-pass algorithm, 例如```find```, ```accumulate```, ```istream_iterator``` are input iterators.

**Output iterator** 可以想成**Input iterator**的补集. Output iterator must provide 
- Prefix and postfix increment ```++```
- Dereference ```*``` 只能作为left-hand side of an assignment (Assigning to a dereferenced output iterator 就是 writes to the underlying element.)
 
copy 函数第三个iterator 就是output iterator, ostream iterator 也是 output iterator 

**Forward iterator**: 
- can read and write a given sequence
- move in only <span style="color:red">**one direction**</span> through the sequence.
- support all the operations of both input iterators and output iterators
- they can read or write the same element multiple times
  - 可以save state of a forward iterator 
- 因为algorithm use forward iterator may <span style="color:red"> make multiple passes through the sequence</span>.
- ```replace``` 要求 forward iterator, ```forward_list``` 也要求 forward iterator


**Bidirectional iterators**: 
- can read and write a sequence forward or backward
- supporting all the operations of a forward iterator
- support prefix and postfix decrement (```--```) operators
- ```reverse``` 要求 bidirectional iterators
- 除了```forward_list``` 标准库的container 都满足 bidirectional iterator


**Random-access iterators**: 
- provide <span style="background-color:#FFFF00">**constant-time access**</span> to any position in the sequence.
- support all the functionality of bidirectional iterators. 除此以外还支持
  - The relational operators (<, <=, >, and >=) to compare the relative positions of two iterators.
  - Addition and subtraction operators (+, +=, -, and -=) on an iterator and an integral value.
  - The subtraction operator (-) when applied to two iterators, which yields the distance between two iterators.
  - The subscript operator (```iter[n]```) as a synonym for ```* (iter + n)```.
- ```sort``` 要求Random-access iterators, array, deque, string, vector, pointer when used to access elements of a built-in array are all random-access iteartor, 


**Algorithm Parameter Patterns**

- ```alg(beg, end, other args);```
- ```alg(beg, end, dest, other args);```
  - ```dest``` is an iteartor that denotes a destination algorithm writes output. <span style="color:red">假定safe to write as many elements as needed.  assume the destination is large enough to hold the output.</span>
  - 如果```dest``` 是 iterator that refers directly to container, then algorithm 直接输出到容器exisiting elements. 更常见的是 ```dest``` is bound to an insert iterator or an ```ostream_iterator ```. Insert iterator 是add new elements to container 确保enough space. An ```ostream_iterator``` writes to an output stream, 也是不管写多少个元素都没有问题
- ``` alg(beg, end, beg2, other args);```
  - 将```beg2```作为第二个输入范围的首元素, 此范围结束位置未指定. 算法假定从beg2 开始范围 与 ```beg``` 和```end```所表示范围至少一样大
- ``` alg(beg, end, beg2, end2, other args);```


**Some Algorithms Use Overloading to Pass a Predicate**: 比如

```c++
unique(beg, end); // uses the == operator to compare the elements

unique(beg, end, comp); // uses comp to compare the elements

```


**Algorithms with _if Versions**: Algorithms that take an element value typically have a second named (not overloaded) version that takes a predicate  in place of the value. The algorithms that take a predicate have the suffix ```_if``` appended: 例子the ```find_if``` algorithm looks for a value for which pred returns a nonzero value.
```c++
find(beg, end, val); // find the first instance of val in the input range 

find_if(beg, end, pred); // find the first instance for which pred is true

```
**Distinguishing Versions That Copy from Those That Do Not**: algorithms that rearrange elements write the rearranged elements back into the given input range. These algorithms provide a second version that writes to a specified output destination. 同时也有一些算法同时提供_copy 和_if 版本

```c++
reverse(beg, end); // reverse the elements in the input range 

reverse_copy(beg, end, dest);// copy elements in reverse order into dest


// removes the odd elements from v1 ]

remove_if(v1.begin(), v1.end(),
    [](int i) { return i % 2; }); 

// copies only the even elements from v1 into v2; v1 is unchanged

remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [](int i) { return i % 2; });
```

#### (f). Container-Specific Algorithms

- ```list``` 和 ```forward_list``` 定义了他们独有的```sort```, ```merge```, ```remove```, ```reverse```, and ```unique```, <span style="color:red">因为generic version of ```sort``` requires random-access iterators, 因此```sort``` 不能用于 ```list``` 和 ```forward_list``` 因为他们offer bidirectional 和 forward iterators</span>. 
- Generic version 其他的algorithm可以用于```list```，但是performance cost 代价太高, 比如A list can “swap” 快速交换元素 its elements by changing the links among its elements rather than swapping the values of those elements. 
- 对于list 和 forward list 优先考虑成员函数版本算法 而不是通用算法
- list 和 forward list  还定义了 ```splice```算法，
- important difference between the list-specific and the generic versions is that the <span style="background-color:#FFFF00">list versions change the underlying container</span>.
- ```merge``` and ```splice``` are destructive on their arguments(会销毁参数).例如generic merge将merged sequence to a given destination iterator; the two input sequences are unchanged. 而```list``` 的```merge```destroys (removed) the given list—elements from the argument list as they are merged into the object on which merge was called. After a merge, the elements from both lists continue to exist, but they are all elements of the same list.

![](/img/post/C++/list_forward_list_algo.png)

都是从```lst2```移动到```lst1```
![](/img/post/C++/splice.png)

***
<br/><br/><br/>

## 11. Associative Containers

#### (a). Overview

**(1). Defining an Associative Container**

- 对于ordered container, map, multimap, set, and multiset. <span style="background-color:#FFFF00">library uses the ```<``` operator for the key tyoe to compare the keys</span>.
- Key Types for Ordered Containers: 可以提供自己定义的比较操作代理关键字的```<``` operator on keys. The specified operation must define a <span style="color:red">**strict weak ordering**</span> over the key type
    - 两个关键词不能同时小于等于对方: 比如 如果 ```k1 <= k2```, 那么<span style="color:red">不可以 ```k2 <= k1```</span>
    - 如果```k1<=k2, k2<=k3```, 那么 ```k1 <= k3```
    - 如果两个Key, 任何都不小于等于另一个, 则成两个key, equivalent, 如果 k1 ==k2 and k2 == k3, 则 k1 == k3
- 如果用自己定义的comparison operation. 需要pass data type and <span style="color:red">comparison type</span> which is a <span style="color:red">**function pointer** type</span>, 并且pass comparison function as constructor argument(类型必须与尖括号中类型一样 )


用自己定义的比较运算,  must <span style="background-color:#FFFF00">supply the type of that operation (pass as a constructor argument, the same type as specified inside the angle brackets) when we define the type of an associative container</span>, 比如下面定义```multiset```, 定义两个types, 一个是Sales_data, 另一个是comparison type, which is a function pointer type that point to ```compareIsbn```. 因为```decltype```返回的是函数类型，需要加上```*```表示函数指针， 注: 下面```compareIsbn``` or ```&compareIsbn``` 都是可以的, 因为当函数作为parameter, 会自动转化为指针

```c++
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{ 
    return lhs.isbn < rhs.isbn;
}
multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn);

//也可用&compareIsbn, 因为当函数作为argument时候，会自动转换成指针

multiset<Sales_data, decltype(compareIsbn)*> bookstore(&compareIsbn);
```


**(2). Pair Type**

The default pair constructor **value initializes** the data members, ```anon``` is a pair of two empty string and, ```line``` holds an empty string and an empty vector

```c++
pair<string, string> anon; // holds two strings 

pair<string, size_t> word_count; // holds a string and an size_t 

pair<string, vector<int>> line; // holds string and vector<int>

pair<string, string> author{"James", "Joyce"};

```

- <span style="background-color:#FFFF00">data members of pair are public</span>. member are named **first** and **second**
- function 可以用list intiailize(braced initializers) return value for pair ```return pair<string, int>();```

![](/img/post/C++/pair.png)

#### (b). Associative Containers Operations


| Syntax | Description | 
| --- | :--- | 
| ```key_type``` | Type of key for this container type, 不是const |
| ```mapped_type``` | Type associated with each key, **map types only** |
| ```value_type``` | For ```sets```, same as the ```key_type```. <br/> For ```maps```, ```pair<const key_type, mapped_typed>``` |

```c++
set<string>::value_type v1; // v1 is a string 

set<string>::key_type v2; // v2 is a string

map<string, int>::value_type v3; // v3 is a pair<const string, int> 

//cannot do 

v4["123"] = 456;//因为key is const 

map<string, int>::key_type v4; // v4 is a string, not const string 

v4 = "123";

map<string, int>::mapped_type v5; // v5 is an int

```

- When we dereference an iterator, get a <span style="background-color:#FFFF00">**reference**</span> to a value of container's ```value_type```. 
  - 对于map, ```value_type``` is a pair which ```first``` holds the <span style="background-color:#FFFF00">**const key**</span> and ```second``` holds the value. 可以改变value 值 但不能改变key的值
- <span style="background-color:#FFFF00">Iterators for ```sets``` Are **const**</span>,虽然sets定义了```iterator``` 和 ```const_iterator``` 但都**read-only access**
- map, multimap, set, or multiset, the iterators yield elements in ascending key order. 比如for loop 是按照升序来读(由小到大)
- we do not use the generic algorithms (Chapter 10) with the associative containers.  The fact that the **keys are const** means that we cannot pass associative container iterators to algorithms that write to or reorder container elements.
  - Associative containers can be used with the algorithms that read elements.However, many of these algorithms search the sequence. 因为elements in associative container 可以被快速找到根据他们的key, <span style="color:red">bad idea to use generic search algorithm</span>, associative containers define a member named ```find```, 用它比generic ```find``` algorithm 快的多(generic algorithm use sequential search)
  - 如果把associative container with algorithms either <span style="color:red">source sequence or as a destination</span>.可以使用```copy``` or ```inserter``` to bind an insert iterator (用```inserter```,可把associative container as a destination for another algorithm)
- map 和 set, 只有key 不存在时候，才会真的插入，如果存在，对于set 无更改, map 会更改value
- 对于<span style="color:red">multiset, multimap, ```insert``` 不需要return bool, 因为总是insert 成功</span>, 返回an iterators to the new element
- <span style="color:red">set 不支持下标运算</span>, <span style="color:red"> 也不能对 multimap 和 unordered_multi_map 进行下标运算 </span>, 因为一个key 对应多个value
  - ```c[k]``` 和 ```c.at[k]``` 区别是 ```at``` 有range check, 会throw ```out_of_range``` exception 
  - <span style="background-color:#FFFF00">下标运算 和 ```at``` 只能用于**non const 的 map, unordered_map**</span>
  - subscript a map, we get a ```mapped_type``` object; when we dereference a map iterator, we get a ```value_type``` object (有first, second)
- multimap 和 multiset, multiple elements of a given key, those elements 是相邻的

```c++
// get an iterator to an element in word_count

auto map_it = word_count.begin();

// *map_it is a reference to a pair<const string, size_t> object

map_it->first = "new key"; // error: key is const 

++map_it->second; // ok: we can change the value through an iterator

```

iterator for set is const, 不能修改

```c++
set<int> iset = {0,1,2,3,4,5,6,7,8,9}; 
set<int>::iterator set_it = iset.begin(); 
if (set_it != iset.end()) {
    *set_it = 42; // error: keys in a set are read-only

    cout << *set_it << endl; // ok: can read the key 
    
}
```

insert into map 
```c++
// four ways to add word to word_count 

word_count.insert({word, 1});
word_count.insert(make_pair(word, 1)); 
word_count.insert(pair<string, size_t>(word, 1)); 
word_count.insert(map<string, size_t>::value_type(word, 1));
```

**Insert**

| Syntax | Description | 
| --- | :--- | 
| ```c.insert(v)``` <br/> ```c.emplace(args)``` | 对于map, set Returns a pair containing an iterator referring to the element with the given key and a bool 表示element 是否插入成功, false 表示之前就已经存在, 未插入; 对于multiset, multimap, 返回 iterator to the new element  |
| ```c.insert(b,e)``` <br/> ```c.insert(il)``` | <span style="color:red">return void</span>. ```b,e``` is itertor, 对于map, set 如果key 不存在才会插入, multimap 和multiset inserts each element in the rage|
| ```c.insert(p,v)``` <br/> ```c.emplace(p, args)``` | iterator p是一个插入位置的提示。<span style="color:red">returns an iterator to the element with the given key</span>. |

e.g. insert 是上面的version 1, 返回的是```pair<iterator, bool>```
```c++
map<string, size_t> word_count; 
string word;
while (cin >> word) {
    auto ret = word_count.insert({word, 1});
    if (!ret.second) 
        ++ret.first->second; 
}
```

**Erase**


| Syntax | Description | 
| --- | :--- | 
| ```c.erase(k)```  |  removes  每一个等于k的key, <span style="color:red">Returns a ```size_type``` 表示删除元素的数量 </span>  |
| ```c.erase(p)```| iterator p是一个删除的位置, 不能是```c.end()```, <span style="color:red">return an iterator after ```p``` or ```c.end()```(if p is the last element) |
| ```c.erase(b,e)```  | removes the range from ```[b,e)```, <span style="color:red">return ```e```</span>  |



**Access**


| Syntax | Description | 
| --- | :--- | 
| ```c.find(k)```  |  return an iterator 指向第一个key = k的 |
| ```c.count(k)```  |  returns the number of elements with k, 对于containers with unique keys, result always is 0 or 1 |
| ```c.lower_bound(k)```  |  returns an iterator 指向第一个不小于k的元素 |
| ```c.upper_bound(k)```| returns an iterator 指向第一个大于k的元素 |
| ```c.equal_range(k)```  | returns an pair of iterators denoting the elements with key ```k```. 如果```k``` 不存在，both members are ```c.end()``` |

Access ```multimap```

```c++
string search_item("Alain de Botton");
auto entries = authors.count(search_item); /
auto iter = authors.find(search_item); 
while(entries) {
    cout << iter->second << endl; 
    ++iter;
    --entries; 
}
```

可以用**lower_bound, upper_bound** 解决上面问题
```c++
for (auto beg = authors.lower_bound(search_item),
            end = authors.upper_bound(search_item); beg != end; ++beg)
cout << beg->second << endl; 
```
再用 **equal_range** 解决上面问题, equal_range 返回 等于查找元素的 range ```[beg,end)```  
```
for (auto pos = authors.equal_range(search_item);
pos.first != pos.second; ++pos.first)
    cout << pos.first->second << endl; 
```

#### (c). Unordered Containers

- Rather than comparison operation to organize elements, <span style="background-color:#FFFF00">these containers use a ```hash``` function and the key type's ```==``` operator</span>. 
- unordered container 的输出与 order container的输出会有不同

**Manage the Buckets**
- The unordered containers are organized as a <span style="background-color:#FFFF00">**collection of buckets**</span>, each of which holds zero or more elements. 
- use hash function to map elements to bucekts. The container puts all of its <span style="color:red">elements with a given hash value into the same bucket</span>.
- To access an element, container first computes the element's **hash code**, which tells which bucket to search.

- The hash function must always yield the same result when called with the same argument. Ideally, the hash function also maps each particular value to a unique bucket. However, a hash function is allowed to map elements with differing keys to the same bucket
  - When a bucket holds several elements, those elements are <span style="color:red">**searched sequentially to find**</span> the one we want.
  -  However, if the **bucket has many elements**, **many comparisons may be needed** to find a particular element.
- 如果container 允许重复elements with a given key (multi_unordered_map, multi_unordered_set), all the elements with the same key will be in the same bucket.
- The performance of an unordered container depends on the quality of its hash function and on the number and size of its buckets.
- ```load_factor``` = size(#elements) / bucket_count; ```max_load_factor```被用作threshold that forces an increase in the number of buckets. ```max_load_factor```越小, 更频繁call ```rehash```
- ```bucket_count```是现在有几个可以使用，不是有几个已经被占用, ```max_bucket_count```是最大的potential number of buckets that unordered_map can have (受system constraints or limitation 影响而不同) 

![](/img/post/C++/unordered_map.png)

**Difference between rehash and reserve**: ```rehash``` doesn't give you any guarantees, and ```reserve``` doesn't express the purpose of rehashing. Use ```rehash``` if you think your map is inefficient, and ```reserve``` if you're preparing for a lot of insertions.
- ```rehash``` takes an existing map and rebuilds a new size of buckets, rehashing in the process and redistributing elements into the new buckets.
  - If <span style="color:red">n >= current buckets</span> into the container then rehashed is done. The new bucket count can be greater than or equal to n.
  - If <span style="color:red">n < current buckets</span> then there may or may not be any effect of function. <span style="color:red">It totally depends upon compiler</span>
- ```reserve``` guarantees you that if you don't insert more than the reserved number of elements, there will be no rehashing (i.e. your iterators will remain valid). Effectively calls ```rehash(std::ceil(count / max_load_factor()))```. ```reserve``` 最好在插入元素前call

比如有code, 下面是okay的
```c++
auto itr = myMap.begin();
while (itr != myMap.end()) {
    if (/* removal condition */) {
        itr = myMap.erase(itr);
    } else {
        ++itr;
    }
}
```

The <span style="background-color:#FFFF00">**erase members shall invalidate only iterators and references to the erased elements**</span>, and preserve the relative order of the elements that are not erased. 而<span style="background-color:#FFFF00">**Rehashing invalidates iterators, changes ordering between elements**</span>.


**Requirements on Key Type for Unordered Containers**

- use an object of type ```hash<key_type>``` to generate the hash code for each element. 
- library 定义一些```hash``` template for <span style="background-color:#FFFF00">**built-in types, including pointers**</span>. 同样也定义了hash for some library types including <span style="background-color:#FFFF00">**strings** and the **smart pointer types**</span>.  we can directly define unordered containers whose key is one of the built-in types (including pointer types), or a string, or a smart pointer.
- 我们不能直接定义unordered container that uses our own class types as key type. Must supply our own version of ```hash``` template. 

To use Sales_data as the key, we’ll need to supply functions to replace both the <span style="color:red">```==``` operator</span> and to <span style="color:red">calculate a hash code</span>. 如果我们<span style="color:red">class 内有 ```==``` operator</span>  we can <span style="color:red">override just the hash function</span>
```c++
size_t hasher(const Sales_data &sd) { 
    return hash<string>()(sd.isbn());
}
bool eqOp(const Sales_data &lhs, const Sales_data &rhs)
{
return lhs.isbn() == rhs.isbn();
}

using SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;
// arguments are the bucket size, pointers to the hash function, and equality operator

SD_multiset bookstore(42, hasher, eqOp);//42 is bucket size 


// 方法二: use FooHash to generate the hash code; Foo must have an == operator 

unordered_set<Foo, decltype(FooHash)*> fooSet(10, FooHash);
```
***

<br/><br/><br/>






























## 12. Dynamic Memory

- Local, **automatic objects** are created and destroyed when the block in which they are defined is entered and exited
- Local **static objects** are allocated before their first use and are destroyed when the program ends
- **Dynamically allocated objects** have a lifetime that is <span style="color:red">**independent** of where they are created</span>; they exist until they are explicitly freed.只有显示的释放, 才能被销毁


Our programs have used only static or stack memory.
- Objects allocated in **static** or **stack memory** are <span style="background-color:#FFFF00">automatically created and destroyed by the compiler</span>. 
  - **Static memory** is used for <span style="color:red">local static objects(局部静态变量, 见6.1, 程序执行路径第一次经过时define exist until 程序结束)</span>, for <span style="color:red">class static data members</span>, and for <span style="color:red">variables defined outside any function</span>
    - **static objects** are allocated before they are used, and they are destroyed when the program ends.
  - **Stack memory** is used for <span style="color:red">**nonstatic objects** defined inside functions</span> (local variables, also hold parameters passed to functions).
    - **Stack objects** exist only while the block in which they are defined is <span style="color:red">executing</span>;
    - Stack similar to ```std::stack``` class, FIFO, the function knows 他们期望的parameters can be found on the end of the stack. Function can push locals on stack and pop before returning the function. 
    - **Stack** is usually in **CPU cache**, so operations involving objects stored on it tend to be <span style="color:red">**faster**</span> (因为FIFO design)
    - However, **stack** is limited resource, Running out of stack is called **stack buffer overflow**, 不会遇到这样问题除非有crazy recursive function
- In addition to static or stack memory,This memory is referred to as the **free store** or **heap**. 
  - Programs use the **heap** for objects that they **dynamically allocate**—that is, for objects that the program <span style="color:red">allocates at **run time**</span>
  - The program <span style="background-color:#FFFF00">controls the lifetime of dynamic objects</span>; <span style="color:red">our code must explicitly destroy such objects</span> when they are no longer needed.
  - Running out of heap memory result in ```std::bad_alloc```

Dynamic Memory and Smart Pointers: 

- ```new``` 和 ```delete``` error-prone, cannot rely on the default definitions for the members that copy, assign, and destroy class objects
  - ```new``` : <span style="color:red">**allocates**</span>, and <span style="color:red">**optionally initializes**</span>, an object in dynamic memory and <span style="color:red">**returns a pointer**</span> to that object;
  - ```delete```: takes a pointer to a dynamic object, <span style="color:red">**destroys that object**</span>, and <span style="color:red">**frees the associated memory**</span>.
- Dynamic memory is **problematic** because it is surprisingly hard to ensure that we free memory at the right time. 有时忘记释放内存，会造成**memory leak**, 或者尚有指针引用存储的情况下就释放了它, 造成pointer is invalid.
- To make using dynamic memory easier (and safer), new library定义了two smart pointer, A smart pointer acts like a regular pointer with the important exception that it <span style="color:red">**automatically deletes** the object to which it points</span>. 






#### (a). Managing Memory Directly

**(1). Using new to Dynamically Allocate and Initialize Objects**

- Objects <span style="background-color:#FFFF00">allocated on the **free store** are unnamed</span>(没有命名的), Instead, new returns a pointer to the object it allocates:
- By default, dynamically allocated objects are **default initialized**: <span style="color:red"> built-in or compound type objects have undefined value; objects of class type are initialized by their default constructor</span>
- 可以nitialize a dynamically allocated object using 直接初始化. 可以用**parentheses 的constructor**(in place construct) or 使用**list initialization(curly braces)**, 也可以用**value initialization**, 只需要在类型别名后跟一个空括号
    - 对于**class type** that define their own constructor, value initialization 是没有意义的. 因为不管用什么形式, 都用default constructor 来初始化
    - 对于**built-in** type, 有difference, a <span style="color:red">**value-initialized object** of built-in type has a **well-defined value**</span> but a <span style="color:red">**default-initialized object does not** default-initialized 是未定义的</span>
- 可以用```auto``` 去deduce the type

```c++
int *pi = new int; // pi points to a dynamically allocated, unnamed, uninitialized int

string *ps = new string; // initialized to empty string

int *pi = new int; // pi points to an uninitialized int 未初始化

```
初始化

```c++
int *pi = new int(1024); // object to which pi points has value 1024 

string *ps = new string(10, '9'); // *ps is "9999999999"

// vector with ten elements with values from 0 to 9

vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};
```

value initialization
```c++
string *ps1 = new string; // default initialized to the empty string 

string *ps = new string(); // value initialized to the empty string 

int *pi1 = new int; // default initialized; *pi1 is undefined 

int *pi2 = new int(); // value initialized to 0; *pi2 is 0

```

pointer of class type initialization When we provide **an initializer inside parentheses**, we can use ```auto``` to <span style="color:red">deduce the type</span> of the object we want to allocate from that initializer(第一个例子). 如果 obj 是int, 那么 p1 是 ```int*```, 如果 obj string, 那么 p1 是 ```string*```
```c++
auto p1 = new auto(obj); // p points to an object of the type of obj // that object is initialized from obj

auto p2 = new auto{a,b,c}; // error: must use parentheses for the initializer, 只能用括号包含单个初始器


```

**(2). Dynamically Allocated const Objects**
- It is <span style="background-color:#FFFF00">legal to use new to allocate const objects</span>:
- <span style="background-color:#FFFF00">A dynamically allocated const object must be **initialized**</span>
-  A <span style="color:red">**const dynamic object** of a **class type**</span> that defines a default constructor  may be <span style="color:red">**initialized implicitly**</span>. Objects of other types must be explicitly initialized. <span style="background-color:#FFFF00">const 动态对象可以隐式初始化, 不是const动态类型对象必须显示初始化</span> 
- Because the allocated object is ```const```, <span style="color:red">the pointer returned by ```new``` is a pointer to ```const```</span>


```c++
// allocate and initialize a const int

const int *pci = new const int(1024); 

// allocate a default-initialized const empty string const 

string *pcs = new const string;
```

```c++


```

**(3). Memory Exhaustion**

- Although modern machines tend to have huge memory capacity, 可是也有可能自由空间(free store)被耗尽(exhausted). Once a program has <span style="background-color:#FFFF00">**used all of its available memory**, **new expressions will fail**</span>.
- if new is **unable to allocate** the requested storage, it <span style="color:red">throws an exception of type ```bad_alloc```</span>,
    - 可以<span style="color:red">prevent ```new``` from throwing an exception</span> by using a different form of ```new``` 
    - 下面例子阻止抛出异常叫: **placement new**, 传递一个由标准库定义的 ```nothrow``` 对象, 如果将```nothrow``` 传递给 ```new```, 我们是告诉它不要抛出异常, 如果```new```不能分配内存, 返回一个空指针.
    - ```bad_alloc``` 和 ```nothrow``` 都定义在```new``` header中

阻止抛出```bad_alloc```
```c++
// if allocation fails, new returns a null pointer

int *p1 = new int; // if allocation fails, new throws std::bad_alloc

int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer

```

**(4). Freeing Dynamic Memory**

- 为了避免 **memory exhaustion**,  we must <span style="background-color:#FFFF00">return dynamically allocated memory to the system</span> once we are finished using it through ```delete``` expression 
- ```delete p;```: p must point to a **dynamically allocated object** or be **null**
- <span style="color:red">Deleting</span> a pointer to memory that <span style="color:red">**was not allocated by new**</span>, or deleting the same pointer value <span style="color:red">**more than once**</span>, is <span style="color:red">**undefined**</span>
   - <span style="color:red">删除non dynamically allocated 指针是错误的</span>. Compiler cannot tell whether a pointer 指向statically or dynamically allocated object.
   - 如果两个指针指向一个object, 删除第一个指针, 不用删除第二个指针(delete more than once), 否则error
   - Compiler <span style="color:red">cannot tell</span> whether <span style="color:red">memory addressed</span> by a pointer has already <span style="color:red">been freed</span>. <span style="color:red">Most compilers will accept these delete expressions</span>, even though they are in error. 
- 对于shared_pointer 管理的内存在最后一个shared_ptr销毁时被自动释放, 但对于built-in pointer 是不是这样的,  A **dynamic object** managed through a built-in pointer (rather than smart pointers) <span style="color:red">**exists** until it is **explicitly deleted** (freed)</span>.
  - Functions that return **pointers** (rather than smart pointers) to **dynamic memory** put a burden on their callers—<span style="color:red">the caller must remember to delete the memory</span>

```c++
int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;

delete i; // error: i is not a pointer

delete pi1; // undefined: pi1 refers to a local (指的是局部静态对象)

delete pd; // ok

delete pd2; // undefined: the memory pointed to by pd2 was already freed 

delete pi2; // ok: it is always ok to delete a null pointer

```

对于function 返回指针指的是dynamically allocated object. function 的caller 必须释放内存, 比如下面的例子, pointer out of scope, 但是内存还没有释放
```c++
Foo* factory(T arg)
{
    return new Foo(arg); // caller is responsible for deleting this memory 

}

void use_factory(T arg){
// use p but do not delete it

    Foo *p = factory(arg);
} // p goes out of scope, but the memory to which p points 没有被释放


//正确方式
void use_factory(T arg){
    Foo *p = factory(arg);
    delete p;
} 


```

Managing Dynamic Memory Is Error-Prone: can avoid all of these problem by using smart pointers exclusively. 
1. 忘记```delete```内存 -- 内存泄漏问题, memory is never returned to the free store, 查找内存泄漏错误是困难的, 因为通常程序运行很长时间后，真正耗尽内存是，才能检测到这种错误
2. Using an object after it has been deleted. This error can sometimes be detected by <span style="background-color:#FFFF00">**making the pointer null** after the delete</span>.
3. 同一块内存释放两次. This error can happen <span style="background-color:#FFFF00">when **two pointers** address **the same dynamically allocated object**</span>. If delete is applied to one of the pointers, then the object’s memory is returned to the free store. <span style="color:red">If we subsequently delete the second pointer, then the free store may be corrupted</span>.


**(5).Resetting the Value of a Pointer after a delete ...**

- 当```delete``` pointer, <span style="color:red">pointer becomes **invalid**</span>. 尽管pointer is invalid, <span style="color:red">pointer 继续hold the address of the dynamic memory</span>.  After the delete, the pointer becomes what is referred to as a <span style="background-color:#FFFF00">**dangling pointer**</span>. 即曾经保存对象数据 但现已经无效的内存指针
  - Dangling pointers have all the problems of uninitialized pointers. 有种方法可以避免问题: 即 If need to keep the pointer after delete memory 在离开现scope前<span style="color:red">assign **nullptr** to the pointer after we use delete</span>. 这样清楚指出指针不指向任何对象


下面例子中p 和 q, 指向the same dynamically allocated object. We ```delete``` that memory and set ```p``` to ```nullptr```, 表示 that the pointer no longer points to an object. However, <span style="background-color:#FFFF00">resetting p has no effect on q, which became invalid when we deleted the memory to which p</span>
```c++
int *p(new int(42)); // p points to dynamic memory

auto q=p; // p and q pointtothesamememory 

delete p; // invalidates both p and q

p = nullptr; // indicates that p is no longer bound to an object

```



#### (b). shared_ptr
- A default initialized smart pointer holds a null pointer；```shared_ptr<string> p1; ```

```shared_ptr``` 和 ```unique_ptr``` 都支持的操作

| Syntax | Description | 
| --- | :--- | 
| ```shared_ptr<T> sp```<br/>  ```shared_ptr<T> up```  |  Null smart pointer that can point to objects of type T |
| ```p```  |  将p用作一个条件判断, 若p 指向一个对象, 则为true |
| ```*p```  |  Dereference p to get the object to which p points |
| ```p->mem```| same as ```(*p).mem``` |
| ```p.get()```  | 返回p中保存的指针, 要小心使用，如果指针指针释放了其对象， 返回指针所指向的对象就消失了 |
| ```swap(p,q)```  <br/> ```p.swap(q)``` | 交换p和q的指针 | 


```shared_ptr``` 独有的操作

| Syntax | Description | 
| --- | :--- | 
| ```make_shared<T>(args)```  |  返回一个```shared_ptr```, pointing to a <span style="color:red">**dynamically allocated object**</span> of type ```T```. Use args to initialize that object |
| ```shared_ptr<T>p(q)```  |  p is a copy of ```shared_ptr q```, <span style="color:red">*递增q中的计数器</span>, The pointer in q must be convertible to ```T*``` |
| ```p = q```  |  p 和 q 都是 ```shared_ptr```, 所保存的指针必须能相互转换，<span style="color:red">**Decrement p's reference count and increment q's count**; **delets** p's **existing memory** if p's **count goes to 0**</span> |
| ```p->unique```| 若```p.use_count```为1，返回true, 否则返回false |
| ```p.use_count```  |  返回与p 共享对象的智能指针数量, 可能很慢, <span style="color:red">intended primarily for debugging purposes</span> |


**(1). make_shared**

- The <span style="background-color:#FFFF00">**safest way** to **allocate** and **use dynamic memory**</span> is to call a library function named ```make_shared```.
- This function <span style="color:red">**allocates** and **initializes** an object in dynamic memory</span> and <span style="color:red">returns a shared_ptr</span> that points to that object
- defined in ```memory``` header 
- 类似于```emplace```, 可以用 <span style="color:red">its argument to construct an object of the given type in place</span>
- 可以用```auto``` 来存储 ```make_shared``` 的 ```shared_ptr```

```c++
// shared_ptr that points to an int with value 42

shared_ptr<int> p3 = make_shared<int>(42);

// p4 points to a string with value 9999999999 

shared_ptr<string> p4 = make_shared<string>(10, '9');

// p6 points to a dynamically allocated, empty vector<string> 

auto p6 = make_shared<vector<string>>();
```

**Copying and Assigning shared_ptrs**

- <span style="color:red">copy or assign a shared_ptr</span>, each shared_ptr <span style="color:red">keeps track of how many other shared_ptrs (**reference count**) point to the **same object**</span>:
    - 当use shared_ptr to initialize another ```shared_ptr```, 或者 pass it to or return it from a function **by value**, reference count 都会增加
    - 当assign a new value to ```shared_ptr``` 或者```shared_ptr``` 被destoryed, 或者goes out of scope 时候, counter 会decrement. 
- **shared_ptr’s counter goes to zero**, the shared_ptr <span style="color:red">**automatically frees**</span> the object that it manages

```c++
auto p = make_shared<int>(42); // object to which p points has one user 

auto q(p); // p and q point to the same object

// object to which p and q point has two users

```

```c++
auto r = make_shared<int>(42); // int to which r points has one user 

r = q; // assign to r, making it point to a different address

    // increase the use count for the object to which q points 

    // reduce the use count of the object to which r had pointed

    // the object r had pointed to has no users; that object is automatically freed

```

**(3).shared_ptrs Automatically Destroy Their Objects**

- When the **last** shared_ptr pointing to an object is **destroyed**, shared_ptr 会自动销毁此对象。It does so through **destructor**. 
    - 比如string 的constructuor 会分配空间来保存character that compose string. destructor 会free memory.  同样的, vector allocate memory to hold elements in vector, desctructor destory elements and free memory used for the elements. 
- The **destructor** for shared_ptr **decrements the reference count** of the object to which that shared_ptr points. If the count 变成0, the shared_ptr <span style="color:red">destructor 销毁 shared_ptr指的对象 and frees the memory used by that object</span>.
- 如果把```shared_ptr``` 放进一个容器中, 如果不需要使用, call ```erase``` 删除不再需要的那些元素. 

下面例子中当```p``` 销毁时，递减其引用计数并检查是否为0，因为p是唯一引用factory 返回内存的对象。由于p将要销毁，p指向的这个<span style="color:red">**对象也被销毁**</span>， 所占用的<span style="color:red">**内存会被释放**</span>.
```c++
shared_ptr<Foo> factory(T arg)
{
    return make_shared<Foo>(arg);
}

void use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
} // p goes out of scope; the memory to which p points is automatically freed

```

对于下面例子，returns a copy of p to its caller. <span style="background-color:#FFFF00">Copying a shared_ptr adds to the reference count of that object</span>. Now when p is destroyed, there will be another user for the memory to which p points. Memory itself will not be freed.
```c++
shared_ptr<Foo>  use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
    return p;
} 
```

**(4). Classes with Resources That Have Dynamic Lifetime**

Programs tend to use dynamic memory for one of three purposes: 
1. They don’t know how many objects they’ll need 不知道自己需要使用多少对象
2. They don’t know the precise type of the objects they need, 不知道所需对象准确类型
3. They want to share data between several objects  需要在多个对象空间共享操作

e.g. 使用shared_ptr, 比如```vector```,allocated resources that exist 与对象生存期一致, 但我们想定义对象 allocated resources 与对象生存期是独立的

```c++
vector<string> v1; 
{ 
    vector<string> v2 = {"a", "an", "the"};
    v1 = v2; // copies the elements from v2 into v1 

} // v2 is destroyed, 但是v1 仍有三个元素,


Blob<string> b1;
{
    Blob<string> b2 = {"a", "an", "the"};
    b1 = b2;
}// 想让b2 被销毁时，但是b2中的元素不能销毁

//b1 指向最初由b2创建的元素

```

因为template 在后面用到, 先用string类
```c++
class StrBlob{
public: 
    typedef vector<string>::size_type size_type;
    StrBlob();
    StrBlob(initializer_list<string>il);
    
    size_type size() const {return data->size;}
    bool empty() const {return data->empty();}
    void push_back(const string & t) {data->push_back(t);}
    void pop_back();
    string& front();
    string& back();

private: 
    shared_ptr<<vector<string>> data; 
//没有 copy constructor, data 也能被定义, 因为compiler generate copy constructor
    
    void check(size_type i, const string & msg) const; 
};

StrBlob::StrBlob(): data(make_shared<vector<string>>()) {} 

StrBlob::StrBlob(initializer_list<string>il): data(make_shared<vector<string>>(il)) {} 

void StrBlob::check(size_type i, const string & msg) const {
    if (i>= data->size())
        throw out_of_range(msg);
}; 
```

**(5). Using shared_ptrs with new**

- if we do <span style="background-color:#FFFF00">not initialize</span> a smart pointer, it is initialized as a <span style="background-color:#FFFF00">**null pointer**</span>.
- The smart pointer  <span style="background-color:#FFFF00">constructors</span> that take pointers are <span style="background-color:#FFFF00">**explicit**</span>. <span style="color:red">Cannot **implicitly** convert a built-in pointer to a smart pointer</span>. 必须使用direct form of initialization 
    - a function that <span style="color:red">returns a shared_ptr **cannot implicitly convert** a plain pointer</span> in its return statement
- <span style="color:red">a pointer used to initialize a smart pointer must point to **dynamic memory**</span> because, by default, smart pointers <span style="color:red">use ```delete``` to **free the associated object**</span>.
- ```reset``` 通常与 ```unique``` 一起使用, 控制多个shared_ptr 共享的对象. <span style="background-color:#FFFF00">Before changing the **underlying object**, we check whether we’re the only user</span>. If not, we <span style="background-color:#FFFF00">**make a new copy** before making the change</span>, 详见下面例子
- <span style="color:red">**当用shared_ptr with dynamic allocated array, 必须用deleter**, 否则删除的只是array的第一个元素</span>

```c++
shared_ptr<double> p1; // shared_ptr that can point at a double 

shared_ptr<int> p2(new int(42)); // p2 points to an int with value 42


shared_ptr<int>p1 = new int(1024);//error: must use direct initialization

shared_ptr<int> p2(new int(1024)); // ok: uses direct initialization

```

function return 

```c++
shared_ptr<int> clone(int p) {
    return new int(p); // error: implicit conversion to shared_ptr<int> 

}

shared_ptr<int> clone(int p) {
    // ok: explicitly create a shared_ptr<int> from int*

    return shared_ptr<int>(new int(p));
}

```


Define and Change shared_ptr

| Syntax | Description | 
| --- | :--- | 
| ```shared_ptr<T>p(q)```  | p manages the object to which the **built-in pointer** q points; <span style="color:red">q must point to **memory allocated** by ```new```</span>  and must be convertible to ```T*``` |
| ```shared_ptr<T> p (u)``` | p assumes ownership from the ```unique_ptr``` u(接管u接管了对象所有权); makes ```u``` null (将u设置成null)|
| ```shared_ptr<T> p (q, d)``` | p assumes ownership from the object to which <span style="color:red">**built-in poiner** q points</span>. q must be convertible to ```T*```, p will <span style="color:red">use</span> the callable object <span style="color:red">d(lambda expression) in place of ```delete``` to free q</span> (call d 代替 delete ) |
| ```shared_ptr<T>p (p2, d)``` | p is a copy of shared_ptr p2 (递增p2的计数器) except that p uses the callable object d  in place of ```delete``` |
| ```p.reset()``` <br/> ```p.reset(q)``` <br/> ```p.reset(q,d)``` | 若p is <span style="color:red">only</span> shared_ptr pointing at its object, ```reset``` <span style="color:red">frees p's existing object</span>. 若传递了可选的参数**built-in pointer** q, makes p pointer to q, otherwise <span style="color:red">makes p null</span>. If d is supplied will call d to free q otherwise uses ```delete``` to free q | 

reset + unique

```c++
if (!p.unique()) //true 表示p不是唯一控制underlying object的
    
    p.reset(new string(*p)); // 我们不是唯一用户, 分配新的拷贝

*p += newVal; // now that 我们知道自己是唯一用户, okay to change this object

```


当用shared_ptr with dynamic allocated array, 必须用deleter


```c++
shared_ptr<Dog>p1(new Dog[3], [](Dog * p){delete[] p;});
```


**Don’t Mix Ordinary Pointers and Smart Pointers**

- A shared_ptr can coordinate destruction only with other shared_ptrs that are copies of itself(当只有自身拷贝，可以call destructor). 这也是推荐使用 recommend using ```make_shared``` rather than ```new```. ```make_shared``` we <span style="background-color:#FFFF00">bind a shared_ptr to the object at **the same time** that we **allocate** it</span>. <span style="color:red">从而避免了将同一块内存绑定到多个独立创建的```shared_ptr```上</span>
- It is <span style="color:red">dangerous to use a **built-in pointer** to access an object owned by a smart pointer</span>, because we may not know when that object is destroyed.
- When we <span style="color:red">bind a shared_ptr to a plain pointer</span>, we give responsibility for that **memory** to that shared_ptr. we should <span style="color:red">no longer use a built-in pointer to access the memory</span> to which the shared_ptr now points

下面例子 parameter to ```process``` is <span style="color:red">passed **by value**</span>. 
-  正确方式是 pass it a ```shared_ptr``` 因此 argument to ```process``` is copied into ```ptr```. Copying a shared_ptr increments its reference count. Thus, inside process the count is at least 2. When process completes, ptr reference count 会递减, 但不会变为0，因此当局部变量ptr被销毁时, the memory to which ptr points will not be deleted。 
-  错误的方法二: 传递了一个临时的shared_ptr that we explicitly construct from a built-in pointer. 但是会有error, 因为pass的是temporary. That <span style="background-color:#FFFF00">**temporary is destroyed**</span> when the expression in which the <span style="background-color:#FFFF00">**call appears finishes**</span>. Destroying the temporary decrements the reference count, which goes to zero. <span style="color:red">临时对象被销毁时,所指的内存会被释放</span>. But x continues to point to that (freed) memory; x is now a **dangling pointer**. <span style="color:red">Attempting to use the value of x is **undefined**</span>.

```c++
// ptr is created and initialized when process is called 

void process(shared_ptr<int> ptr)
{
    // use ptr

} // ptr goes out of scope and is destroyed


shared_ptr<int> p(new int(42)); // reference count is 1

process(p); // copying p increments its count; in process the reference count is 2

int i = *p; // ok: reference count is 1



int *x(new int(1024)); // dangerous: x is a plain pointer, not a smart pointer

process(x); // error: cannot convert int* to 

shared_ptr<int> process(shared_ptr<int>(x)); // legal, but the memory will be deleted!

//shared_ptr<int>(x) 是 r-value 在function完之后, 就被删除掉了, 明天记得debug看什么时候删除的

int j = *x; // undefined: x is a dangling pointer!

```


**Don’t Use get to Initialize or Assign Another Smart Pointer**

- smart pointer 定义了一个函数 ```get```, <span style="background-color:#FFFF00">**返回built-in pointer**</span> to the object that smart pointer is managing. 此函数是为了这样一种情况设计的:
  - This function is intended for cases when we need to <span style="color:red">pass a built-in pointer</span> to code that <span style="color:red">can’t use a smart pointer</span>. <span style="color:red">The code</span> that uses the return from get <span style="color:red">**must not delete that pointer**</span>.
- Although the compiler will not complain, it is an <span style="color:red">**error** to bind another smart pointer to the pointer returned by ```get```</span>

下面例子中, p 和 q是相互独立的创建的, 各自的计数器都是1, 当q所在block结束时, q被destroyed -> free the memory to which q points. makes p into a **dangling pointer**. 意味着attempt to use p is undefined. Moreover, <span style="background-color:#FFFF00">when p is destroyed, the pointer to that memory will be deleted a second time.</span>
```c++
shared_ptr<int> p(new int(42)); // reference count is 1

int *q = p.get(); // ok: but don't use q in any way that might delete its pointer

{ 
    // undefined: 两个独立的shared_ptr指向相同的内存
    
    shared_ptr<int>(q);

} // block ends, q is destroyed, and the memory to which q points is freed

int foo = *p; // undefined; the memory to which p points was freed

```


**(6). Smart Pointers and Exceptions**

-  <span style="background-color:#FFFF00">Need to ensure that resources are properly freed if an exception occurs</span>. One easy way to make sure resources are freed is to **use smart pointers**.
-  When we use a smart pointer, the smart pointer class <span style="color:red">**ensures that memory is freed**</span> when it is no longer needed even if the <span style="color:red">block is exited prematurely</span>:
    - When a function is exited, 正常处理结束或者发生了异常, 无论哪种情况 all the local objects are destroyed
   - 如果使用built-in pointer 管理内存, 在```new```之后对应的```delete```发生异常, 内存不会自动释放
- <span style="color:red">classes</span> that are designed to be <span style="color:red">used by both C and C++</span> generally <span style="color:red">require</span> the user to specifically <span style="color:red">free any resources</span> that are used.

下面第一个例子 即使有异常, 内存会自动被释放, 第二个例子, 如果异常在```new```和 ```delete```之间且异常未被catch, <span style="color:red">this memory can never be freed</span>
```c++
void f()
{
shared_ptr<int> sp(new int(42)); // allocate a new object

// code that throws an exception that is not caught inside f 

} // 函数结束时 shared_ptr 自动释放内存


void f()
{
int *ip = new int(42); // dynamically allocate a new object

 // code that throws an exception that is not caught inside f

delete ip; // free the memory before exiting

}

```

<span style="color:red">Classes that **allocate resources**—and that **do not define destructors** to free those resources</span>—can be subject to the same kind of <span style="color:red">errors that arise when we use **dynamic memory**</span>. 比如下面例子如果connection had a destructor, that destructor would automatically close the connection when f completes.问题与memory leak 几乎是等价的.  解决方法用```shared_ptr``` + ```delete```, 定义一个函数代替```delete```, <span style="color:red">即使发生异常, 也可以正确的关闭</span>

```c++
struct destination; // 表示我们正在连接什么

struct connection; // 表示我们连接所需要的信息

 connection connect(destination*); //打开连接 
 
 void disconnect(connection); // 关闭连接
 
 void f(destination &d /* other parameters */)
{
// 获得连接，接住使用完后要关闭它

connection c = connect(&d);

// use the connection

// 如果在f退出前忘记调用disconnect, 就无法关闭c了
}

//解决方法

void end_connection(connection *p) { disconnect(*p); }

void f(destination &d /* other parameters */)
{
    connection c = connect(&d);
    shared_ptr<connection> p (&c, end_connection);
    //使用连接

    //当f 退出时（即使是由于异常退出）, connection会被正确关闭
    
}

```


**Smart Pointer Pitfalls**
1. 不使用相同的built-in pointer value to initialize more than one smart pointer 
2. 不delete ```get``` 返回的指针
3. Don’t use ```get()``` to initialize or ```reset``` another smart pointer.(不把get返回的指针跟其他smart pointer 绑定)
4. If you use a pointer returned by ```get()```, remember that the <span style="color:red">pointer</span> will <span style="color:red">become **invalid** when the last corresponding smart pointer goes away.</span>
5. 如果使用smart pointer to manage <span style="background-color:#FFFF00">a resource other than memory allocated by new, remember to pass a deleter</span>



#### (c). unique_ptr

- Unlike ```shared_ptr```, <span style="background-color:#FFFF00">**only one unique_ptr**</span> at a time can point to a <span style="background-color:#FFFF00">given object</span> 只能有一个指定给定对象
- <span style="color:red">The object</span> to which a ```unique_ptr``` points <span style="color:red">is destroyed when the ```unique_ptr``` is destroyed</span>
- Unlike ```shared_ptr,``` there is <span style="background-color:#FFFF00">no library function comparable to ```make_shared``` </span> that returns a ```unique_ptr```. 当定义```unique_ptr``` 时, 需要将其绑定到一个```new``` 返回的指针上
- As with ```shared_ptrs```, we must use the <span style="color:red">direct form of initialization</span>:
- <span style="background-color:#FFFF00">不能copy unique_ptr</span>, cannot assign 一个 unique_ptr 给另一个 unique_ptr
  - 虽然不能copy, 但可以调用```release```(返回当前保存的指针 并将其设为null， 切断unique_ptr和它原来管理的对象联系) or ```reset```
    - release 返回的通常用来<span style="color:red">initialize or assign 另一个smart pointer</span>
- one exception to the rule that we cannot copy a unique_ptr: We can <span style="color:red">copy or assign a unique_ptr that is about to be destroyed</span> . 最常见的例子是 when we return a unique_ptr from a function:
  - 较早版本有个```auto_ptr```, 具有unique_ptr 部分特性, 但是不能在容器中保存```auto_ptr```, 也不能返回```auto_ptr```. 虽然```auto_ptr```仍是标准库的一部分, 但程序应该使用```unique_ptr```
- Differ from shared_ptr, we must supply the deleter type inside the angle brackets for unique_ptr

unique_ptr Operations 

| Syntax | Description | 
| --- | :--- | 
| ```unique_ptr<T>u1```  | **Null** unique_ptr that can point to objects of type T. u1 will <span style="color:red">use ```delete``` to free its pointer</span>  |
| ```unique_ptr<T,D>u2``` | u2 will use a <span style="color:red">callable object of type D to free its pointer</span> | 
| ```unique_ptr<T,D>u(d)``` | **Null** unique_ptr that point to objects of type T that <span style="color:red">uses d</span>, which must be an object of type D <span style="color:red"> inplace of ```delete```</span> | 
| ```u = nullptr``` | <span style="color:red">Deletes</span> the object to which u points, <span style="color:red">makes u null</span> |
| ```T* p = u.release()``` | <span style="color:red">Relinquishes control</span> of the pointer u had held; <span style="color:red">**returns the pointer** u had held</span> and <span style="color:red">**makes u null**</span> | 
| ```u.reset()``` <br/> ```u.reset(q)``` <br/> ```u.reset(nullptr)``` | <span style="color:red">Deletes the object to which u points</span>; If the **built-in pointer** q is supplied, <span style="color:red">makes u point to that object</span>. Otherwise makes u null | 

```c++
unique_ptr<double> p1; // unique_ptr that can point at a double 

unique_ptr<int> p2(new int(42)); // p2 points to int with value 42

unique_ptr<string> p1(new string("Stegosaurus")); 
unique_ptr<string> p2(p1); // error: no copy for unique_ptr 

unique_ptr<string> p3;
p3 = p2; // error: no assign for unique_ptr

````

```nullptr``` 没有 allocate memory 不能dereference

```
unique_ptr<int>pt;
*pt = 0;//error 因为nullptr 并没有allocate memory

unique_ptr<int>pt(new int(0));
*pt = 0;
    
```
reset / release
```c++
// transfers ownership from p1 to p2 

unique_ptr<string> p2(p1.release()); // release makes p1 null

unique_ptr<string> p3(new string("Trex"));

// 将所有权从p3 转移给 q2

p2.reset(p3.release()); // reset 释放了p2原来的内存, 将p3指针所有权转移给p2 并将p3设置为空,

```


copy unique pointer from function return. 下面两个例子, compiler knows 返回的对象将要被销毁, 在此情况下, the compiler does a special kind of “copy” which we’ll discuss in § 13.6.2.

```c++
unique_ptr<int> clone(int p) {
// ok: explicitly create a unique_ptr<int> from int*

    return unique_ptr<int>(new int(p));
}

//can return a copy of local object

unique_ptr<int> clone(int p) { 
    unique_ptr<int> ret(new int (p)); 
    // . . .
    
    return ret;
}

```

deleter

```c++
// p points to an object of type objT and uses an object of type delT to free that object

// it will call an object named fcn of type delT 

unique_ptr<objT, delT> p (new objT, fcn);

void f(destination &d /* other needed parameters */)
{
    connection c = connect(&d); // open the connection 
    
    // when p is destroyed, the connection will be closed

    unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection);
    // when f exits, even if by an exception, the connection will be properly closed 
    
}
```


#### (d). weak_ptr

- A weak_ptr  is a smart pointer that <span style="background-color:#FFFF00">does not control the lifetime of the object</span> to which it points. Instead, a weak_ptr <span style="background-color:#FFFF00">points to an object that is **managed by a shared_ptr**</span>
  - <span style="color:red">Binding</span> a **weak_ptr** to a **shared_ptr** does <span style="color:red">not change the reference count</span> of that **shared_ptr**. 当最后一个指向对象的 shared_ptr 被销毁,对象就被deleted. That <span style="color:red">object will be deleted</span> even if there are<span style="color:red"> weak_ptrs pointing to it</span>—hence the name weak_ptr, which captures the idea that a weak_ptr shares its object “weakly.”
- <span style="color:red">创建weak_ptr 需要shared_ptr 来初始化</span>
- Because the <span style="color:red">object might no longer exist</span>, we <span style="color:red">cannot use a weak_ptr to access</span> its object directly. To access that object, we <span style="color:red">must call ```lock```</span>. The lock function checks whether the object to which the weak_ptr points still exists.如果存在，lock <span style="color:red">returns a shared_ptr to the shared object</span>, 也保证所指向的底层对象也会存在



| Syntax | Description | 
| --- | :--- | 
| ```weak_ptr<T>w```  |  Null weak_ptr that can point at objects of type T | 
| ```weak_ptr<T>w(sp)``` | weak_ptr that <span style="background-color:#FFFF00">points to the same object as the shared_ptr sp</span>. T must be convertible to the type to which sp points. |
| ```w = p``` | <span style="background-color:#FFFF00">**p can be shared_ptr or a weak_ptr**</span>. After the assignment w shares ownership with p | 
| ```w.reset()``` | Makes w null |
| ```w.use_count()``` | **The number of shared_ptrs** that share ownership with w | 
| ```w.expired()``` | Returns true if ```w.use_count()``` is zero, false otherwhise |
| ```w.lock()``` |  If <span style="background-color:#FFFF00">expired</span> is <span style="background-color:#FFFF00">true</span>, <span style="background-color:#FFFF00">returns a null shared_ptr</span>; <span style="background-color:#FFFF00">otherwise returns a shared_ptr to the object</span> to which w points |

注意当绑定p 到 wp, <span style="color:red">use count 不变</span>
```c++
auto p = make_shared<int>(42); 
weak_ptr<int>wp(p); // wp weakly shares with p; use count in p is unchanged

```

use ```lock```, 下面语句中np访问对象是安全的 
```c++
if ( (shared_ptr<int> np = wp.lock()) ) {   // true if np is not null

// inside the if, np shares its object with p 

}
```

应用 define a companion pointer class for our StrBlob class, 注意下面class StrBlobPtr 不能绑定到const StrBlob 对象, 因为 that <span style="color:red">the constructor takes a reference to a nonconst object</span> of type StrBlob.

```c++
class StrBlobPtr; //对于StrBlob中的友元声明来说, 前置声明是必要的

class StrBlob{//具体定义在上面的shared_ptr,这里加了个friend class

    friend class StrBlobPtr; //因为StrBlobPtr 要access StrBlob private member Data

    StrBlobPtr begin() {return StrBlobPtr(*this); }
    StrBlobPtr end() {
        auto ret =  StrBlobPtr(*this, data->size()); 
        return ret;
    }
};

class StrBlobPtr{
public:
    StrBlobPtr(): cur(0) {} 
    StrBlobPtr(StrBlob & a, size_t sz = 0): wptr(a.data), curr(sz) {}
    std::string& deref() const; 
    StrBlobPtr& incr(); //前缀递增

private:
    std::shared_ptr<std::vector<std::string>> check(std::size_t, const std::string&) const;
    //保存一个weak_ptr, 意味着底层vector可能被销毁

    std::weak_ptr<std::vector<std::string>> wptr;

    std::size_t curr; //在数组中当前位置

};

//StrBlobPtr check 与 StrBlob check不同，需要检查指针是否存在

std::shared_ptr<std::vector<std::string>> StrBlobPtr::check(
    std::size_t i, const std::string& msg) const
{
    auto ret = wptr.lock(); //vector还存在吗？

    if(!ret) throw std::runtime_error("unbound StrBlobPtr");
    if(i>=ret->size())
        throw std::out_of_range(msg);
    return ret; //返回指向vector的shared_ptr
    
}

std::string& StrBlobPtr::deref() const{
    auto p = check(curr, "deference past end");
    return (*p)[curr]; //(*p)解引用获取vector
    
}

StrBlobPtr& StrBlobPtr::incr(){
    // if curr already points past the end of the container, can't increment it 
    
    check(curr, "increment past end of StrBlobPtr"); 
    
    ++curr; // advance the current state

    return *this;
}
```


#### (e). Dynamic Arrays

- ```new``` and ```delete``` operators <span style="background-color:#FFFF00">**allocate** objects **one at time**</span> 一次只能分配释放一个
- 例如vector 和string, 有时候需要一次为很多对象分配内存. C++ 定义了两种 <span style="color:red">**an array of objects** at once</span>(一次分配一个对象数组)
    - ```new``` :
    - ```allocator``` let us <span style="color:red">**separate** allocation from initialzation</span>. Use ```allocator``` better performance and more flexible memory management
- Most applications should <span style="color:red">use a library container rather than dynamically allocated arrays</span>. Using a container is easier, <span style="color:red">less</span> likely to contain <span style="color:red">memory- management bugs</span>, and is likely to give <span style="color:red">better performance</span>.
    -  Classes that use the container 可以copy, assignment, and destruction. Classes that allocate dynamic arrays <span style="color:red">must define their own versions</span> of these operations to manage the associated memory

**(1). new and Arrays**

- ```new``` <span style="background-color:#FFFF00">**allocates** the requested number of objects</span> and (assuming the allocation succeeds) returns <span style="background-color:#FFFF00">**a pointer to the first one**</span>
  - <span style="color:red">can also use **type alias**</span> to represent an array type
- <span style="color:red">**Allocating an Array** Yields **a Pointer** to the Element Type</span>(not array type): 当我们用```new``` 来allocate 一个数组时, 并<span style="color:red">没有得到一个array type</span>. we get <span style="color:red">a pointer to the element type of the array</span>
  - 不能call ```begin```, ```end``` on a dynamic array (因为这些function use the array dimension(part of array's type) to return pointers). 同时也不能用 a range ```for``` 来process the elements in a (so-called) dynamic array
- By default, objects allocated by ```new```—whether allocated as <span style="color:red"> a single object or in an array</span>—are  <span style="background-color:#FFFF00">**default initialized**(没有default constructor 不能dynamically allocated as array)</span>. 可以对数组中元素进行**value initialization**, 方法是size后面 <span style="color:red">加一个空括号</span>
  - 新标准下, 可以provide <span style="color:red">a braced list of element initializers</span>. 如果<span style="color:red">fewer initializers</span> than elements, <span style="color:red">remaining elements are value initialized</span>.  If there are <span style="color:red">more initializers</span> than the given size, then the new expression <span style="color:red">fails and **no storage is allocated**</span>. In this case, ```new``` throws an exception of type ```bad_array_new_length```(in ```new``` header).
  - Although we can use <span style="color:red">**empty parentheses** to **value initialize**</span> the elements of an array, we <span style="color:red">cannot supply an element initializer</span> inside the parentheses. So <span style="color:red">cannot use ```auto``` to allocate an array </span>
- It Is  <span style="color:red">Legal to Dynamically **Allocate an Empty Array**</span>
  -  When we use ```new``` to allocate an array of **size zero**, <span style="color:red">new returns **a valid, nonzero pointer**</span>. That pointer is guaranteed to be <span style="color:red">distinct from any other pointer returned by ```new```</span>. 就像off-the-end pointer for a zero-element array. can use this pointer in ways that we use an off-the-end iterator
     -  The pointer <span style="color:red">**cannot be dereferenced**</span>—after all, it points to no element
- To <span style="color:red">free a dynamic array</span>, we use a special form of ```delete``` - 在指针前加上一个空方括号
    - Elements in an array are <span style="background-color:#FFFF00">destroyed in **reverse order**</span>. That is, the last element is destroyed first, then the second to last, and so on.
    - 当 ```delete``` a pointer to an array, empty bracket pair is essential: 指示compiler <span style="color:red">此指针指向一个对象数组的第一个元素</span>. <span style="color:red">如果忽略方括号 or 在删除a pointer to an object(not array)时候provide 方括号, behavior is undefined</span>.
    - The compiler is <span style="color:red">unlikely to warn</span> us if we <span style="color:red">forget the brackets when we delete a pointer to an array</span> or if we <span style="color:red">use them when we delete a pointer to an object</span>. Instead, our program is apt to misbehave without warning during execution(行为异常).

对于type alias 即使没有方括号, the compiler <span style="color:red">executes this expression using ```new[]```</span>. Compiler executes as if we write ```int *p = new int[42];```
```c++
// call get_size 确定分配多少个int

int *pia = new int[get_size()]; // pia points to the first of these ints

//type alias
typedef int arrT[42]; // arrT names the type array of 42 ints

int *p = new arrT; // allocates an array of 42 ints; p points to the first one

```

initialize

```c++
int* pia = new int[10];  //10个未初始化的int

int *pia2 = new int[10](); //10个值初始化为0的int

string *psa = new string[10];//10个空string

string *psa2 = new string[10](); // 10个空string


//可以提供braced list of initializer

//10个int 分别对应 corresponding initializer

int *pia3 = new int[10]{0,1,2,3,4,5,6,7,8,9};

// block of ten strings; the first four are initialized from the given initializers

// remaining elements are value initialized

string *psa3 = new string[10]{"a", "an", "the", string(3,'x')};
```

size zero: 对于下面的p 如果n = 0, ```p``` 可以加 0, 也可以用 ```p-p = 0``` （subtract the pointer from itself, yielding zero). for loop 条件会失败,  loop 不会执行

```c++
size_t n = get_size(); // get_size returns the number of elements needed 

int* p = new int[n]; // allocate an array to hold the elements

for (int* q = p; q != p + n; ++q)
    /* process the array */ ;
```

delete 

```c++
delete p; //p must point to a dynamically allocated object or be null

delete [] pa; // pa must point to a dynamically allocated array or be null

typedef int arrT[42];
int *p = new arrT; // allocates an array of 42 ints; p points to the first one

delete [] p; // brackets are necessary because we allocated an array

```

**(2). Smart Pointers and Dynamic Arrays**

- To use a unique_ptr to manage a dynamic array, we <span style="color:red">must include a pair of empty brackets</span> after the object type
    - when <span style="color:red">destroys</span> the pointer it manages, it will <span style="color:red">automatically use ```delete[]```</span>.
- When a ```unique_ptr``` points to an array, we <span style="color:red">cannot use the dot and arrow member access operators</span> 因为<span style="color:red">unique_ptr points to an array, not an object </span>. 
-  when a <span style="color:red">unqiue_ptr points to an array</span>, we <span style="color:red">can use the subscript operator</span> to access the elements(**return the object** not array) in the array, <span style="color:red">不能使用deference operator</span> 去access 第一个元素
- Unlike unique_ptr, <span style="color:red">shared_ptrs provide no direct support for managing a dynamic array</span>. If we want to use a shared_ptr to manage a dynamic array, we must <span style="color:red">provide our own deleter</span>
    - 如果没有提供 deleter, the code would be **undefined**: 跟我们使用动态数组, ```delete```时忘记加```[]``` 是一样的问题
- <span style="background-color:#FFFF00">no subscript operator for shared_ptrs</span>, and the smart pointer types do not support pointer arithmetic. 因此访问数组中元素必须<span style="color:red">用```get``` 获取一个**built-in pointer**</span>

unique_ptrs to Arrays

| Syntax | Description | 
| --- | :--- | 
| ```unique_ptr<T[]> u ```  | u can point to a dynamically allocated array of type T |
| ```unique_ptr<T[]> u(p) ``` | u points to the dynamically allocated array to which the **built-in pointer** p pointers. p must be convertible to ```T*``` | 
| ```u[i]``` |  <span style="color:red">**Returns the object** at position i</span> in the array that u owns. <span style="color:red">**u must point to an array**</span> | 



The brackets in the type specifier (```<int[]>```) say that up points not to an int but to an array of ints. 当销毁它的管理指针时候, 会自动call ``delete[]```
```c++
unique_ptr<int[]>up(new int[10]); //up 指向10个未初始化的int

up.release(); // automatically uses delete[] to destroy its pointer

```

```c++
for (size_t i = 0; i != 10; ++i)
    up[i] = i; // 为每个元素赋予一个新的值

```

为了使用shared_ptr 来管理动态数组, 必须提供一个动态数组
```c++
shared_ptr<int>sp(new int[10], [](int *p){delete[] p;});
sp.reset(); //uses the lambda we supplied that uses delete[] to free the array

```

shared_ptrs don't have subscript operator and don't support pointer arithmetic 
```c++
for (size_t i = 0; i != 10; ++i)
    *(sp.get() + i) = i; // use get to get a built-in pointer

```

#### (f). Allocator Class

- ```new``` combines <span style="color:red">**allocating memory with constructing object(s)**</span> in that memory. Similarly, <span style="color:red">**delete combines destruction with deallocation**</span>.  Combining initialization with allocation is usually what <span style="background-color:#FFFF00">we want when we allocate a single object</span>. 
    - 当分配一大块内存时, we often plan to construct objects in that memory <span style="color:red">as needed</span>. we’d like to <span style="color:red">decouple memory allocation from object construction</span>. means that we can allocate memory in large chunks and <span style="color:red">pay the overhead of constructing</span> the objects only when we actually <span style="color:red">need to create them</span>.


比如下面例子```new``` 分配了 n 个string, 但是可能不需要n个string, 少量就满足了, 这样可能创建了一些永远得不到的对象. 而且<span style="background-color:#FFFF00">每个元素被赋值两次</span>, 第一次在default initialized, 第二次在assign 时候
```c++
string *const p = new string[n]; // construct n empty strings
  
string s;
string *q = p; //q指向p的第一个元素

while (cin >> s && q != p +n)
    *q++ = s; //赋予一个新值

const size_t size = q - p; //记住我们读取了几个string

delete[] p; // p 指向第一个数组, 记得用delete[] 来释放

```

**Allocator**

- define in ```memory``` header, let use separate allocation from construction. It <span style="background-color:#FFFF00">provides type-aware allocation of **raw**, **unconstructed**, memory<span>.
- define **allocator**, 需要specify type. 
- When an allocator object allocates memory, it <span style="background-color:#FFFF00">**allocates memory**</span> that is <span style="background-color:#FFFF00">**appropriately sized**</span> and <span style="background-color:#FFFF00">**aligned to hold objects**</span> of the given type:
- It is an <span style="color:red">**error** to use raw memory</span> in which an object has <span style="color:red">not been constructed</span>
  - We <span style="color:red">must ```construct``` objects in order to use memory returned by allocate</span>. Using unconstructed memory in other ways is undefined.
- When we’re finished using the objects, we <span style="color:red"> must ```destroy``` the elements we constructed</span>, which we do by calling ```destroy``` on each constructed element
  - <span style="background-color:#FFFF00">只能 destroy elements that are actually **constructed**</span>.
  - 当元素被销毁, , we can either <span style="color:red">reuse the memory to hold other object</span> or <span style="color:red">return the memory to the system</span>. We free the memory by calling ```deallocate```
    - pass给```deallocate```的指针<span style="color:red">不能为空(null)</span>; it <span style="color:red">must point to memory allocated by ```allocate```(分配内存的起点)</span>. Moreover, the size argument passed to deallocate must be <span style="color:red">the same size</span> as used in the <span style="color:red">call to allocate that obtained the memory</span> to which the pointer points. 如果size少了, 不会报错，会内存泄漏

| Syntax | Description | 
| --- | :--- | 
| ```allocator<T> a ```  | Defines an ```allocator``` object named a that can allocate memory for objects of type T |
| ```a.allocate(n) ``` | <span style="background-color:#FFFF00">Allocate **raw**, **unconstructed** memory to hold n objects</span> of type T | 
| ```a.deallocate(p, n) ``` | <span style="background-color:#FFFF00">Deallocates memory that n objects</span> of type T starting at the addresss in ```T*``` pointer p; <span style="color:red">p must be a pointer previously **returned by allocate**, and n must be the **size requested** when p was created</span>. The user must <span style="color:red">run ```destory```</span> on any objects that were constructed in this memory <span style="color:red">before calling ```deallocated```</span>  | 
| ```a.construct(p, args) ``` |  <span style="background-color:#FFFF00">p</span> must be a pointer to type T that <span style="background-color:#FFFF00">**points to raw memory**</span>; args are passed to constructor for type T, which is used to construct an object in the memory pointer to by p  |
| ```a.destroy(p) ``` | Runs the destructor on object pointed to by the the ```T*``` pointer p, 需要一个一个删除 | 


下面例子分配n个未初始化的string

```c++
allocator<string>alloc; // object that can allocate strings

auto const p = alloc.allocate(n); //分配n个unconstructed strings

```

<span style="color:red">The memory an allocator allocates is **unconstructed**</span>. We use this memory by constructing objects in that memory. ```construct``` 接受0个或多个argument(must match constructor for that class) 用来initialize object. error use unconstructed memory; 用完对象后, 必须用destory 来销毁他们

```c++
auto q = p; // q will point to one past the last constructed element 

alloc.construct(q++); // *q is the empty string 

alloc.construct(q++, 10, 'c'); // *q is cccccccccc 

alloc.construct(q++, "hi"); // *q is hi!

cout << *p << endl; // ok: uses the string output operator

cout << *q << endl; // disaster: q points to unconstructed memory!


//必须删除用完的元素

while (q != p)
    alloc.destroy(--q); // free the strings we actually allocated


//free memory and return the memory to the system
alloc.deallocate(p, n);
```


**Algorithms to Copy and Fill Uninitialized Memory**
- allocator的 ```construct```只能一个一个construct, 不能批量construct, ```uninitialized_copy``` 和 ```uninitialized_fill_n``` 可以<span style="background-color:#FFFF00">批量</span>  construct
-  The <span style="background-color:#FFFF00">destination iterator</span> passed to ```uninitialized_copy``` must denote <span style="background-color:#FFFF00">**unconstructed memory**</span>.  Unlike copy, uninitialized_copy constructs elements in its destination.
-  Like ```copy```, ```uninitialized_copy``` <span style="color:red">returns its (incremented) **destination** iterator</span>. ```uninitialized_copy``` returns a pointer positioned <span style="color:red">**one element past** the last constructed element</span>.


| --- | :--- | 
| ```uninitialized_copy(b,e,b2) ```  | Copies elements from the input range denoted by iterators b and e into <span style="background-color:#FFFF00">**unconstructed, raw memory**</span> denoted by the iterator b2. The memory denoted by <span style="background-color:#FFFF00">b2 must be large enough</span> to hold a copy of the elements in the input range |
| ```uninitialized_copy_n(b,n,b2) ```  | <span style="color:red">Copies n elements starting from iterator b into **raw memory** starting at b2</span> | 
| ```uninitialized_fill(b,e,t) ```  | Constructs objects in the range of **raw memory** denoted by iterators b and e as a copy of t (从b到e 值均为tt的拷贝) |
| ```uninitialized_fill_n(b,n,t) ```  | Constructs an unsigned number n objects starting at iterator b. b must denote <span style="color:red">**unconstructed, raw memory** large enough</span> to hold the given number of objects |


分配一个比vector中元素大一倍的动态内存(allocated memory), 将原来vector中元素拷贝到前一半空间, 对后一半空间给定值进行填充
```c++
// allocate twice as many elements as vi holds

auto p = alloc.allocate(vi.size() * 2);

// construct elements starting at p as copies of elements in vi

auto q = uninitialized_copy(vi.begin(), vi.end(), p);

uninitialized_fill_n(q, vi.size(), 42);  // initialize the remaining elements to 42

```

例子： 给一个文本, 给一个单词, 打印出这个单词在文本中出现多少回，在第几行，第几行的文本

![](/img/post/C++/shared_ptr_eg.PNG)
- 设计两个class ```TextQuery``` 和 ```QueryResult```
    - 用 ```shared_ptr``` 用来传递 ```set``` (这个string 在第几行出现) 和 ```vector<string>``` (整个file 文本)  避免拷贝. 
    - ```query```是```const``` function: ```cons```t function 巧妙使用, 因为不会改变class obejct
    - ```auto &lines = wm[word];``` 用了 ```&```. ```wm[word]``` 返回lvalue reference, 但是 ```auto``` 对reference deduce 是value, 为了keep reference 加上 ```&```, 注意```lines``` 是 shared_ptr, ```if(!lines)``` 判断shared_ptr是否为空
    - ``` static shared_ptr<set<line_no>> nodata(new set<line_no>);``` 定义一个局部static 对象, 指向空的行号set 的shared_ptr，避免多次定义一样的nodata 
    - ```for (auto num : *qr.lines) ``` 解引用因为 ```qr.lines```是shared_ptr, ```*(qr.file->begin() + num)```, ```qr.file```也是shared_ptr

```c++
void runQueries(ifstream &infile){
    TextQuery tq(infile); /
    
    / iterate with the user: prompt for a word to find and print results
    while (true) {
        cout << "enter word to look for, or q to quit: "; string s;
        if (!(cin >> s) || s == "q") break;
        print(cout, tq.query(s)) << endl;
    }
}

class QueryResult; // 为了定义函数query 返回类型， 这个定义是必须的

class TextQuery {
    public:
        using line_no = std::vector<std::string>::size_type; 
        TextQuery(std::ifstream&);
        QueryResult query(const std::string&) const;
    private:
        std::shared_ptr<std::vector<std::string>> file; // input file
        
        // map of each word to the set of the lines in which that word appears 
        
        std::map<std::string,
            std::shared_ptr<std::set<line_no>>> wm;
};

TextQuery::TextQuery(ifstream &is): file(new vector<string>)
{
    string text;
    while (getline(is, text)) {
        file->push_back(text);  
        int n = file->size() - 1; //保存当前行号

        istringstream line(text);  //将文本分解为单词

        string word; 

        while (line >> word) {
            
            auto &lines = wm[word]; // lines is a shared_ptr

            if (!lines) // that pointer is null the first time we see word

                lines.reset(new set<line_no>); // allocate a new  set
                
            lines->insert(n); // insert this line number
        
        }
    }
}

class QueryResult {
    friend std::ostream& print(std::ostream&, const QueryResult&);
public:
    QueryResult(std::string s, std::shared_ptr<std::set<line_no>> p,
                std::shared_ptr<std::vector<std::string>> f):sought(s), lines(p), file(f) { }  
private: 
    std::string sought; //查询单词

    std::shared_ptr<std::set<line_no>> lines; //出现的行号

    std::shared_ptr<std::vector<std::string>> file; // input file 

};    


QueryResult TextQuery::query(const string &sought) const{
    //如果未找到sought, 将返回一个指向此set的指针

    static shared_ptr<set<line_no>> nodata(new set<line_no>); 
    //使用find 而不是下标运算 表示避免将单词添加到wm 中
    
    auto loc = wm.find(sought);
    if (loc == wm.end())
        return QueryResult(sought, nodata, file); // not found
    
    else
        return QueryResult(sought, loc->second, file);
}

string make_plural(size_t ctr, const string& word, const string& ending){
    return (ctr>1) ? word: word + ending;
}

ostream &print(ostream & os, const QueryResult &qr)
{
    os << qr.sought << " occurs " << qr.lines->size() << " "
        << make_plural(qr.lines->size(), "time", "s") << endl; 
    // print each line in which the word appeared
    
        for (auto num : *qr.lines) 
            // don't confound the user with text lines starting at 0

             os << "\t(line " << num + 1 << ") "
                 << *(qr.file->begin() + num) << endl;
    return os;
}
```

---
<br/> <br/> <br/>

## 13. Copy Control


#### (a). Copy, Assign, and Destroy

- A constructor is the copy constructor if its <span style="background-color:#FFFF00">**first parameter is a reference to the class**</span> type and any additional parameters have default values
  -  <span style="color:red">copy constructor’s own parameter must be a **reference**</span>: 否则调用永远不会成功, 因为一直自己copy 自己 parameter
  - first parameter 通常是 a reference to const
  - 通常copy constructor is not <span style="color:red">**explicit**</span>
  - When not define a copy constructor, the compiler <span style="color:red">**synthesizes**</span> one for us. Unlike the synthesized default constructor, <span style="color:red">a copy constructor is synthesized even if we define other constructors</span> 即使有其他的constructor, compiler也可能定义个copy constructor for us
- The compiler <span style="background-color:#FFFF00">copies each **nonstatic** member</span> in turn <span style="background-color:#FFFF00">from the given object into the one being created</span>. The type of each member determines how that member is copied
  - class member 是class type, 则由copy constructor for that class 进行拷贝
  - Although we cannot directly copy an array, <span style="background-color:#FFFF00">the **synthesized copy constructor** copies</span> members of <span style="background-color:#FFFF00">**array** by copying each element</span>. 如果array elements 是class type, 用class的copy constructor.
-  **copy initialization** requires either the copy constructor or the move constructor.
   -  **Copy initialization** 不仅在我们用```=```定义变量时发生, 在下面情况也发生:
       - <span style="background-color:#FFFF00">```insert``` 和 ```push``` 是**copy initialization**, whereas ```emplace``` 是 **direct initialization**</span>
       - 对于function call, <span style="color:red">**parameters** that have a **nonreference type**</span>, 对于 function return <span style="color:red">when a function has a **nonreference return type**：are **copy initialized**</span>
       - <span style="color:red">**Brace initialize**</span> the elements in an array or the members of an <span style="color:red">**aggregate class**</span>
   - 对于有<span style="color:red">**explicit**</span> 限定的constructor, <span style="color:red">不能进行类型转换的copy construct</span>. 可以进行initialization 比如:```vector<int>(10);```, 但不可以 ```vector<int>v = 10;```
   - During copy initialization(implicit type conversion), the compiler is permitted (but not obligated) to <span style="color:red">skip the copy/move constructor and create the object directly</span>(<span style="background-color:#FFFF00">不同type assignment initialization 是type conversion via 没有explicit 修饰的type conversion constructor; 相同type assignment initialization 会通过copy constructor</span>). That is, the compiler is permitted to rewrite
     - 即使忽略了copy/move constructor, 但是<span style="background-color:#FFFF00">copy/move constructor 必须exist(自己定义or compiler generated) and must be accessible (not private) in program</span>
     - 下面例子很重要, 
  
Synthesized Copy constructor 会copy array element 
```c++
struct test{
    test(const test& t){this->a = t.a;
        cout <<"in "<<t.a<<endl;;
    }
    test(int num){
        a = num;
    }
    int a;
};

class Ani{
public:
    test array[2];
    Ani(): array{test(10),test(15)}{}
};

Ani a;
Ani b = a; 
//print in 10

//print in 15 

```

```c++
string dots(10, '.'); // direct initialization 

string s(dots);  // direct initialization 

string s2 = dots;  // copy initialization 

string null_book = "9-999-99999-9"; // copy initialization 

string nines = string(100, '9'); // copy initialization

```

**Constraints on Copy Initialization**: library constructor is explicit

```c++
vector<int> v1(10); // ok: direct initialization

vector<int> v2 = 10; // error: constructor that takes a size is explicit

void f(vector<int>); // f's parameter is copy initialized

f(10); // error: can't use an explicit constructor to copy an argument

f(vector<int>(10)); // ok: directly construct a temporary vector from an int

```

**The Compiler Can Bypass the Copy Constructor**
```c++
string null_book = "9-999-99999-9"; // copy initialization into

string null_book("9-999-99999-9"); // compiler omits the copy constructor

```
- 例子一, implicit type conversion, 用的是constructor,  跳过copy/move constructor, 
  - <span style="background-color:#FFFF00">不同type assignment initialization 可以跳过copy/move constructor 直接通过constructor to create object; </span>
  -  <span style="background-color:#FFFF00">相同type assignment initialization 会通过copy constructor</span>
- 例子二: 因为copy constructor 是private(inaccessible), 不能copy
  
```c++
//case 1

struct str{
    str(const str& l){
        cout <<" goin "<<l.a<<endl;
        this->a = l.a;
    }
    str(string a){
        this->a = a;
    }
    string a;
};

string dog = "dog";
str a =dog; //call constructor

str b = a; //call copy constructor

//case 2

struct str{
    str(string a){
        this->a = a;
    }
    string a;
private:
    str(const str& l) = default
};
string dog = "dog";
str a =dog;//error cannot copy 

```

**(2).The Copy-Assignment Operator**

- To be consistent with assignment for the built-in types, <span style="background-color:#FFFF00">**assignment operators** usually **return a reference** to their left-hand operand</span>. the library generally requires that types stored in a <span style="color:red">**container** have assignment operators that **return a reference** to the left-hand operand</span>.
- the compiler <span style="color:red">generates a **synthesized copy- assignment operator**</span> for a class if the class <span style="color:red">does not define</span> its own
- <span style="background-color:#FFFF00">assigns **each nonstatic member** of the right-hand object to</span> the corresponding member of the <span style="background-color:#FFFF00">left-hand object<span style="background-color:#FFFF00"> using the copy-assignment operator for the type of that member.


**(3). Destructor**
- destructors do whatever work is needed to <span style="color:red">**free the resources** </span> used by an object and <span style="color:red">destroy the **nonstatic data members** of the object</span>
- <span style="color:red">takes no parameters, it cannot be overloaded</span>. <span style="background-color:#FFFF00">always only **one destructor** for a given class
- In a destructor, the function body is executed first and then the members are destroyed. <span style="background-color:#FFFF00">Members are destroyed in **reverse order**</span> from the order in which they <span style="background-color:#FFFF00">were initialized</span>.
- Members of class type are destroyed by running the member’s own destructor. <span style="color:red">**The built-in types(包括了smart pointer) do not have destructors**</span>, so nothing is done to destroy members of built-in type
- <span style="background-color:#FFFF00">The destructor is **not run** when a **reference or a pointer** to an object goes out of scope</span>.
- The compiler defines a <span style="color:red">**synthesized destructor**</span> for any class that does <span style="color:red">not define</span> its own destructor
    - 如果destructor 不是用来阻止对象被摧毁, the <span style="background-color:#FFFF00">**synthesized destructor**</span> has an <span style="background-color:#FFFF00">empty function body</span>.
    - Members are destroyed as part of the implicit destruction phase that follows the destructor body(<span style="color:red">在destructor 完成之后, member call 他们自己的destructor, 比如string call 自己destructor to free</span>)


**(4). The Rule of Three/Five**
-  copy / move constructor, copy / move assignment operator, destructor, 对于前四个, 如果除它外有任何一个定义了, compiler都不会synthesize， destructor 只有 当base destructor 是private 时候才不会生成. 比如 如果定义了destructor, 其他四个compiler都不会生成. 同样如果定义了 move assignment, ( copy/move constructor, copy assignment 也都不会生成), 但destructor 会生成
-  If the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.
- 当需要copy constructor时候, 也需要copy assignment operator, 反之亦然. (比如copy 是为了生成一个独一无二的序号)
- When we specify ```= default``` on the declaration of the member <span style="background-color:#FFFF00">inside the class body</span>, the synthesized function is **implicitly inline**. If do not want the synthesized member to be an inline function, we 也可以  <span style="background-color:#FFFF00">specify ```= default``` on the member’s definition</span>(在class 外面定义时声明 ```=default```)
  - We can <span style="background-color:#FFFF00">use ```= default``` only on member functions</span> that <span style="background-color:#FFFF00">**have a synthesized version**</span> (i.e., the default constructor or a copy-control member).
- **Preventing Copies** 对于不能copy 的class i.e IO class： 以免多个对象写入或者读取相同的IO缓冲
    1. Defining a Function as ```Deleted```: 
       -  Unlike ```= default```, <span style="color:red">```= delete``` must appear on the **first declaration** of a deleted function</span>, 函数第一次声明的时候就要加```=delete```, 不能像```= default```, 还可以定义在外部
       -  Unlike ```= default```(只能用于default constructor or copy-control member that the compiler can synthesize), we <span style="color:red">can specify ```= delete``` **on any function**</span>
       -  we did  <span style="color:red">not delete the destructor</span>: 因为If the destructor is deleted, then there is no way to destroy objects of that type. 同样 <span style="background-color:#FFFF00">不能create objects has a deleted destructor</span>。 If a member(member是class type, 假如有deleted destructor) of that class can’t be destroyed, the object/class as a whole can’t be destroyed.
          -  It is not possible to define an object or delete a pointer to a **dynamically allocated object** of a type with a deleted destructor(因为无法删除).
    2. **private Copy Control**:
        - 当 <span style="background-color:#FFFF00">**copy constructor** and **copy-assignment operator** are **private**</span>, <span style="color:red">user 不能 copy such objects</span>. However, <span style="color:red">**friends and members** of the class can still make copies</span>
          - 为 <span style="color:red">阻止friends and members of class still make copies</span>, 我们<span style="background-color:#FFFF00">declare these members as private but do **not define** them</span>.
        - User code 尝试copy flagged as error at **compile time**, <span style="color:red">compies made in member functions or friends(声明但不定义)</span> will result in an <span style="color:red">error at **link time**</span>

如果只定义了destructor, 而没有定义copy constructor 和 copy-assignmnet operator 是错误的. 比如下面例子, 使用了synthesized versions of the copy constructor and copy-assignment operator，造成错误是多个```HasPtr``` 指向相同的内存, 比如```ret``` 和 ```hp```, 两个对象包含same pointer value. <span style="color:red">The code will delete pointer twice, which is an **error**</span> 

```c++
class HasPtr { 
public:
    HasPtr(const std::string &s = std::string()): ps(new std::string(s)), i(0) { }
    ~HasPtr() { delete ps; }
    // WRONG: HasPtr needs a copy constructor and copy-assignment operator 

};

HasPtr f(HasPtr hp) // HasPtr passed by value, so it is copied
{
    HasPtr ret = hp; // copies the given HasPtr

    return ret; // ret and hp are destroyed

}

HasPtr p("some values");
f(p); // when f completes, the memory to which p.ps points is freed 

// 因为pass by value, value is deleted after function completed

HasPtr q(p); // now both p and q point to invalid memory!

```


在function 内部声明 ```=default``` 是inline, 如果在function 外面声明```=default``` 不是inline 
```c++
class Sales_data { 
public:
    // copy control; use defaults 
    
    Sales_data() = default;
    Sales_data(const Sales_data&) = default; 
    Sales_data& operator=(const Sales_data &); 
    ~Sales_data() = default;
    // other members as before
};

Sales_data& Sales_data::operator=(const Sales_data&) = default;
```

阻止拷贝:
```c++
struct NoCopy {
    NoCopy() = default; // use the synthesized default constructor 

    NoCopy(const NoCopy&) = delete; // no copy
    
    NoCopy &operator=(const NoCopy&) = delete; // no assignment 
    
    ~NoCopy() = default; // use the synthesized destructor

};
```

destructor 是 deleted,  
```c++
struct NoDtor {
    NoDtor() = default; // use the synthesized default constructor

    ~NoDtor() = delete; // we can't destroy objects of type NoDtor 

};
NoDtor nd; // error: NoDtor destructor is deleted

NoDtor *p = new NoDtor(); // ok: but we can't delete p 

delete p; // error: NoDtor destructor is deleted

```

**The Copy-Control Members May Be Synthesized as Deleted** (deleted or inacessble : DI):
- The <span style="background-color:#FFFF00">**synthesized destructor**</span> is defined as <span style="background-color:#FFFF00">**deleted**</span> if <span style="color:red">data member 的 class 的**destructor** is **DI**</span> 
- The <span style="background-color:#FFFF00">**synthesized copy constructor**</span> is defined as <span style="background-color:#FFFF00">**deleted**</span> if 有class <span style="color:red">member的**copy constructor**</span> DI or class 有<span style="color:red">member 有DI **destructor**</span>, <span style="background-color:#FFFF00">如果有**const, reference** 可以copy-construct</span>, 因为与copy的对象, reference 与其shared 一个对象, const 也会生成在constructor, 但是必须提供non-default constructor
- The <span style="background-color:#FFFF00">**synthesized copy-assignment operator**</span> is defined as <span style="background-color:#FFFF00">**deleted**</span>: 如果member 是 <span style="color:red">DI copy-assignment operator</span>, or <span style="color:red">class has **const or reference** member</span>
- The <span style="background-color:#FFFF00">**synthesized default constructor**</span> is defined as <span style="background-color:#FFFF00">**deleted**</span> if <span style="color:red">member has DI destructor</span>(创建的对象无法删除, 不可以的), or <span style="color:red">**reference member** 没有in-class initializer</span>, or **const member** 的type <span style="color:red">没有explicitly define a default constructor</span>(比如自己定义的类) and <span style="color:red">没有in class initializer</span>

总结上面的:
-  <span style="color:red">揭示道理是: 如果class有member 不能default constructed, copied, assigned, or destoryed 则class对应的function也是deleted</span>
- 如果有const成员, 不能改变值, reference 成员不能改变绑定对象, 则不能使用synthesized copy-assignment operator.
- 本质上, 如果有member 不能copy, assign, destory, 则class 也不会生成相应copy-control members

下面例子copy constructed ok的, 但是要提供non-default constructor
```c++
class Ani{
public:
    Ani(int a_): a(a_){}
    int &a;
};

Ani a(5);
Ani b(a);
```

#### (b). Copy Control and Resource Management

- copy like a value: copy and original 是独立的，改变一个不会影响另一个
- copy like a pointer: copy and original use the same underlying data. 改变一个影响另一个

**(1). Classes That Act Like Values**

下面例子 
- <span style="color:red">**dynamically allocates** its own copy of that string</span> and stores a pointer to that string in ps.
- <span style="background-color:#FFFF00">**Assignment operators** typically combine the actions of the **destructor and the copy constructor**</span>. 顺序很重要
    1. 像destructor, 先destroys the left-hand operand's resouces
    2. 像copy constructor, assignment copies data from the right-hand operand.
- Moreover, when possible, **we should also write our assignment operators** so that 让left-hand operands 是有意义(sensible)的状态当发生异常时


```c++
class HasPtr { 
public:
    HasPtr(const std::string &s = std::string()): 
        ps(new std::string(s)), i(0) { }
    HasPtr(const HasPtr &p):
        ps(new std::string(*p.ps)), i(p.i) { } 
    
    HasPtr& operator=(const HasPtr &);
    ~HasPtr() { delete ps; }
private:
    std::string *ps;
    int i;
};

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
    auto newp = new string(*rhs.ps); // copy the underlying string
    
    delete ps;  // free the old memory

    ps = newp; // copy data from rhs into this object

    i = rhs.i;  // return this object
    
    return *this;
}
```

Key Concept: Assignment Operators
- <span style="background-color:#FFFF00">**Assignment operators** must work correctly </span> if an object is <span style="color:red">**assigned to itself**</span>.
- Most <span style="background-color:#FFFF00">**assignment operators** share work with the **destructor** and **copy constructor**</span>
- copy assignment 最后返回reference, 否则如果return value, 需要call copy constructor 还有call destructor to destory temporary value 
- Good Pattern: 
    1. copy right-hand operand into a local temporary.
    2. step1 完成后, safe to destory existing member of left-hand operand. 
    3. copy the date from temporary into members of left-hand operand. 

bad example, 如果是自己拷贝到自己, 把underlying object就给删除了, 最后访问一个无效的指针, What happens is <span style="color:red">**undefined**</span>.
```c++
HasPtr&
HasPtr::operator=(const HasPtr &rhs)
{
    delete ps; // frees the string to which this object points

    // if rhs and *this are the same object, we're copying from deleted memory!

    ps = new string(*(rhs.ps)); 
    i = rhs.i;
    return *this;
}
```

**(1). Classes That Act Like Pointers**

- <span style="color:red">需要copy constructor and copy- assignment operator to **copy the pointer member**</span>,而不是copy pointer 指的值
- 需要free memory when 最后一个指向的对象被销毁时
- Easiest way is use ```shared_ptr``` to manage the resource(会referen count, track有多少个uses sharing th pointed-to object)
- 如果自己创建reference count, 问题是where to put reference count, 比如下面例子, if store in object的话, 也许不能update correctly. 解决方法是<span style="background-color:#FFFF00">**store the counter in dynamic memory**</span>
    - When we copy or assign an object, we’ll copy the pointer to the counter. That way the copy and the original will point to **the same counter**.

当把p1 给 p3, 递增p1的计数器, 但是却没法递增p2的计数器
```c++
HasPtr p1("Hiya!");
HasPtr p2(p1); // p1 and p2 point to the same string 

HasPtr p3(p1); // p1, p2, and p3 all point to the same string

```

Reference counting works as follows: 
1. 每一个constructor (copy constructor 除外) creates a counter.<span style="color:red">记录多少个objects share state</span> with the object we are creating. When we create an object， initialize the counter as 1
2. copy constructor not allocate a new counter; copies the data members of its given object, including the counter 并 递增reference counter
3. destructor 递减counter, 如果count 变成0, destructor deletes that state
4. copy assignment 递减左侧对象的counter, 递增右侧对象的counter, 如果left-hand operand goes to zero. destory the state of left-hand operand. <span style="background-color:#FFFF00">通过先增加右侧, 再减少左侧的counter</span>, 这样子保证不会先在左侧reference count等于0时 free memory

e.g. reference count. 注意
- 意destructor 不能随便删除, 只有counter go to zero, then free the memory of both ```ps``` and ```use``` point. 
- copy assignment operator 增加右侧运算对象计数器, 减少左侧对象计数器, 如果左侧计数器等于0，delete/free memory. 而且要能handle self-assignment.

下面是很好的例子, 注意什么时候删除pointer

```c++
class HasPtr { 
public:
    // constructor allocates a new string and a new counter, which it sets to 1 
    
    HasPtr(const std::string &s = std::string()):
        ps(new std::string(s)), i(0), use(new std::size_t(1)) {}

    // copy constructor copies all three data members and 递增计数器
    
    HasPtr(const HasPtr &p):
        ps(p.ps), i(p.i), use(p.use) { ++*use; } 
    
    HasPtr& operator=(const HasPtr&);
    ~HasPtr();
private:
    std::string *ps;
    int i; 
    std::size_t *use;//reference counter
     
    // member to keep track of how many objects share *ps

};

//destructor 

HasPtr::~HasPtr()
{ 
    if (--*use == 0) { 
        //delete string and reference counter

        delete ps;  
        delete use; 
    }
}

HasPtr& HasPtr::operator=(const HasPtr &rhs)
{
    ++*rhs.use; // increment the use count of the right-hand operand

    if (--*use == 0) { // then decrement this object's counter
    
        // free this object's allocated members

        delete ps; 
        delete use;
    }
    ps = rhs.ps; 
    i = rhs.i; 
    use = rhs.use; 
    return *this;
}
```


#### (c). Swap

- swap is important, 对于algorithm that reorder elements. Such algorithms call ```swap``` whenever they need to exchange two elements.
    - If a class 定义了自己 ```swap```, then the algorithm uses that class-specific version. Otherwise, use ```swap``` defined by the library. 
- In principle, <span style="color:red">none of this memory allocation is necessary</span> for pointer.


```swap``` 通常involves a copy(**copy constructor**) and two assignment(**assignment operator**). 
```c++
HasPtr temp = v1; // copy constructor

//assignment operator

v1 v1 = v2; 
v2 = temp; 

//pointer 

string *temp = v1.ps; // copy constructor

//assignment operator

v1.ps = v2.ps;
v2.ps = temp;
```

**(1).Write own swap function**

- override the default behavior of ```swap``` by defining a version of swap that operates on our class.
- **declaring** ```swap``` as a **friend**</span> to give it access to HasPtr’s (private) data members.
- <span style="background-color:#FFFF00">**optimize**</span> our code, we’ve <span style="color:red">defined swap as an **inline**</span> function
- <span style="color:red">Unlike the copy-control members, <span style="background-color:#FFFF00">```swap```</span> is never necessary. However, defining swap can be an important optimization for classes that allocate resources.
- if a class has a member that <span style="color:red">has its own type-specific ```swap``` function, calling ```std::swap``` would be a mistake</span>.
  - 下面例子有正确的使用方法: <span style="background-color:#FFFF00">type-specific version of swap 是better match than std</span>. 因此当没有type-specific version of swap, then—assuming there is <span style="color:red">a **using declaration** for swap</span> in scope—calls to swap will <span style="color:red">use the version in ```std```</span>.
  
```c++
class HasPtr {
    friend void swap(HasPtr&, HasPtr&);
    // other members as before

};

inline void swap(HasPtr &lhs, HasPtr &rhs) {
    using std::swap;
    swap(lhs.ps, rhs.ps); // swap the pointers, not the string data 
    
    swap(lhs.i, rhs.i); // call std::swap, 因为built-in 么有type-specific version
    
}
```
如果有自己member 的swap, 用```std::swap```是mistake(不会报错), 如果Foo has type ```HasPtr```, the library ```swap``` makes unnecessary copies of the strings managed by ```HasPtr```. 下面例子中为什么```swap``` not hid declaraction for the ```HasPtr```的```swap```, 在18.2.3中讲解
```c++
void swap(Foo &lhs, Foo &rhs)
{
    // WRONG: this function uses the library version of swap, not the HasPtr version

    std::swap(lhs.h, rhs.h);

    // swap other members of type Foo
}

//正确方式

void swap(Foo &lhs, Foo &rhs)
{
    using std::swap;//表示只有当没有type-specific swap时候,才会用std::swap的

    std::swap(lhs.h, rhs.h); //uses the HasPtr version of swap

    // swap other members of type Foo
    
}
```

**(2).Using swap in Assignment Operators**
- Classes that define swap often use ```swap``` to define their assignment operator. These operators use a technique known as **copy and swap**. 把右侧对象swap给左侧
- 注意<span style="color:red">右侧对象是**pass by value**</span> which means copy constructor 
- Assignment operators that use copy and swap are <span style="background-color:#FFFF00">automatically exception safe and correctly handle self-assignment</span>. 

例子中 
- the parameter is not a reference, pass right-hand operand by value.  Copying a ```HasPtr``` <span style="color:red">allocates a new copy</span> of that object’s string. 
- 当assignment operator 完成后,  <span style="color:red">```rhs``` is **destroyed**</span> and the ```HasPtr``` destructor is run
- 是自动handle self-assignment and exception safe. 
  - copy right-hand operand before changing left-hand operand, it handles self assignment in the same was as we did in our original copy constructor
  - 唯一可能报错是copy constructor, 如果有exception occurs,it will happen before we change left-hand operand.

```c++
// note rhs is passed by value, which means the HasPtr copy constructor 

// copies the string in the right-hand operand into rhs

HasPtr& HasPtr::operator=(HasPtr rhs)
{
    // 交换左侧对象和local varaible rhs

    swap(*this, rhs); // rhs now points to the memory this object had used
    
    return *this; // rhs is destroyed, which deletes the pointer in rhs

}
```

#### (d). Classes That Manage Dynamic Memory

- Some classes need to allocate a varying amount of storage at **run time**

**StrVec Class Design**:类似于vector, add elements时候看有没有足够space, 有的话直接construct an object in next available sport, 没有的话, <span style="color:red">vector is reallocated</span>(obtains new space, moves the existing elements into that space, frees the old space, and adds the new element)
- use an **allocator** to obtain raw memory
- 因为```allocator``` 获得内存时raw/unconstructed memory, use **allocator**'s ```construct``` member to create objects. 当remove 时候用 **allocator** 的```destory```
- 每一个StrVec 有三个pointer 
    - ```elements```, points to first element in the allocated memory 
    - ```first_free```, points just after the last actual element 
    - ```cap```, points just past the end of the allocated memory 
- 还有个member named ```allocator<string> alloc``` . ```alloc``` will allocate the memory used by a ```StrVec```. 
- 有四个ultility functions: 
    1. ```alloc_n_copy``` will allocate space and copy a given range of elements.
    2. ```free``` will destroy the constructed elements and deallocate the space.
    3. ```chk_n_alloc``` will ensure that there is room to add at least one more element to StrVec,如果没有足够空间, call ```reallocate```
    4. ```reallocate``` will reallocate the StrVec when it runs out of space.


下面code
- allocator allocate是raw/unconstructed memory, 必须call ```construct``` 去construct an object in that memory, ```construct``` 会用到```first_free``` 并递增```first_free```(递增得到next, unconstructed element)
- ```uninitialized_copy``` <span style="background-color:#FFFF00">返回时一个指针 指向one element past the last constructed element</span>
- Moving, Not Copying, Elements during Reallocation. Before 写 reallocate, function 应该做:
    1.  Allocate memory for a new, larger array of strings
    2. Construct the first part of that space to hold the existing elements
    3. Destroy the elements in the existing memory and deallocate that memory

copy string 是<span style="background-color:#FFFF00">**value like**</span>, 改变一个不会影响另一个. 所以copy a string肯定会allocate memory for those characters and destory a string 肯定会free memory used by string. <span style="color:red">Perfomance will be much better by avoid overhead of allocating and deallocating string 当reallocate</span>

**Move Constructor and std::move**

- 有一些class(包括string) 都定义了 move constructor. 可以想象每个string 都有一个a pointer to an char array. <span style="color:red">string的move constructor copies pointer 而不是 allocating space for and copying the chars</span>
- 是将resource move(而不是拷贝) from given object to 正在创建的对象(<span style="color:red">**take ownership**</span>). <span style="background-color:#FFFF00">用于 **reallocate** 时候</span>
- move constructor 保证移后源(moved-from) 仍然保持一个valid, destructible state.
- ```move``` 定义在 ```utility``` header, 使用move 不需要provide a ```using``` declaration (将在18.2.3中讲到), 使用move 直接call的是 ```std::move```not ```move```
- 下面code中的```reallocate```在```move```完成之后, 不知道旧的```StrVec```内存中 string 是什么值, 但<span style="color:red">保证对他们执行string destructor is safe</span>

```c++
class StrVec{
public:
    StrVec(): // the allocator member is default initialized 

        elements(nullptr), first_free(nullptr), cap(nullptr) {}
    StrVec(const StrVec&); 
    StrVec &operator=(const StrVec&);
    ~StrVec(); 
    void push_back(const std::string&); 
    size_t size() const { return first_free - elements; } 
    size_t capacity() const { return cap - elements; } 
    std::string *begin() const { return elements; } 
    std::string *end() const { return first_free; }

private:
    std::allocator<std::string> alloc; // allocates the elements 
    
    // used by the functions that add elements to the StrVec

    void chk_n_alloc()
    { if (size() == capacity()) reallocate(); }
    
    //used by the copy constructor, assignment operator, and destructor 

    std::pair<std::string*, std::string*> alloc_n_copy
            (const std::string*, const std::string*);
    void free();
    void reallocate();
    std::string *elements;//指向数组的首元素

    std::string *first_free;//指向数组第一个空闲元素指针

    std::string *cap; //指向数组尾后指针

};

void StrVec::push_back(const string& s){
    chk_n_alloc(); // ensure that there is room for another element 

    // construct a copy of s in the element to which first_free points 
    
    alloc.construct(first_free++, s);
}

std::pair<std::string*, std::string*> alloc_n_copy
            (const std::string* b, const std::string* e){
    auto data = alloc.allocate(e-b);            
    //返回the start of the allocated memory and value return from uninitialized_copy 

    //uninitialized_copy 返回时一个指针 指向one element past the last constructed element

    return {data, uninitialized_copy(b,e,data)};
}

void StrVec::free(){
    //不能传递一个空指针 
    
    if (elements) {
        // destroy the old elements in reverse order
    
        for (auto p = first_free; p != elements; /* empty */)
            alloc.destroy(--p); 
        }
        alloc.deallocate(elements, cap - elements);
    }
}

StrVec::StrVec(const StrVec &s)
{
    // call alloc_n_copy to allocate exactly as many elements as in s
    
    auto newdata = alloc_n_copy(s.begin(), s.end()); 
    elements = newdata.first;
    first_free = cap = newdata.second;
}

StrVec::~StrVec() { free(); }

StrVec &StrVec::operator=(const StrVec &rhs)
{
    // call alloc_n_copy to allocate exactly as many elements as in rhs
    
    auto data = alloc_n_copy(rhs.begin(), rhs.end());
    free();
    elements = data.first;
    first_free = cap = data.second;
    return *this;
}

void StrVec::reallocate(){
    //将分配当前大小两倍的内存空间

    auto newcapacity = size() ? 2 * size() : 1;
    //分配新内存

    auto newdata = alloc.allocate(newcapacity);

    auto dest = newdata; // points to the next free position in the new array

    auto elem = elements; //points to the next element in old array 

    for(size_t i = 0; i!=size(); ++i)
        alloc.construct(dest++, std::move(*elem++));
        //will take over ownership of the memory from the string to which elem points.


    free(); //一旦移动完元素就释放旧内存空间

    // We don’t know what value the strings in the old StrVec memory have,
    
    // but we are guaranteed that it is safe to run the string destructor on these objects.

    //更新数据结构

    elements = newdata; 
    first_free = dest;
    cap = elements + newcapacity;
}

```



#### (e). Rvalue References

- An <span style="color:red">**rvalue reference**</span> is a reference that must be <span style="color:red">bound</span> to an <span style="color:red">**rvalue**</span>.
- important property: that rvalue reference <span style="color:red">只能 bound to an object that is about to be **destroyed**</span>
    - 因此可以自由将rvalue reference 移动到另一个对象中
- an <span style="background-color:#FFFF00">**lvalue**</span> expression refers to an object’s <span style="background-color:#FFFF00">**identity**</span> whereas an <span style="background-color:#FFFF00">**rvalue**</span> expression refers to an <span style="background-color:#FFFF00">object’s **value**</span>
- <span style="background-color:#FFFF00">rvalue reference 只能接 rvalue </span>
- <span style="background-color:#FFFF00">**r-value reference <-X-  lvalue**</span>:  <span style="color:red">can bind an **rvalue reference** to 要求conversion的expression,to literals, 或者返回 rvalue 的 expression, 但lvalue reference(不算const) 不能绑定到这些表达式; 反过来 但是 **rvalue-reference**不能绑定到一个**lvalue**</span>
- <span style="background-color:#FFFF00">**rvalue-reference <-X- rvalue reference**</span> <span style="color:red">不能绑定  **rvalue reference**</span> to a variable defined as an <span style="color:red">**rvalue reference**</span> type.
- <span style="background-color:#FFFF00">**lvalue-reference <-x- rvalue**</span> 
不可以比如```int & r = i*42; ```

例子:
- return lvalues 表达式的例子: along with the <span style="color:red">assignment, subscript, dereference, and **prefix** increment/decrement operators</span>
- Functions that **return a nonreference type**, along with the <span style="color:red">arithmetic, relational(true/false), bitwise, and **postfix** increment/decrement operators, all yield **rvalues**</span>

```c++
int i = 42;  //ok

int &r = i;  //ok

int &&rr = i; lvalue  // error: cannot bind an rvalue reference to an lvalue

int &r2 = i * 42; // error: i * 42 is an rvalue

const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue

int &&rr2 = i * 42; // ok: bind rr2 to the result of the multiplication

//不能把r-value reference 绑定到 r-value reference 

int &&rr1 = 42; // ok: literals are rvalues

int &&rr2 = rr1; // error: the expression rr1 is an lvalue!

```

**Lvalues Persist; Rvalues Are Ephemeral**

-  **Lvalues** have persistent state, whereas rvalues are either **literals** or **temporary objects** created in the course of evaluating expressions.
    - Variables Are **Lvalues**
-  **rvalue** references can only be bound to **temporaries**, we know that 
    - <span style="color:red">The referred-to object is about to be **destroyed**</span>
    - <span style="color:red">There can be no other users of that object </span>
- 从上面一条, 所以rvalue reference 可以自由接管所引用对象自愿



**The Library move Function**

- 尽管不能直接把rvalue reference 绑定到 lvalue, 但<span style="background-color:#FFFF00">可以 cast lvalue to rvalue reference type by use ```std`::move```</span>
- ```move``` 告诉compiler 我们有个lvalue, 但想让对待rvalue 一样处理它.
- We can <span style="color:red">**destroy**</span> a moved-from object and can <span style="color:red">**assign** a new value</span> to it, <span style="color:red">but we cannot use the value of a moved-from object</span>.
- 不用using declaraction for ```move```, 因为我们调用 ```std::move``` 而不是 ```move```, 原因将在18.2.3中讲到

```c++
int &&rr1 = 42; 

int &&rr3 = std::move(rr1);

```

---

- moving, rather than copying, the object can <span style="background-color:#FFFF00">provide a significant performance boost</span>
- A second reason to move rather than copy occurs in classes such as the <span style="background-color:#FFFF00">**IO** or **unique_ptr**</span> classes. 这些class <span style="color:red"> resources 不能shared. 因此objects of these types 不能被copies 但可以move </span>

---


#### (f). Move Constructor and Move Assignment

**(1). Move Constructor**

-  **move constructor**:  the reference parameter in the  is an <span style="background-color:#FFFF00">**rvalue reference**</span>, 像copy constructor, <span style="color:red">**any additional parameters** must all have **default** arguments</span>.
 -  除了move resources, move constructor must **ensure** that <span style="color:red">destroying moved- from object(移后源) will be harmless </span>.  original object must no longer point to those moved resources. <span style="color:red">responsibiles 转移给了newly created object</span>
- 因为<span style="background-color:#FFFF00">move operation 不allocate any resources</span>, 所以通常<span style="color:red">不会throw exception</span>. 如果不告诉compiler 它不会throw exception, compiler也许会做extra work to cater to the possibility that也许throw
  - specify ```noexcept``` on move constructor, 是<span style="color:red">promise that a function does **not throw** any exceptions</span>.   specify noexcept on a function after its **parameter list**. 在parameter list 内在**constructor initializer list**前面
  - 必须specify ```noexcept``` both on <span style="color:red">**declaration** in class header</span> 和 <span style="color:red">**definition** outside class</span>
  - <span style="background-color:#FFFF00">**Move constructors**</span> and <span style="background-color:#FFFF00">**move assignment operators**</span> that cannot throw exceptions should be marked as <span style="background-color:#FFFF00">**noexcept**</span>.
- move operation 不throw exception 基于两个事实: 
  1. 虽然move operations 不抛出异常，但<span style="color:red">抛出异常是被允许的</span>
  2. library containers 自身提供保障当异常发生, 比如vector ```push_back``` 有exception, vector itself 是unchanged 



noexcept
```c++
class StrVec { 
public:
    StrVec(StrVec&&) noexcept; //move constructor

};

StrVec::StrVec(StrVec &&s) noexcept : /* member initializers */
 { /* constructor body */ }
```



例子中move constructor 没有allocate new memory. take over memory in given ```StrVec```, 在take over memory 之后, constructor body sets pointers to ```nullptr```. 之后moved-fom object 会被destoryed by calling destructor (会deallocate ```first_free```. <span style="color:red">如果我们忘记assign ```s.first_free``` to ```nulltpr```, 会deleted memory we just moved</span>)
```c++
StrVec::StrVec(StrVec &&s) noexcept // move won't throw any exceptions

// member initializers take over the resources in s

: elements(s.elements), first_free(s.first_free),
{
    // leave s in a state in which it is safe to run the destructor

    s.elements = s.first_free = s.cap = nullptr;
}
```


可能出现的问题: 比如在reallocate(move elements from old space to new memory) 过程中发生异常. If reallocation 使用move constructor throw exception 在移动了部分而不是全部元素后。问题就产生了: <span style="color:red">旧空间中的移动元素已经改变，而新空间中的unconsturcted elements 可能尚不存在</span>, vector满足不了 当有exception 自身unchanged 性质. 所以这种情况下, <span style="background-color:#FFFF00">vector 会使用copy constructor</span>: 如果exception 发生, elements are constructe in new memory, old elements remain unchanaged. <span style="color:red">如果exception 发生, vector free the space it allocated and return. 原始的vector elements still exist. 为了避免这种潜在问题, vector使用move constructor 而不是copy constructor 除非知道move constructor cannot throw an excetpion. tell compiler safe to use during reallocation. 必须explicitly tell library that our <span style="color:red">move constructor safe to use by marking ```noexcept```</span>



**(2). Move Assignment**
- 像move constructor, if <span style="color:red">**move-assignment operator** won’t throw any exceptions</span>, we should make it <span style="color:red">```noexcept```</span>.  Like a copy-assignment operator, a move-assignment operator must guard against self-assignment
- As in any other assignment operator, it is crucial that we <span style="color:red">在使用右侧运算对象之前，不能释放左侧运算对象的资源 (可能是相同资源)</span>.
- After a **move operation**, 需要确保“moved-from” object must remain a valid, destructible object(可以run destructor) but users may <span style="color:red">make no assumptions about its value</span>.    
  - ```StrVec``` move operations meet this requirement <span style="background-color:#FFFF00">by **setting the pointer members of the moved-from object to ```nullptr```**</span>
  - valid 表示可以依然为其赋予新值, 可以安全使用不依赖其结果,比如```string```当移后, remain valid, 可以run operations such as ```empty``` or ```size``` on moved-from objects. 可是不知道会得到什么结果. 

例子中 we do check self-assignment. <span style="color:red">因为calling```move``` 可以让rvalue 作为右侧运算符</span>,

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
    // 直接检测self-assignment

    if (this != &rhs) {
        free(); // free existing elements 
        
        elements = rhs.elements; // take over resources from rhs
        
        first_free = rhs.first_free; 
        cap = rhs.cap;
        // leave rhs in a destructible state

        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    } 
    return *this;
}
```
**(3). Synthesized Move Operations**

-  if a class <span style="color:red">defines its own copy constructor, copy-assignment operator, or destructor</span>, the <span style="color:red">**move constructor** and **move- assignment** operator are not synthesized</span>
- when a class <span style="color:red">doesn’t have a move operation</span>, the corresponding <span style="color:red">**copy** operation is used in place of move</span> through normal function matching
- The compiler will <span style="color:red">synthesize a move constructor or a move-assignment operator </span> only if the class <span style="background-color:#FFFF00">doesn’t define any of its own **copy-control members**</span> and if every <span style="color:red">nonstatic data member</span> of the class <span style="color:red">can be moved</span>.
    - can move built-in type 
    - can move member of a class type 如果该class 定义了 move operation 
- <span style="background-color:#FFFF00">**move operation** is never implicitly defined as a ```deleted``` function</span>. 但是如果我们explicit ask compiler to gerenerate a move operation by using ```=default```, compiler unable to move member, then move operation 被定义成 ```deleted```. 除了一个important exception, rules for when a synthesized move operation 被定义成 ```deleted``` 跟 copy operation 类似的原则: (deleted or inaccessible as **DI**)
    -   Unlike the copy constructor, the <span style="background-color:#FFFF00">**move constructor** is defined as ```deleted```</span> 如果class <span style="color:red">有member defines own copy constructor</span> 但是没有定义 move constructor, 或者 class member 的 class 没有定义copy constructor 并且<span style="color:red">compiler 不能sythesize a move constructor</span> (对move-assignment 同理) 
    - The <span style="color:red">**move constructor**</span> or <span style="color:red">**move-assignment operator**</span> is defined as <span style="color:red">**deleted**</span>, 如果class memmber 的class <span style="color:red">有move constructor or move assignment 是DI的</span>
    - Like the copy constructor, the <span style="color:red">**move constructor** is defined as deleted if the destructor is DI</span>.
    - Like the copy-assignment operator, <span style="color:red">**move-assignment operator** 定义成 **deleted** 如果 class 有 const or reference member </span>
    - <span style="background-color:#FFFF00">如果class 定义了move constructor or move assigment operator, 则他的copy constructor 和 copy-assignment operator for that class 都被定义成了 deleted</span> 
- class 定义了move constructor and move-assignment operator 应该avoid overhead 由copy resource 产生的. 一般说如果定义了一个copy-control members, 就应该定义所有5个操作(copy constructor, copy/move constructor, copy/move assignment operator)


```c++
// the compiler will synthesize the move operations for X and hasX 

struct X {
    int i; // built-in types can be moved s
    
    td::string s; // string defines its own move operations

};
struct hasX {
    X mem; // X has synthesized move operations 

};

X x, x2 = std::move(x); // uses the synthesized move constructor hasX hx, 

hasX hx, hx2 = std::move(hx); // uses the synthesized move constructor
```

比如下面例子, 定义了copy constructor 没有定义move constructor, 因为忽略了move contructor的declaration, compiler 不能generate move constructor. 
```c++
// assume Y is a class that defines its own copy constructor but not a move constructor

struct hasY {
    hasY() = default;
    hasY(hasY&) = default;
    Y mem; // hasY will have a deleted move constructor

};
hasY hy, hy2 = std::move(hy); // error: move constructor is deleted

//error 原因是 hasY & lvalue reference, 不接受rvalue

struct hasY {
    hasY() = default;
    hasY(const hasY& y) {
 	cout << "int copy constructor" <<endl;
    }
    Y mem;
 };
 hasY hy, hy2 = std::move(hy);//ok, print: in copy constructor
 
 //因为const reference 接受rvalue 
 
```


-  When a class has both a **move constructor** and a **copy constructor**, the compiler uses ordinary function matching to determine which constructor to use
    - rvalue will call move constructor, 因为move constructor is better match 不用conversion
    - 如果没有move constructor, will call copy constructor 
- If a class has a <span style="color:red">**usable** copy constructor and no **move constructor**</span>, objects will be <span style="color:red">“moved” by the copy constructor</span>. Similarly for the <span style="color:red">copy-assignment operator and move-assignment</span>(如果没有move assignment 用copy-assignment).

第一个例子, v2是lvalue, 使用copy-assignment operator(因为对于move assignment operator <span style="background-color:#FFFF00">不能bind rvalue reference to an lvalue</span>). 第二个例子, ```getVec``` 返回时rvalue, 赋值是move-assignment operator. assign rvalue (实际上viable for both move-assignment and copy assignment. 但是<span style="background-color:#FFFF00">calling copy assignment 需要conversion to ```const```</span>, whereas ```StrVec&&``` is exact match )

```c++
StrVec v1, v2;
v1 = v2; // v2 is an lvalue; copy assignment

StrVec getVec(istream &); // function getVec returns an rvalue

v2 = getVec(cin); // getVec(cin) is an rvalue; move assignment

```

下面例子call copy constructor, 因为没有move constructor available 
```c++
class Foo {
public:
    Foo() = default;
    Foo(const Foo&); // copy constructor

// other members, but Foo does not define a move constructor

};
Foo x;
Foo y(x); //copy constructor; x is an lvalue 

Foo z(std::move(x)); //copy constructor, 因为没有available move constructor 

//can convert Foo&& to const Foo&

```

- **Move constructor** 设置pointer to zero, to ensure that it is safe to destory moved-from object. function 不会throw exception, 因此mark as ```noexcept```
- Assignment operator 的parameter has a nonreference parameter, which means the parameter is **copy initialized**: <span style="background-color:#FFFF00">**lvalue are copies and rvalue are moved**</span>. 因此 <span style="color:red">single assignment operator</span> acts as both the <span style="color:red"> **copy-assignment** and **move- assignment** operator</span>
  - Regardless of whether the copy or move constructor was used, the body of the assignment operator <span style="color:red"> **swaps** the state of the two operands</span>.

```c++
class HasPtr { 
public:
    // added move constructor
    
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}

    // assignment operator is both the move- and copy-assignment operator 

    HasPtr& operator=(HasPtr rhs)
        { swap(*this, rhs); return *this; } 
};

hp = hp2; // hp2 is an lvalue; copy constructor used to copy 

hp2 hp = std::move(hp2); // move constructor moves hp2

```

用**rvalue reference** call pointer ```&```
```c++
Message::Message(Message &&m): contents(std::move(m.contents)) 
//move constructor 

{
    move_Folders(&m); // moves folders and updates the Folder pointers
    
}

Message& Message::operator=(Message &&rhs)
{
    if (this != &rhs) { // direct check for self-assignment

        remove_from_Folders(); //用于销毁左侧运算对象的旧状态

        contents = std::move(rhs.contents); // move assignment

        move_Folders(&rhs); // reset the Folders to point to this Message

    } 
    return *this;
}
```

**(4). Move Iterators**

- Ordinarily, <span style="color:red">an **iterator** dereference operator returns an **lvalue** reference</span> to the element. Unlike other iterators, <span style="color:red">the dereference operator of a **move iterator** yields an **rvalue** reference</span>.
- transform an ordinary iterator to a move iterator by calling the library ```make_move_iterator``` function
- <span style="color:red">library makes **no guarantees** about which algorithms can be used with move iterators</span> and which cannot. 只有确信当在算法运行完 不再访问它时(在用它为其他的赋值, 或者pass给user的function), 才能pass move iterator
- 如果小心使用```move``` 可以大幅度提高性能, 如果随意在普通用户代码中使用```move```, 很可能导致难以查找的错误, 而难以提高性能

下面例子用到 **move iteartors**, dereference operator yields an **rvalue** reference, construct will use the **move constructor** to construct the elements


```c++
void StrVec::reallocate()
{
    // allocate space for twice as many elements as the current size

    auto newcapacity = size() ? 2 * size() : 1;
     auto first = alloc.allocate(newcapacity);
    // move the elements 
    
    auto last = uninitialized_copy(make_move_iterator(begin()), 
        make_move_iterator(end()), first); 
    free();  // free the old space

    elements = first; // update the pointers 
    
    first_free = last;
    cap = elements + newcapacity;
}
```




**(5).  Rvalue References and Member Functions**

- 如果一个函数同时提供了<span style="background-color:#FFFF00">copy and move 两个版本</span>,可以获益
    - 一个版本是 take an lvalue reference to ```const T&```
    - 另一个版本是 takes an rvalue reference to <span style="color:red">nonconst ```T &&```</span>  and will be run when we pass a modifiable rvalue. This version is free to steal resources from its parameter
- 一般来说，<span style="background-color:#FFFF00">不用为function 定义 ```const X&&``` or a plain ```X&```</span>. 通常we pass an <span style="color:red">rvalue reference</span> when want to steal from argument. <span style="color:red">the argument must not be ```const```</span>. 类似的, 拷贝对象不应该改变被copied的对象, no need to define a version that take a plain ```X&``` parameter.

比如 the library containers that define push_back provide two versions:
- 版本一: can pass any object that can be converted to tye X
- 版本二: pass only an **rvalue** that is not ```const```

```c++
void push_back(const X&); // copy: binds to any kind of X

void push_back(X&&); // move: binds only to modifiable rvalues of type X

```

两个版本的```push_back``` 区别在于 rvalue reference version 的 ```push_back``` call ```move``` to pass parameter to ```construct```, <span style="background-color:#FFFF00">```construct``` 通过第二个和第二个之后的参数来确定用哪个constructor</span>, 因为```move``` returns an rvalue reference, type of argument to ```construct``` is ```string&&```. 因此string 的 move constructor will be used to construct a new last element
```c++

void StrVec::push_back(const string& s)
{
    chk_n_alloc(); // ensure that there is room for another element

    // construct a copy of s in the element to which first_free points
    
    alloc.construct(first_free++, s);
    } 
void StrVec::push_back(string &&s)
{
    chk_n_alloc(); // reallocates the StrVec if necessary
    
    alloc.construct(first_free++, std::move(s));
}


StrVec vec; 
string s = "some string or another";
vec.push_back(s); // calls push_back(const string&) 

vec.push_back("done"); // calls push_back(string&&)

```


**(6).Rvalue and Lvalue Reference Member Functions**

- can <span style="background-color:#FFFF00">call a **member function**</span> on an object, <span style="color:red">regardless</span> of whether that object is an <span style="color:red">lvalue or an rvalue</span>
- 还可以对rvalue 进行赋值 一个rvalue 
- **reference qualifier**: replace ```&``` or ```&&``` after parameter list (像class 的const 定义类似), ```&``` 表示只能是lvalue call it , ```&&``` 表示只能是rvalue call it: 
    - 与```noexcept```类似, <span style="background-color:#FFFF00">**reference qualifier** 必须同时出现于function **declaration** 和 **definition** 中</span>
    - 一个function <span style="background-color:#FFFF00">可以**同时**有**const** 和 **reference qualifier**</span>. <span style="color:red">但reference qualifier 必须跟在 ```const``` 后面</span>
- 就像 ```const``` function 可以被overload, overload a function based on its **reference qualifer**. 我们<span style="background-color:#FFFF00">可以综合 **reference qualifier** 和 **const** 来区分一个成员函数的重载版本 </span>
    - const function version 通过一个有const, 一个没有const 来区分, 但是对于如果想用<span style="background-color:#FFFF00">**reference qualifier** 区分</span> function(两个或两个以上有same name and same parameter list), <span style="color:red">必须
provide a reference qualifier 在所有的functions or 所有都不提供 </span>

可以call lvalue or rvalue 的member function `

```c++
string s1 = "a value", s2 = "another"; 
auto n = (s1 + s2).find('a'); //ok

s1 + s2 = "wow!";//ok, 对一个rvalue 进行赋值

```

reference qualifier 

```c++
class Test{
public:
    Test(int a_): a(a_){}
    int a;
    void getR() &&  {
        cout << " only rvalue can call "<<endl;
    }
    void getL() & {
        cout << " only lvalue can call "<<endl;
    }
};

auto rval = [] () -> Test { return Test(8); };
//也可以写成 auto rval = [] { return Test(8); };
    
Test lval(10);
rval().getR();//okay

lval.getR(); //error

lval.getL(); //okay

```


另一个例子

```c++
class Foo {
public:
    lvalues Foo &operator=(const Foo&) &; // may assign only to modifiable, 
    
    //只能是lvalue 在左侧的 assignment 

 };

Foo &Foo::operator=(const Foo &rhs) &
{
    // do whatever is needed to assign rhs to this object
    return *this;
}

Foo &retFoo(); //function returns a reference (lvalue)

Foo retVal(); //function returns by value (rvalue)

Foo i, j; // i, j are lvalues

i=j; // okay: i is lvalue 

retFoo() = j; // okay: retFoo() is lvalue

retVal() = j; // error: retVal() returns an rvalue

i = retVal(); // ok: we can pass an rvalue as the right-hand operand to assignment

```

<span style="background-color:#FFFF00">reference qualifier 必须跟在const 的后面</span>

```c++
class Foo {
public:
    Foo someMem() & const; // error: const qualifier must come first
    
    Foo anotherMem() const &; // ok: const qualifier comes first 

};
```


reference qualifier overload
```c++
class Foo { 
public:
    Foo sorted() &&; // // may run on modifiable rvalues 

    Foo sorted() const &; // 可用于任何类型的 Foo

private:
    vector<int> data;
};

// this object is an rvalue, so we can sort in place

Foo Foo::sorted() &&
{
    sort(data.begin(), data.end());
    return *this;
} 

// this object is either const or it is an lvalue; either way we can't sort in place 

//lvalue 是因为改了这个，可能改变其他对象的值，改不会报错

Foo Foo::sorted() const & {
    Foo ret(*this); // make a copy 
    
    sort(ret.data.begin(), ret.data.end()); // sort the copy 
    
    return ret; // return the copy

}

retVal().sorted(); // retVal() is an rvalue, calls Foo::sorted() && 

retFoo().sorted(); // retFoo() is an lvalue, calls Foo::sorted() const &

```

overload const reference 必须都加上 或者都不加上: 对于sorted function, 两个都没有加上 reference qualifier 是okay 的. 
```c++
class Foo { 
public:
    Foo sorted() &&;
    Foo sorted() const; // error: must 加上 reference qualifier

    // Comp 用来比较int 值

    using Comp = bool(const int&, const int&);
    Foo sorted(Comp*); // ok: different parameter list

    Foo sorted(Comp*) const; // ok: neither version is reference qualified

};
```

































***
<br/> <br/> <br/>


## 14. overloaded operators

- When an operator is a member function, the <span style="background-color:#FFFF00">**left-hand operand**</span> is bound to the implicit <span style="background-color:#FFFF00">**this**</span> parameter. The <span style="background-color:#FFFF00">**right-hand operand**</span> is passed as an <span style="background-color:#FFFF00">**explicit parameter**(传递到function)</span>.
- An operator function must either be <span style="background-color:#FFFF00">a member of a class</span> or <span style="background-color:#FFFF00">have **at least one parameter** of class type</span>:
    - 意味着我们不能改变built-in type operator 含义
- 只能重载已有的operator, 不能加新的operator, 比如不可以overload ```**``` 去执行幂操作
- 对于重载运算符, precedence and associativity (优先率 和 结合律) 应保持一致, 比如 ``` x == y + z; ``` 永远等价于 ``` x == (y + z)```
- 有四个 ```+,-,*,&``` 既可以是一元也可以是二元运算，根据number of parameters 腿短定义是哪个
- call operator function 可以直接用 operator ```data1 + data2;``` 也可以像普通function 一样 call overloaded operator function.```operator+(data1, data2); data1.operator+=(data2);```. <span style="color:red">两种调用方法等价的</span>
- <span style="background-color:#FFFF00">the comma, address-of, logical AND, and logical OR operators should not be overloaded</span>.
    - 因为运算符指定了运算顺序, 而operator overloading 是一个function call, 运算顺序可能会变了
    - overloaded versions of ```&&``` or ```||``` operators do not preserve short-circuit evaluation properties of the built-in operators. 用户发现他们熟悉的求值规则不见了
    - 因为这些运算符有了内置的含义，如果重载, behave differently from their normal meanings.
- 如果一个class 定义了 ```==``` operator, 通常也应该定义 ```!=``` as well, 同样如果一个class定义了 ```<``` operator, 也应该定义 all relational operators

![](/img/post/C++/operator_overloading.PNG)

error 去redefine built-in operators
```c++
// error: cannot redefine the built-in operator for ints 

int operator+(int, int);
```

**Guideline of whether make the operator a class member or ordinary nonmember function**

1. assignment ```=```, subscript ```[]```, call ```()```, and member access arrow ```->```` must defined as <span style="background-color:#FFFF00">**members**</span>
2. compound-assignement operators 比如```+=``` 应该是 <span style="background-color:#FFFF00">**members**</span>
3. Operators that change the state of their object or that are closely tied to their given type—such as **increment**, **decrement**, and **dereference**—usually should be <span style="background-color:#FFFF00">**members**</span>.
4. Symmetric operators(provide **mixed-type** expression)—those that might convert either operand, such as the **arithmetic**, **equality**, **relational**, and **bitwise** operators—usually should be defined as ordinary <span style="background-color:#FFFF00">**nonmember functions**</span>. 希望还有混合类型的symmetric operator 比如 把 int 加上 double, 因为int 可以在 加号左侧 右侧都可以, 

比如 加号(```string``` 和 ```const char*``` )被定义成了 string member function then. 相反如果定义成nonmember function, ```"hi" + s``` 等于 ```operator+("hi",s)```, 唯一的requirement是至少一个运算对象是class type, and both operands can converted to string 

```c++
string s = "world";
string t = s+"!"; // ok 

string u = "hi" + s; // would be an error if + were a member of string

```


#### (b). Input and Output Operators

- input and output function 必须是 <span style="background-color:#FFFF00">**nonmember function**</span>. 不能是member of own class. 因为如果是class member(left side is IO), 必须属于istream or ostream 类, 但是those class 是part of standard library, 不能加members to IO class  
- 如果 input and output access nonpublic data, <span style="background-color:#FFFF00">**declared** it as **friends**</span>

**(1). Overloading the Output Operator <<**

- first parameter of an output operator is a <span style="background-color:#FFFF00">reference to a nonconst **ostream** object</span>. <span style="color:red">nonconst 原因是 write to stream changes its state<span>. 而reference 是因为IO对象 不能copy
- 第二个paramemter 通常是 a reference to const class type that we want to print. const 是避免改变object
- return its ```ostream``` **reference** parameter
- The output operators for the built-in types do little **formatting**. <span style="color:red">尤其不会打印换行符</span>. 让user control the detials of their output 


例子
```c++
ostream & operator << (ostream & os, const Sales_data & item){
    os << item.isbn() <<" "<<item.revenue;
    return os;
}
```

**(2). Overloading the Input Operator >>**

- first parameter is <span style="background-color:#FFFF00">**reference to stream**</span> from which it is to read. 
- 第二个 parameter 是 a <span style="background-color:#FFFF00">**reference to nonconst object**</span> which to read. 不是const 因为要read data into this object. 
  - return its ```istream``` **reference** parameter
- <span style="background-color:#FFFF00">**Input operators**</span> must deal with the <span style="color:red">possibility</span> that the <span style="color:red">input might fail</span>; output operators generally don’t bother.
- 当读取操作发生错误时, 输入运算符应该负责从错误中恢复, to protect a user that ignores the posssibility of an input error, won't generate misleading results
  - 如果错误发生错误, 应当set IO state```failbit```, ```eofbit```(file was exhausted), ```badbit```(stream corrupted). 

下面例子, 如果IO错误(比如输入不是数字, 或者hit end-of-file or some other error on input stream), 则运算符将非定对象重置为empty ```Sales_data```
```c++
istream operator>>(istream & is, Sales_data & item){
    double price; 
    is >> item.bookNo >> item.units_sold >> price;
    if (is) // check that the inputs succeeded 
        
        item.revenue = item.units_sold * price;
    else
        item = Sales_data(); // input failed: give the object the default 
    
    return is;
}
```

#### (c). Arithmetic and Relational Operators

- we define the <span style="background-color:#FFFF00">**arithmetic** and **relational** operators as **nonmember functions**</span>, 允许左侧和右侧运算对象 转换. 
- Operators 不应该change state of either operand, so parameter is <span style="background-color:#FFFF00">**references to const**</span>
- 如果定义了**arithmetic operator**, 通常也应该<span style="background-color:#FFFF00">define **compound assignment operator**</span>, 通常更<span style="color:red">**efficient**</span> to define arithmetic operator to use compound assignment 

arithmetic operator: use compound-assignment operator

```c++
Sales_data
operator+(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs; // copy data members from lhs into 

    sum sum += rhs; 
    return sum;
}
```

**1. Equality Operators**

- 如果class 需要判断两个object 是否相等，应该定义 ```==``` 而不是member function 
- operator should be <span style="color:red">**transitive**</span>, 如果 ```a==b```, ```b==c``` 则 ```a==c```
- 如果定义了 ```==``` operator, 也应该定义 ```!=``` operator 
- 相等和不等operator 应该把工作委托(delegate)给另外一个. 表示<span style="color:red">只有相等 or 不等 其中一个 实际比较 work</span>, 另一个call that does the real work 

下面例子展示了只有相等 或 不等一个do the real work
```c++
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
  
  return lhs.isbn() == rhs.isbn() && lhs.units_sold == rhs.units_sold &&
    lhs.revenue == rhs.revenue;
} 
bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
    return !(lhs == rhs);   
}

```

**2. Relational Operators**

- 定义了equality operator, 也应该定义relation operators， 因为<span style="color:red">一些**container** 用到了 operator ```<```</span>
- Ordinarily the relational operators should:
    1. <span style="color:red">**Define an ordering**</span> relation that is **consistent** with requirement for as a key to an <span style="color:red">**associative container**</span> 
    2.  Define a relation that is **consistent** with ```==``` if the class has both operators. 如果 two objects are ```!=```, one object should ```<``` the other
- If a single logical definition for ```<``` exists(如果存在唯一一种逻辑可靠的 ```<```定义), classes usually should define the ```<``` operator. However, if the class also has ```==```, define ```<``` only if the definitions of ```<``` and ```==``` yield consistent results.


#### (d). Assignment Operators

- 除了copy assignment 和 move assignment operators 把同一类的赋值, 也可以定义additional assignment operators that allow 别的类型作为 right-hand operand 
- library (e.g.```vector```) classs 还定义了 a braced list of elements ```vector<string> v = {"a", "an", "the"};```
- Assignment operators can be overloaded. <span style="background-color:#FFFF00">**Assignment operators**</span>, regardless of parameter type, must be defined as <span style="background-color:#FFFF00">**member functions**</span>.  ordinarily <span style="background-color:#FFFF00">**compound-assignment operators** 也应该定义成 **member function**</span>

```c++
class StrVec { 
public:
    StrVec &operator=(std::initializer_list<std::string>);
    //其他成员和上面定义一样
};

StrVec & StrVec::operator=(std::initializer_list<string>il){
    auto data = alloc_n_copy(il.begin(), il.end());
    free();
    elements = data.first;
    first_free = cap = data.second;
    return *this;
}
```

compound-assignment operator
```c++
Sales_data& Sales_data::operator+=(const Sales_data &rhs)
{
    units_sold += rhs.units_sold; 
    revenue += rhs.revenue; 
    return *this;
}
```

#### (e). Subscript Operator


- define the subscript operator ```operator[]```
- The <span style="background-color:#FFFF00">**subscript operator**</span> must be a <span style="background-color:#FFFF00">**member function**</span>.
- To be compatible with the ordinary meaning of subscript, the subscript operator usually <span style="color:red">returns a **reference** to the element</span> that is fetched.
    - 因为返回时reference, 所以 subscript 可以是assignment 的either side. 
    - good idea to define both <span style="color:red">**const** and **nonconst** version of **subscript operator**</span>. (因为可以下表运算结果reference可以是 赋值运算任意一边)

不能对返回const reference 的subscript operator 进行赋值运算
```c++
class StrVec { 
public:
    std::string& operator[](std::size_t n) { return elements[n]; }
    const std::string& operator[](std::size_t n) const { return elements[n]; }

private:
    std::string *elements; // pointer to the first element in the array 

};

const StrVec cvec = svec; // copy elements from svec into cvec

if (svec.size() && svec[0].empty()) {
    svec[0] = "zero"; // ok: subscript returns a reference to a string

    cvec[0] = "Zip"; // error: subscripting cvec returns a reference to const 

}

```


#### (f). Increment and Decrement Operators

- 因为 increment (++) 和 decrement (--)  change the state of the object on which they operate, our preference is to make them <span style="background-color:#FFFF00">**member functions**</span>
- <span style="color:red">prefix</span> return a <span style="color:red">**reference**</span>, <span style="color:red">postfix</span> return a <span style="color:red">**value**</span>
  - To be consistent with the built-in operators, the <span style="color:red">**postfix operators**</span> should <span style="color:red">return the **old**</span> (unincremented or undecremented) value. That value is <span style="color:red">returned as a **value**</span>, not a reference.
- 区分prefix and postfix:
  - ```postfix``` version 有一个<span style="background-color:#FFFF00">**extra(unused, so not give it a name) parameter** of type ```int```</span>. When we <span style="color:red">use a **postfix operator**</span>, the compiler supplies <span style="color:red">**0** as the **argument** for this parameter</span>, 尽管可以使用这个extra 0, 但实际不这么做
  - The <span style="color:red">**postfix**</span> versions have to <span style="color:red">**remember** the current state</span> of the object <span style="color:red">before incrementing</span> the object
  - <span style="color:red">Prefix 需要check if increment/decrement is safe</span> and either throw exception or increment/decrement, <span style="background-color:#FFFF00">Postfix 不需要explicitly check,因为postfix 内call prefix which do the check</span>.


**Defining Prefix Increment/Decrement Operators**

increment check 如果```currr```已经到达了```vector```的末尾, check 将抛出异常。Decrement 如果```curr``` 已经是0了, 那么传递给```check```的值是一个非常大的positive 无效的value
```c++
class StrBlobPtr { 
public:
// increment and decrement 
    
    StrBlobPtr& operator++(); 
    StrBlobPtr& operator--(); // other members as before

};

// prefix: return a reference to the incremented/decremented object 

StrBlobPtr& StrBlobPtr::operator++()
{
    // if curr already points past the end of the container, can't increment it 
    
    check(curr, "increment past end of StrBlobPtr"); 
    ++curr; 
    return *this;
}
StrBlobPtr& StrBlobPtr::operator--()
{
    // / if curr is zero, decrementing it will yield an invalid subscript
    
    --curr; 
    check(-1, "decrement past begin of StrBlobPtr"); //check if -1>=curr(unsigned), 如果大于throw error 
    
    return *this;
}

```

<span style="background-color:#FFFF00">postfix version don't check increment because prefix version 内check the increment</span>
```c++
StrBlobPtr StrBlobPtr::operator++(int)
{
    // no check needed here; the call to prefix increment will do the check 

    StrBlobPtr ret = *this; // save the current value

    ++*this; // advance one element; prefix ++ checks the increment

    return ret; // return the saved state

} 
StrBlobPtr StrBlobPtr::operator--(int)
{
    // no check needed here; the call to prefix decrement will do the check 

    StrBlobPtr ret = *this; // save the current value

    --*this; // move backward one element; prefix -- checks the decrement

    return ret; // return the saved state 

}
```

<span style="background-color:#FFFF00">**Calling the Postfix Operators Explicitly**</span>
```c++
StrBlobPtr p(a1); // p points to the vector inside a1 

p.operator++(0); // call postfix operator++ 

p.operator++(); // call prefix operator++

```

#### (g). Member Access Operators

- The dereference (```*```) and arrow (```->```) operators are often used in classes that represent iterators and in smart pointer classes
- <span style="background-color:#FFFF00">**Operator arrow**</span> must be a <span style="background-color:#FFFF00">**member**</span>(function). The <span style="background-color:#FFFF00">**dereference operator**</span> is not required to be a member but usually should be a<span style="background-color:#FFFF00"> **member**</span> as well.
- When we write ```point->mem```, <span style="background-color:#FFFF00">```point``` must be a **pointer** to a class</span> object or class with an overloaded operator```->```. 根据point类型不同, writing ```point->mem``` resolve 步骤是:
    1. 如果 ```point``` 是<span style="background-color:#FFFF00">**pointer**</span> type ,则用```(*point).mem;```.
    2. 如果```point```是<span style="background-color:#FFFF00">**class**</span> type with overloaded operator```->``` 则用 ```point.operator->()mem;```   来fetch ```mem```
        - 如果operator```->```function return pointer type, goto step 1
        - 如果返回的 ```res``` 是class, 继续step2,  ```point.operator->()mem``` 转化为  ```res.operator->()mem;``` 直到fetch的是pointer type or some error 

比如下面例子, 最好获得是size的number, 不建议这么做, 因为breaks encapsulation
```c++
struct size {
    int width, height;
    size() : width(640), height(480) { }
};
struct metrics {
    size s;
    size const* operator ->() const {
        return &s;
    }
};
struct screen {
    metrics m;
    metrics operator ->() const {
        return m;
    }
};

int main() {
    screen s;
    std::cout << s->width << "\n";
}
```

值得注意
-  <span style="color:red">**deference**</span> 返回时 <span style="color:red">**reference**</span>, 而 <span style="color:red">**arrow**</span> 一般返回是 <span style="color:red">**pointer**</span>
- 两个function 是```const``` member, 因为fetch an element 不改变state of a ```StrBlobPtr```. 这些operator 返回reference or pointer to nonconst string, 因为```StrBlobPtr```(它的constructor是 ```StrBlob &```) 绑定的是nonconst 的 ```StrBlob```

```c++
class StrBlobPtr { 
public:
    std::string& operator*() const
    { 
        auto p = check(curr, "dereference past end");
        return (*p)[curr]; // (*p) is the vector to which this object points

    } 
    
    std::string* operator->() const
    { 
        // delegate the real work to the dereference operator 

        return & this->operator*();
    }
};

StrBlob a1 = {"hi", "bye", "now"};
StrBlobPtr p(a1); // p 指向a1中的vector

*p = "okay"; // assigns to the first element in a1

cout << p->size() << endl; // prints 4, the size of the first element in a1

cout << (*p).size() << endl; // equivalent to p->size()

```

#### (h). Function-Call Operator

-  overload the <span style="background-color:#FFFF00">**call operator**</span> allow objects to be used as <span style="background-color:#FFFF00">**function**</span>
    - 可以<span style="color:red">store state, **more flexible**</span> than ordinary functions.
    - <span style="color:red">**Objects**</span> of classes that define the <span style="color:red">**call operator**</span> 被叫做 <span style="background-color:#FFFF00">**function objects**</span>.
- The **function-call operator** must be a <span style="background-color:#FFFF00">**member function**</span>, can <span style="color:red">define 多个 call operator</span>, each of which must <span style="color:red">differ as to the **number** or **types** of their **parameters**</span>.
- **Function objects**(定义了function-call operator) are most often used as arguments to the <span style="background-color:#FFFF00">**generic algorithms**</span>,
- **Lambdas Are Function Objects**
    - 除了function objects, 也可将<span style="color:red">**lambda function**</span> 用于 <span style="color:red">**generic algorithms**</span>. 
    - When we write a lambda, the compiler translates that expression into an <span style="color:red">**unnamed object** of an **unnamed class**</span> . <span style="color:red">The classes generated</span>  from a lambda <span style="color:red">contain an **overloaded function-call operator**</span> (parameter list and function body are the same as lambda)
        - by default, <span style="color:red">**lambdas** 不能改变 captured variables</span>.As a result, the function-call operator in class generated from lambda is <span style="color:red">const member function</span>. If lambda declared as <span style="color:red">mutable</span>, then call operator is <span style="color:red">not const</span>
    - 当lambda captures a varaibles by <span style="background-color:#FFFF00">**reference**</span>, 是由程序确保lambda <span style="color:red">执行时引用所引对象确实存在</span>. Therefore,  the compiler is permitted to <span style="color:red">**use the reference directly** without storing that reference</span> as a data member in the generated class.
    - 当lambda <span style="background-color:#FFFF00">**captures by value**</span> are copied into the lambda. These classes have a <span style="color:red">**constructor** to **initialize** these data members</span> from captured values, so class <span style="background-color:#FFFF00">**store**</span> these values in class. 
    - <span style="color:red">Classes generated from a lambda </span> expression have a <span style="background-color:#FFFF00">deleted default constructor, deleted assignment operators, and a default destructor</span>. Whether the class has a <span style="background-color:#FFFF00">defaulted or deleted **copy/move constructor** depends in the usual ways on the types of the captured data members</span>

下面例子 function call operator returns its absolute value 
```c++
struct absInt {
    int operator()(int val) const {
        return val < 0 ? -val : val;
    }
};

int i = -42;
absInt absObj; 
int ui = absObj(i); // passes i to absObj.operator()

```


Function-object classes often contain data members that are used to <span style="background-color:#FFFF00">**customize** the operations in the call operator</span>. 下面的```for_each``` 会initialize from cerr and a new line character.

```c++
class PrintString{
public:
    PrintString(ostream &o = cout, char c = ' '): os(o), sep(c) { }
    void operator()(const string &s) const { os << s << sep;
private: 
    ostream &os;
    char sep;
};

PrintString printer; // uses the defaults; prints to cout 

printer(s); // prints s followed by a space on cout

PrintString errors(cerr, '\n');

errors(s); // prints s followed by a newline on cerr

for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'));

```


**1. Lambdas Are Function Objects**

```c++
stable_sort(words.begin(), words.end(),
        [](const string &a, const string &b)
        {return a.size() < b.size(); });

//acts like an unnamed object of a class that would look something like

class ShorterString {
public:
bool operator()(const string &s1, const string &s2)
    const{ return s1.size() < s2.size(); } 
};

//We can rewrite the call to stable_sort to use this class instead of the lambda expression:

stable_sort(words.begin(), words.end(), ShorterString());
```

Lambda capture by value, class generated 需要有constructor.  This <span style="background-color:#FFFF00">**synthesized class** does not have a default constructor</span>, 需要提供argument 
```c++
auto wc = find_if(words.begin(), words.end(),
    [sz](const string &a) {return s.zie() >= sz;});

//would generate a class that looks something like

class SizeComp {
    SizeComp(size_t n): sz(n) { } // parameter for each captured variable
    
    // call operator with the same return type, parameters, and body as the lambda 

    bool operator()(const string &s) const { return s.size() >= sz; }
private:
    size_t sz; // a data member for each variable captured by value 

};    

// to use this class, must pass an argument: 

auto wc = find_if(words.begin(), words.end(), SizeComp(sz));
```



**2. Library-Defined Function Objects**

- standard library defines a set of classes that represent the arithmetic, relational, and logical operators. <span style="color:red">每一个class 定义了call operator</span>. 比如 ```add```, ```modulus(%)```, ```equal_to``` 
- <span style="background-color:#FFFF00">**library function objects** guarantees work for **pointers**</span>. 比如sort pointers <span style="background-color:#FFFF00">based on their address in memory</span>.  Although it would be <span style="color:red">**undefined** for us to do so **directly**</span>, we can do so through one of the **library function objects**
- <span style="color:red">**associative containers** use ```less<key_type>``` to order their elements</span>. 比如可以define ```set``` of pointers or use a pointer as key in ```map``` without specify ```less``` directly.

```c++
plus<int> intAdd; // function object that can add two int values 

negate<int> intNegate; // function object that can negate an int value 

// uses intAdd::operator(int, int) to add 10 and 20

int sum = intAdd(10, 20); //30

sum = intAdd(10, intNegate(10)); // sum = 0

```


![](/img/post/C++/functor.PNG)

使用function-object classes <span style="color:red">**override** the default operator used by an algorithm</span>. 比如: sort 用的default operator ```<``` which sorts the sequence into ascending order. To sort into descending order, pass ```greater```

```c++
sort(svec.begin(), svec.end(), greater<string>());
```

function-objects 可以用pointer比较 addresss in memory 
```c++
vector<string *> nameTable; 
// 老版error, 新版不是error : the pointers in nameTable are unrelated, so < is undefined 

sort(nameTable.begin(), nameTable.end(),
    [](string *a, string *b) { return a < b; });

// ok: library guarantees that less on pointer types is well defined 

sort(nameTable.begin(), nameTable.end(), less<string*>());
```


**3. Callable Objects and function**

- callable objects： **functions** and **pointers to functions**, **lambdas**, objects created by **bind**, and **classes** that overload the **function-call operator**(他们彼此间type 不一样).
- two callable objects(Different types) with <span style="color:red">**different types** may share the **same call signature**</span>. 比如用```map<string, int(*)(int,int)>``` <span style="color:red">不能存储 callable objects with different type but the same **callable signature**</span>
- 解决上面的问题可以用 ```funtion``` defined in ```functional``` header
  - **call signature** inside angle brackets: 比如```function<int(int, int)>```
  - We cannot (directly) store the name of an **overloaded function** in an object of type function. 比如说一样的名字，但是属于不同类, 具体看下面例子
    - One way to resolve the ambiguity is to <span style="color:red">store a **function pointer**</span>(因为function pointer 带着类型) instead of the name of the function:
    - 另外一种方法, we can <span style="color:red">use a unamed **lambda**</span> to disambiguate

<center>Operations on function</center>

| Syntax | Description | 
| --- | :--- | 
| ```function<T> f ```  | f is <span style="background-color:#FFFF00">**null function** object</span> that can <span style="background-color:#FFFF00">**store callable objects**</span> with a <span style="background-color:#FFFF00">**call signature** </span>that equaivalent to function type T (i.e. T is ```retType (args)``` )
| ```function<T> f(nullptr)``` | Explicityly construct a null function | 
| ```function<T> f(obj);``` | stores a <span style="background-color:#FFFF00">**copy**</span> of the callable obj in f |
| ```f``` | Use f as a condition; true if ```f``` <span style="color:red">holds a **callable object**</span>; false otherwise |
| ```f(args)``` Calls he object in f passing args | 
| | 下面是 Types defined as member of ```function<T>``` |
| ```result_type``` | The <span style="background-color:#FFFF00">type **returned**</span> by this function types's callable object  |
| ```argument_type``` <br/> ```first_argument_type```  <br/> ```second_argument_type```  | Types defined when T has <span style="color:red">exactly one or two arguments</span>. 如果T只有一个argument, 则argument_type 是该类型同义词; 如果T有两个argument, 则```first_argument_type``` 和```second_argument_type``` 分别代表两个argument type |



 two callable objects with <span style="color:red">**different types** may share the **same call signature**</span> as if they had the same type. 比如call signature ```int(int, int)```, 下面的例子```add```, ```mod``` 和 ```div``` 都是接受两个ints, return 一个 int

```c++
// ordinary function

int add(int i, int j) { return i + j; }

// lambda, which generates an unnamed function-object class

auto mod = [](int i, int j) { return i % j; }; 

// function-object class

struct div {
    int operator()(int denominator, int divisor) {
        return denominator / divisor;
    }
};
```

我们希望<span style="background-color:#FFFF00">define a **function table** to store "points" to these callable</span>, 当需要特定操作, look in table to find function to call, 比如定义 ```map``` 如下, 可以加入```add```, 但是不能加入```mod``` or ```div```, ```mod``` is a lambda, and each <span style="color:red">lambda has its own **class type**</span>

```c++
// maps an operator to a pointer to a function taking two ints and returning an int 

map<string, int(*)(int,int)> binops;
// ok: add is a pointer to function of the appropriate type 

binops.insert({"+", add}); //

binops.insert({"%", mod}); // error: mod is not a pointer to function

```

function example

```c++
function<int(int, int)> f1 = add; // function pointer 

function<int(int, int)> f2 = div(); // object of a function-object class

function<int(int, int)> f3 = [](int i, int j) { return i * j; }; // lambda

cout << f1(4,2) << endl; // prints 6

cout << f2(4,2) << endl; // prints 2 

cout << f3(4,2) << endl; // prints 8

```

可以用function type  redefine our map

```c++
// table of callable objects corresponding to each binary operator 

// all the callables must take two ints and return an int

// an element can be a function pointer, function object, or lambda 

map<string, function<int(int, int)>> binops = {
    {"+", add}, // function pointer

    {"-", std::minus<int>()}, // library function object
 
    {"*", [](int i, int j) { return i * j; }}, // unnamed lambda 
    
    {"%", mod}, // named lambda object

     {"/", div()} }; // user-defined function object

binops["+"](10, 5); // calls add(10, 5)

binops["-"](10, 5); // uses the call operator of the minus<int> object

binops["/"](10, 5); // uses the call operator of the div  object

binops["*"](10, 5); // calls the lambda function object 

binops["%"](10, 5); // calls the lambda function object

```


We cannot (directly) store the name of an overloaded function in an object of type function, 比如下面有两个add, 放进去的add 不知道哪个add

```c++
int add(int i, int j) { return i + j; }
Sales_data add(const Sales_data&, const Sales_data&); 
map<string, function<int(int, int)>> binops;
binops.insert( {"+", add} ); // error: which add?

//用function pointer store 消除问题

int (*fp)(int,int) = add; // pointer to the version of add that takes two ints

binops.insert( {"+", fp} ); // ok: fp points to the right version of add


//另一种方法用lambda:

// ok: use a lambda to disambiguate which version of add we want to use 

binops.insert( {"+", [](int a, int b) {return add(a, b);} } );
```

#### (i). Overloading, Conversions, and Operators


**1. Conversion Operators**


- We can use <span style="color:red">**non-explicit constructor**</span> that can be called with <span style="color:red">**one argument** defines an **implicit conversion**</span>. Convert object from argument’s type to class type. 也可以定义<span style="color:red">conversion from the class</span>; define a conversion from a class type by defining a <span style="color:red">**conversion operator**</span>.
- ```operator type() const;```:  **conversion operator** is a member function that <span style="color:red">converts a value of a **class type** to a value of some other type(**不能是void, 也不能是array or function type**)</span>. Conversions to <span style="background-color:#FFFF00">**pointer types**(**data** or **function pointers**) 或者 **reference**</span> types 是可以的
- Conversion operators have <span style="color:red">**no return type and no parameters**</span>
- Must be <span style="color:red">defined as **member** functions</span>
- **Conversion operations** ordinarily should <span style="background-color:#FFFF00">**not change** the object they are converting</span>. As a result, conversion operators usually should be <span style="background-color:#FFFF00">defined as **const** members</span>.
- Compiler 只能apply 一步conversion at a time, 但是<span style="color:red">**implicit user-defined conversion** can be preceded or followed by a standard conversion</span>(built-in conversion double to int，而 ```const char*``` 到 string 不算built-in) 
- Caution: Avoid Overuse of Conversion Functions: 如果不存一对一mapping 关系的时候不要定义
    - 一般很少提供类型转换，但是一个例外是 <span style="background-color:#FFFF00">for classes to define conversions to bool</span>. 但早期的版本 因为bool 算arithmetic type, 会导致convert to bool 再convert to arithmetic, 导致意想不到的结果,
    - **explicit** Conversion Operators: 为防止上面说的情况发生, 不会发生自动转换. The compiler <span style="background-color:#FFFF00">won’t (generally) use an **explicit conversion operator** for **implicit conversions**</span>. <span style="background-color:#FFFF00">must do so explicitly through a cast. </span>
        - 这个规定存在一个例外，<span style="color:red">如果表达式被用作条件</span>,  <span style="color:red">an **explicit conversion** will be used **implicitly** to convert an expression used as</span>
            - The condition of an ```if```, ```while``` or ```do``` statement, condition expression in a ```for``` statement, 
            - An operand to the logical NOT (```!```), OR (```||```), or AND (```&&```) operators or 条件逻辑表达式 (```?:```) operator



比如下面例子<span style="color:red">既定义了```SmallInt```  到int 转换, 也定义了从 int 到 ```SmallInt``` 转换</span>. defines conversions to and from its type
```c++
class SmallInt { 
public:
    SmallInt(int i = 0): val(i)
    {
        if (i < 0 || i > 255) 
            throw std::out_of_range("Bad SmallInt value");
    }
    operator int() const { return val; }
private: 
    std::size_t val;
};       

SmallInt si;
si = 4; // implicitly converts 4 to SmallInt then calls SmallInt::operator=

si + 3; // implicitly converts si to int followed by integer addition

```

Although compiler apply only **one** user-defined conversion at a time. an implicit user-defined conversion can be preceded or followed by a standard (built-in) conversion. 比如下面例子 可以<span style="color:red">pass any 算数类型 to the SmalInt constructor</span>.  <span style="color:red">也可以将SmallInt 转换成int 然后 convert int 到其他arithmetic type</span>

```c++
//built in conversion double -> int

SmallInt si = 3.14; // calls SmallInt(int) constructor

// the SmallInt conversion operator converts si to int;

si + 3.14; // int 再用 built-in conversion to double 

```




Conversion operation no return type, no parameter list, always const function

```c++
class SmallInt; 
operator int(SmallInt&); //error: nonmember


class SmallInt { 
public:
    int operator int() const; //error: 有return type 
    
    operator int(int = 0) const; //error: parameter list 不为空
    
    operator int*() const { return 42; } // error: 42 is not a pointer
    
};
```

一些早期的版本bool 算arithmetic type (所以转换成bool -> arithmetic type ), 所以class convert to bool (not explicit) 有意想不到的后果, 比如```ifstream``` had convertion to bool. 尝试用 output operator on an input stream, 因为没有 ```<<``` 定义 给 ```istream```, <span style="color:red">应该有**error**</span>, 但是use bool conversion operator to <span style="color:red">**convert cin to bool. 导致 bool to int**</span>. 所以 42 会shift left 1 or 0 
```c++
int i = 42;
cin << i; // this code would be legal if the conversion to bool were not explicit!

```

explicit Conversion Operators: The compiler <span style="background-color:#FFFF00">won’t (generally) use an **explicit conversion operator** for **implicit conversions**</span>. 必须用 cast 才能转换

```c++
SmallInt si = 3; // ok: the SmallInt constructor is not explicit

si + 3; // error: implicit is conversion required, but operator int is explicit 

static_cast<int>(si) + 3; // ok: explicitly request the conversion

```

早期版本IO通过定义了向 ```void*```类型转换，避免以上问题( convert to ```void *``` which is nullptr if the stream operation failed, and non-null if the stream is still good.), C++11 通过explicit conversion to bool. The condition in ```while``` 执行了input operator reads value and return ```cin```. ```cin``` <span style="background-color:#FFFF00">**implicitly converted** by the istream **operator bool** conversion function</span>, return true if conditon state of cin is good, and false otherwise
```c++
while (std::cin >> value)
```

**Explicit call conversion operator** 

```c++
class Test{
public:
    operator string() const {
        return "123";
    }
};
Test a;
cout << a.operator string()<<endl; //ok

```

**2. Avoiding Ambiguous Conversions**


- If a class<span style="color:red"> has one or more conversions</span>, <span style="color:red"> **Important**</span> to ensure <span style="color:red">only **one way convert**</span> from  class type to target type. 两种方式multiple conversion paths (都很可能产生ambiguity)
   - 第一种provide mutual conversion (<span style="background-color:#FFFF00">**converting constructor and conversion operator**</span>)
      - 比如 ```Foo``` has a constructor from ```Bar```, 不要给 ```Bar``` conversion operator to ```Foo```
   - 第二种是:  <span style="background-color:#FFFF00">**define multiple conversions**</span> from or to types that are themselves related by conversions(比如 two arithmetic types). 
      - <span style="color:red">Do not define overloaded versions</span> of conversion constructor that take arithmetic types. 比如 定义了 int to ```Foo```, 不要定义```double``` to ```Foo```
       - <span style="color:red">Do not define conversion operators to more than one arithmetic type</span>. Let the standard conversions provide conversions to the other arithmetic types. 比如定义了 ```Foo``` to ```int```, 不要定义 ```Foo``` to ```double```
    - 如果定义了多种方式conversions, <span style="color:red">之所以ambiguity, 因为conversions have the **same rank**</span><span style="color:red">(the **rank** of standard conversion)</span>
    - 如果有ambiguity, 不能用**cast** 解决问题
- **Caution: Conversions and Operators**
  - Ordinarily, it is a <span style="color:red"> **bad idea**</span> to define classes with <span style="color:red"> **mutual conversions**</span> or to <span style="color:red"> define conversions to or from two arithmetic types</span>.  
  - **The easiest rule of all**: 除了可以定义 <span style="background-color:#FFFF00">an **explicit** conversion to bool</span>, <span style="color:red">avoid defining conversion functions and limit nonexplicit constructors</span>.
- Need to <span style="color:red">use a constructor or a **cast** to **convert an argument**</span> in a call to an <span style="color:red">**overloaded function**</span> frequently is  <span style="color:red">**bad design**</span>. 注意下面例子
  - <span style="background-color:#FFFF00">Call to an **overloaded function**</span>, if two (or more) <span style="color:red"> 转化为不同type的 都可行的</span> (比如 10, ```short``` to ```Foo``` 还是 ```double``` to ```Bar```), 是<span style="color:red">**ambiguity**</span>, <span style="background-color:#FFFF00">**rank** of any standard conversion 不会被考虑</span>. 只有当**同一个**  type user-defined conversion时候(比如是 ```short``` to ```Foo``` 还是 ```double``` to ```Foo```时候), **rank** of standard conversion 才 被考虑


下面例子obtain A 可以从 A的constructor or B's conversion operator. the call to f is <span style="color:red">**ambiguous**</span>.  <span style="color:red">**error**</span>. 不能用 **cast** 来解决ambiguity
```c++
struct B;//根据compile 顺序, 需要首先declare

struct A {
    A() = default; 
    A(const B&);// converts a B to an A 

};
struct B{
    operator A() const; // also converts a B to an A

};

A f(const A&); //function parameter 是A, 返回 A

B b;
A a = f(b); // error ambiguous: f(B::operator A())

            // or f(A::A(const B&))


// If want to make the call, explicitly call the conversion operator or constructor:

A a1 = f(b.operator A()); // ok: use B's conversion operator 

A a2 = f(A(b)); // ok: use A's constructor

```

<span style="color:red">**Ambiguities**</span> 

- 当call ```f2```时候,两个类型转换都可以使用, 不管是long double -> int or long double -> double 而且哪个转换没有比另一个更好,  the call is <span style="color:red">**ambiguous**</span>.  
- initialize a2 from long。 <span style="color:red">Neither constructor is an **exact match** for long</span>. long -> double followed by ```A(double)``` or long -> int, followed by ```A(int)```.  the call is <span style="color:red">**ambiguous**</span>.  
- <span style="color:red">如果conversion 的 rank 不一样, 则有better match</span>. 比如short to int 是preferred to short to double , 所以不会有ambiguity

```c++
struct A {
    A(int = 0);     // usually a bad idea to have two

    A(double); // conversions from arithmetic types


    operator int() const; // usually a bad idea to have two operator 

    double() const; // conversions to arithmetic types 

};
void f2(long double);//function 
A a;
f2(a); // error ambiguous: f(A::operator int())

        // or f(A::operator double()) 

long lg;
A a2(lg); // error ambiguous: A::A(int) or A::A(double)

short s = 42;
// promoting short to int is better than converting short to double 

A a3(s); // uses A::A(int)

```

**Overloaded Functions and Converting Constructors**

when we call an **overloaded function**. 如果两个或多个类型转换都提供了同一种可行的匹配，这些类型转换一样好. 下面例子<span style="color:red">**ambiguity**</span> 因为<span style="color:red">overload functions take parameters 的class type  定义了一样的 converting constructor </span>

```c++
struct C { 
    C(int);
};
struct D {
    D(int);
};
void manip(const C&);
void manip(const D&);
manip(10); // error ambiguous: manip(C(10)) or manip(D(10))

//可以消除ambiguity by explicitly constructing the correct type

manip(C(10)); //ok: calls manip(const C&)

```

下面例子证明： 当 call to an **overloaded function**, if two (or more) <span style="color:red">user-defined conversions provide a viable match</span>, 不会用 <span style="background-color:#FFFF00">**rank** of any standard conversion </span> 去看which is better match, 比如下面的 int 对于 10 是better match, double 对于10 需要额外的standard conversion, compiler 仍然认为是<span style="color:red">**ambiguous**</span>, the compiler will still flag this call as an <span style="color:red">**error**</span>.

```c++
struct E { E(double);
// other members
};
void manip2(const C&);
void manip2(const E&);
// error ambiguous: two different user-defined conversions could be used

manip2(10); // manip2(C(10) or manip2(E(double(10)))
```



**3. Function Matching and Overloaded Operators**

- Providing both <span style="background-color:#FFFF00">**conversion functions** to an **arithmetic type** and **overloaded operators** for the same class type may lead to ambiguities</span> between the overloaded operators and the built-in operators.
- When we <span style="color:red">call a **named function**</span>, <span style="color:red">**member** and **nonmember functions** with the same name 不会 overload</span>, 因为syntax 不同(call member type 需要through object, reference or pointer). 但是call <span style="color:red">**overloaded operator** </span>, <span style="color:red">nothing to indicate</span> whether <span style="color:red">using a **member** or **nonmember** function</span>. 

the expression ```a sym b``` might be, 第一种是member function, 第二种是nonmember function.<span style="background-color:#FFFF00"> 不像普通function calls, 我们不能区分whether we're calling a nonmember or member function</span> . 
```c++
a.operatorsym (b); // a has operatorsym as a member function 

operatorsym(a, b); // operatorsym is an ordinary function

```

下面例子, 第一个use overloaded versionf of ```+``` that takes two ```SmallInt``` values. 第二个addition is <span style="color:red">**ambiguous**</span>, 因为我们convert ```0``` to a ```SmallInt```  也可以把 ```s3``` convert to ```int``` and use built-in additon on ints
```c++
class SmallInt { 
    friend
    SmallInt operator+(const SmallInt&, const SmallInt&); 
public:
    SmallInt(int = 0); // conversion from int

    operator int() const { return val; } // conversion to int private:
private:
    std::size_t val;
};
SmallInt s1, s2;
SmallInt s3 = s1 + s2; // uses overloaded operator+ 

int i = s3 + 0; // error: ambiguous

```


***
<br/> <br/> <br/>


































## (15). Object-Oriented Programming


#### (a). OOP: An Overview

- Object-oriented programming key ideas is: **data abstraction**, **inheritance** and **dynamic binding**.
    - **data abstraction**: define classes that separate interface from implementation. 
    - **Inheritance**: define classes that model relationship among similar types
    - **dynamic binding**: use objects of these types(similar types) while ignoring the details of how they differ 

**Dynamic Binding**:

the decision as to which <span style="color:red">version to run depends on the type of the argument</span>, <span style="color:red">在run time 选择函数版本</span>. Therefore, <span style="background-color:#FFFF00">**dynamic binding**</span> is sometimes known as <span style="background-color:#FFFF00">**run-time binding**</span>.
   - **dynamic binding** happens when a **virtual** member function is called through a **reference** or a **pointer** to a base-class type. 比如下面例子 Use the same code to process objects of either type ```Quote``` or ```Bulk_quote``` interchangeably. item is reference ```const Quote &``` , 可以是  ```Quote``` object or ```Bulk_quote``` object. 因为```net_price``` 是virtual function, ther <span style="color:red">**version**</span> of ```net_price``` that <span style="color:red">is **run** will depend on</span> the type of the object that <span style="color:red">we pass</span> to ```print_total```

```c++
class Quote { 
public:    
     std::string isbn() const;
    virtual double net_price(std::size_t n) const;
};
class Bulk_quote : public Quote { // Bulk_quote inherits from Quote

    double net_price(std::size_t) const override;
};

double print_total(ostream &os, const Quote &item, size_t n)
{
// depending on the type of the object bound to the item parameter 

// calls either Quote::net_price or Bulk_quote::net_price 

double ret = item.net_price(n);
    os << "ISBN: " << item.isbn() // calls Quote::isbn

    << " # sold: " << n << " total due: " << ret << endl; 
    return ret;
}
print_total(cout, basic, 20); // calls Quote version of net_price 

print_total(cout, bulk, 20); // calls Bulk_quote version of net_price

```

#### (b). Defining Base and Derived Classes





base class:
- a **base class** must distinguish the functions it expects its derived classes to override (**virtual**) VS expects its derived classes to inherit without change(直接继承不要改变的).
- <span style="color:red">A **base class** must be **defined**, not just declared, before we can use it as a **base class**</span>: 因为derived class 可能contains and use memeber it inherits from base class. 使用这些 members, derived lass must know what they are. 所以重要的implication是: <span style="color:red">**impossible to derive a class from itself**</span>

derived class:
- Derived Classes <span style="background-color:#FFFF00">**声明**时候 不用include its **derivation list**</span>. 比如 ```class Foo;``` ok的, 但 ```class Foo: public bar;``` 是error的
- A derived class must specify the class(es) from which it inherit. It does so in <span style="color:red">**derivation list**</span> (继承了哪个class, 是public, private, protected):  a colon followed by a comma-separated list of base classes each of which may have an optional access specifier
- <span style="color:red">A derived class constructor initializes its **direct base** class only</span>. 比如 C继承B, B继承A, 那么 C 只用initialize B 的constructor, 不用initialize A 的, A 的constructor 由 B 来initialize
- 尽管derived class contains member from inheritance from base, 但<span style="color:red">cannot directly initialize those members</span>. a <span style="color:red">derived class must use a **base-class constructor** to initialize</span> its base-class part. Base-class part initialized along witht data members of derived class, during the initialization phase of the constructor 
    - The <span style="background-color:#FFFF00">**base class** is initialized first</span>, and then the members of the derived class are initialized in the order in which they are declared in the class.
    - 遵循base-class interface: 即使可以通过inheritance 给public/protected data 赋值, 最好还是通过base-class constructor initialize member(should respect the interface of its base class)
    

inheritance:
- The fact that a <span style="background-color:#FFFF00">derived object contains subobjects for its base classes</span> is key to how inheritance works.
- Standard 没有说明how derived objects 怎么存储, The base and derived parts of an object are not guaranteed to be stored contiguously
- a **base class** at the root of the hierarchy. Inheriting classes are known as **derived classes**. 
  - base class: 定义 common members. derived clas define memeber that are specific to derived class
- A <span style="color:red">**direct base**</span> class is named in the derivation list. An span style="color:red">**indirect base**</span> is one that a derived class inherits through its direct base class.  <span style="color:red">**The most derived object**</span> contains a subobject for its **direct base** and for each of its **indirect bases**.  


a derived-class constructor uses its <span style="background-color:#FFFF00">**constructor initializer list** to pass arguments to a base-class constructor</span>

```c++
Bulk_quote(const std::string& book, double p, std::size_t qty, double disc) :
        Quote(book, p), min_qty(qty), discount(disc) { } 
};
```

用作base class 必须被defined not just declared.

```c++
class Quote; // declared but not defined

// error: Quote must be defined

class Bulk_quote : public Quote { ... };
```

一个class 可以同时是base class, 也可以是 derived class. 下面例子 Base is a **direct base** to D1 and an **indirect base** to D2. 
```c++
classBase{/* ... */};
class D1: public Base { /* ... */ }; 
class D2: public D1 { /* ... */ };
```

可以阻止Inheritance by define final
```c++
class NoDerived final { /* */ }; // NoDerived can't be a base class class 

Base { /* */ };

// Last is final; we cannot inherit from Last

class Last final : Base { /* */ }; // Last can't be a base class 

class Bad : NoDerived { /* */ }; // error: NoDerived is final class 

Bad2 : Last { /* */ }; // error: Last is final

```



**static Members**

- base class 定义了 static member, <span style="background-color:#FFFF00">**only one** such member defined for the entire hierarchy</span>. 不管几个继承了base class, 只有一个instance of each sstatic member. 
- <span style="color:red">如果**static** 是 **private**, derived class 不能用它</span>
- 如果static member is accessible, we can <span style="color:red">use a static member through either base or derived</span>

```c++
class Base { 
public:
    static void statmem();
};

class Derived : public Base {
    void f(const Derived&){
        Base::statmem(); // ok: Base defines statmem 
        
        Derived::statmem(); // ok: Derived inherits statmem
    
        // ok: derived objects can be used to access static from base 
        
        derived_obj.statmem(); // accessed through a Derived object 
        
        statmem(); // accessed through this object

    }
};
```

#### (c). Derived-to-Base Conversion

- Ordinarily, we can <span style="color:red">bind a reference or a pointer</span> only to an object that has <span style="color:red">the same type as the corresponding reference or pointer</span> or to a type that involves an acceptable <span style="color:red">const conversion</span>
    - class type 有个例外: <span style="background-color:#FFFF00">bind a **pointer or reference** to a **base-class** type to an object of a type **derived** from that base class</span>. 只能derived-to-base, 不能convert base to derived.
    	- the compiler will <span style="color:red">apply</span> the derived-to-base conversion <span style="background-color:#FFFF00">**implicitly**</span>.  
        - derived to base conversion 之所以存在因为每一个derived class 都包含base-class part (用base class type 的reference or pointer 可以绑定到上面)
        - 但是反过来对于base-class, <span style="background-color:#FFFF00">没有这个保证</span>, A base-class object can <span style="color:red">exist either as an **independent object** or as part of a derived object</span>. 如果base object is not part of derived object 只有member defined in base, 没有member defined by derived class
        - cannot convert from base(a base pointer or reference is bound to a derived object) to derived. 当使用绑定derived 的base reference/pointer 去convert to derived 是不可以的
    - important implication: When we use a <span style="background-color:#FFFF00">**reference (or pointer) to a base-class type**, we don’t know the actual type</span> of the object to which the pointer or reference is bound. 可以是base 也可以是derived 的type
    - 因为assignment operator, copy constructor 接受const **reference** of class type, the <span style="background-color:#FFFF00">**derived-to-base conversion**</span> lets us <span style="background-color:#FFFF00">pass a derived object</span> to a <span style="background-color:#FFFF00">**base-class copy/move operation**</span>. <span style="background-color:#FFFF00">Only the **base-class part** of the derived object is **copied**, **moved**, or **assigned**</span>. The **derived part** of the object is **ignored** (忽略 derived class 部分被 **sliced down**(切掉了).)
    - Like built-in pointers, the  <span style="background-color:#FFFF00">**smart pointer** classes support the **derived-to-base conversion**</span>—we can store a pointer to a derived object in a smart pointer to the base type.
- 没有conversion from a **base-to-derived** class type. 但是possible convert an object of a derived class to base-class type. However, such conversions may not behave as we might want.
   - 如果当我们知道conversion is safe from base to derived, 可以用<span style="background-color:#FFFF00"> ```static_cast``` override the compiler</span>
  

**static type** VS **dynamic type**
- <span style="color:red">**static type**</span> of an expression: <span style="color:red">known at **compile time**</span> : it is the type with which a variable is declared or that an expression yields. 
- The <span style="color:red">**dynamic type** is the type of the object in **memory**</span> that at the variable or expression represents. The dynamic type may <span style="color:red">not be known until **run time**</span>.
- <span style="color:red">**static type**</span> of a **pointer** or **reference** to a base class <span style="color:red">may differ from its **dynamic type**</span>.    


Derived-to-Base Conversion:

```c++
Quote item; 
Bulk_quote bulk; 
Quote *p = &item; // p bound to the Quote object

p = &bulk; // p bound to the Quote part of bulk

Quote &r = bulk; // r bound to the Quote part of bulk

```

下面例子, <span style="color:red">**static type** of item differ from its **dynamic type**</span>. As we’ve seen, the **static type** of item is ```Quote&,``` but in this case the **dynamic type** is ```Bulk_quote```
```
double ret = item.net_price(n);
```

对于base class might or might not be part of a derived object, there is <span style="color:red">no automatic **conversion from the base class to its derived class(s)**</span>: 因为Derived member可能不在base中. Compiler no way to know that conversion is safe at run time. Compiler 仅仅look at static types of pointer or reference to 判断if conversion legal. <span style="color:red">如果base class 有one or more virtual functions, can use ```dynamic_cast```</span> (cover at 19.2.1) to request a conversion that checked at run time.  <span style="color:red">

```c++
Base base;
Derived* bulkP = &base; // error: can't convert base to derived 

Derived& bulkRef = base; // error: can't convert base to derived

```

cannot convert from base(a base pointer or reference is bound to a derived object) to derived. 即使base pointer 的dynamic type 是 derived type.

```c++
Derived bulk;
Base *itemP = &bulk; // ok: dynamic type is Bulk_quote 

Derived *bulkP = itemP; // error: can't convert base to derived

```

Copy / Move operation 的parameters <span style="color:red">const reference to class type</span>. 因为是reference, the **derived-to-base conversion** lets us pass a <span style="color:red">**derived**</span> object to a <span style="color:red">**base-class**</span> copy/move operation; 这些operation not virtual. When we pass a derived object to a base-class constructor/assignment operator, <span style="background-color:#FFFF00">**constructor/operator knows only about the member of the base class**</span>. 比如我们定义的class, 有synthesized versions of copy and assignment. That constructor only knows ```Quote``` 的 ```bookNo``` 和 ```price```. <span style="color:red">copies those member from Base and ignore the members that are part of the Derived </span>

```c++
Derived bulk; // object of derived type

Base item(bulk); // uses the Quote::Quote(const Quote&) 

item = bulk; // calls Quote::operator=(const Quote&)

```

重要的点:
- The conversion from <span style="color:red">**derived to base**</span> applies only to **pointer** or **reference** types
- No implicit conversion from the base-class type to the derived type.
- Like any member, the **derived-to-base conversion** may be inaccessible due to access controls. 
- 可以copy, move, assign an object of derived type to base-type object. 但是只copy, move, assign member in the base-class part of object.


#### (d). Virtual / Polymorphism 

**Virtual**
- When we <span style="color:red">call a **virtual function** through a **pointer** or **reference**</span>, the <span style="color:red">call will be **dynamically bound**</span>. Depending on reference or pointer 绑定 object type, the version in the base class or in one of its derived classes will be executed.
-  <span style="background-color:#FFFF00">Any **nonstatic member** function, other than a constructor, 可以是 virtual</span>. <span style="color:red">**virtual** 只能用于the declaration inside the class</span>, outside class定义时不能用
    - virtual function in base class is  <span style="color:red">**implicitly virtual** in **all derived classes**</span>. 在 derived class **virtual** function, <span style="color:red">keyword **virtual** 加不加都可以</span>
    - Member functions <span style="color:red">not declared virtual are **resolved** at **compile time**</span>

- derived class override inherited virtual function <span style="color:red">必须有一样的**parameter type** as the base-class function </span>
    - return type 一般也要match, 一个例外是 <span style="background-color:#FFFF00">return a **reference** / **pointer**</span> to types that are themselves  <span style="color:red">related by inheritance</span>.  比如 ```D``` 继承 ```B```, ```B``` 的virtual 返回 ```B*```, ```D``` virtual 可以返回 ```D*```,   并且在return type<span style="color:red">**derived-to-base conversion** from D to B is **accessible**</span>
    - ```override```: explicitly note that function <span style="color:red"> **override** a virtual that it inherits</span>. <span style="color:red">compiler will **reject**</span> a program if a function <span style="color:red">marked ```override``` does not override</span> an existing virtual function
        - override 只能用于 virtual function
    - ```final```: 
    	- Preventing Inheritance. 通过定义 class as **final**: ```class NoDerived final ```, class 不能再被 inherited
	    - 把function 定义成 **final** 表示不能再override, 比如 C 继承 B， B继承A, B override 的virtual from A as final 表示 C中不能再override 这个function
    - ```final``` 和 ```override``` 都 <span style="background-color:#FFFF00">specify parameter list, const,  reference qualifier 之后</span>
 - 可以redefine a function in derived class the same name as virtual in base class 但是 <span style="color:red">不同的 parameter list</span>. Compiler 会认为这个function 不是override base class virtual function 
- Virtual functions that have <span style="color:red">**default arguments** should use the same values in the base and derived classes</span>.
  -  <span style="background-color:#FFFF00">default argument bind at compiled time</span>, derived 的default argument 不会override base 的default
- 有些情况<span style="background-color:#FFFF00">prevent dynamic binding</span> of a call to virtual function, 可以force call to use 特定的virtual(不用derived 用base的), 可以用**scope operator**. This call will be <span style="background-color:#FFFF00">**resolved at compile time**</span>.
    - 一般情况只有<span style="color:red">**member functions** or **friends**</span> 才用scope operator 回避dynamic binding
    -  The most common case is when a <span style="color:red">derived-class virtual function calls the version from the base class</span>. base-class version might do work <span style="color:red">**common** to all types</span> in the hierarch. Derived classes would do whatever additional work
    -  If a derived virtual function that intended to <span style="color:red">call its base-class version omits the scope operator</span>, the call will be resolved at run time as a call to the derived version itself, resulting in an <span style="color:red">**infinite recursion**</span>
-  <span style="background-color:#FFFF00">**virtual functions** must always be define</span>. <span style="color:red">因为**dynamic binding**不知道call 哪个function at **runtime**.  <span style="background-color:#FFFF00">通常上, 如果我们不需要哪个function, 无须定义</span>. 




**Polymorphism**
- The key idea behind OOP is **polymorphism**(from Green meaning "**many forms**"). inheritance as **polymorphic** types. we can use the “many forms” of these types while <span style="color:red">ignoring the differences among them</span>. The fact that the **static** and **dynamic** types of references and pointers can differ is the cornerstone(根本所在) of how C++ supports polymorphism.
  - 比如使用 reference or pointer to the base class, 不知道type(base type or derived type) until <span style="background-color:#FFFF00">**runtime**</span>. 如通过 <span style="background-color:#FFFF00">**pointer or reference of base class call virtual function**</span>. The version of  virtual function 由 the reference or pointer 绑定对象的真实类型决定
  - On the other hand,calls to  <span style="background-color:#FFFF00">**nonvirtual functions** through pointer/reference </span> or calls to  <span style="background-color:#FFFF00">any function (virtual or not) on an **object**(plain—nonreference and nonpointer—type) </span> are <span style="background-color:#FFFF00">bound at **compile time**</span>.

下面例子中case3 比较重要, 因为only copy derived 中的base-class 的part. case3中```base``` is <span style="color:red">plain (non pointer and non reference) that call is bound at compile time</span>. We can <span style="color:red">change the value</span> (i.e., the contents) of the object that base represents, but there is <span style="color:red">**no way to change the type**</span> of that object. 因此<span style="color:red">call is resolved at **compile time**</span> 
```c++
Quote base("0-201-82470-1", 50);
print_total(cout, base, 10); // calls Quote::net_price 

Bulk_quote derived("0-201-82470-1", 50, 5, .19);
print_total(cout, derived, 10); // calls Bulk_quote::net_price

//case 3

base = derived; // copies the Quote part of derived into base 

base.net_price(20); // calls Quote::net_price

```

override: 只能用于virtual function 

```c++
struct B {
    virtual void f1(int) const; 
    virtual void f2();
    void f3();
};
struct D1 : B 
{
    void f1(int) const override; // ok: f1 matches f1 in the base 
    
    void f2(int) override; // error: B has no f2(int) function

    void f3() override; // error: f3 not virtual

    void f4() override; // error: B doesn't have a function named f4
}

struct D2 : B {
    // inherits f2() and f3() from B and overrides f1(int)
    
    void f1(int) const final; // subsequent classes can't override f1 (int)

};
struct D3 : D2 {
    void f2(); // ok: overrides f2 inherited from the indirect base, B

    void f1(int) const; // error: D2 declared f2 as final

};
```

prevent dynamic binding of a call to a virtual function.  We can use the scope operator to do so.

```c++
double undiscounted = baseP->Quote::net_price(42);
```


#### (e). Abstract Base Classes

- **Pure Virtual Functions**: not have to be **defined**(可以不被define, 但不是必须不被define). specify that a virtual function by writing ```= 0``` in place of function b. The ```= 0``` 只能是在<span style="background-color:#FFFF00">declaration of virtual function in class body</span>
    - <span style="color:red">可以provide a definition for pure virtual</span>. 但是function body 必须被<span style="color:red">定义outside the class</span>.不能在provide function body inside the class that is ```=0```
- A class containing (or <span style="color:red">**inheriting without overridding**</span>) a pure virtual function is an abstract base class
    - Abstract class <span style="color:red">定义了interface</span> for subsequent classes to override, 但不能create objects
- 不能 create objects of a type that is an **abstract base class**.: abstract class 的constructor 是用于derived class的constructor 来 construct abstract class 的 member
- **refactoring**:   redesigning a class hierarchy to move operations and/or data from one class to another, 是common in OO application.  即使改变了继承体系, 那么使用 derived class代码无须改变, 但是必须recompile any code that uses those classes.



#### (f). Access Control and Inheritance

- Like public, <span style="color:red">**protected** members are accessible to **members** and **friends**</span> of classes derived from this class.
- 在derived class 的<span style="color:red">**derived class member**</span>中 access <span style="color:red">**base protected members**</span> 可以通过<span style="color:red">**derived object**</span>access, 而不能通过 base-class objects.
-  **derivation access specifier** 不控制derived class members/functions 如何使用 **direct base class**. 而是控制 <span style="color:red">users of the derived class</span>  -including derived class的inherit class or objects—怎么使用direct base classes.
    - 比如 protected inherited, derived class的 member and friend 可以使用 base 的 public/protected, 但不能访问base 的private,  但是user 不能使用base 的public/protected
- Whether the <span style="color:red">**derived-to-base conversion** 是否 **accessible** 取决</span>于which code try to use conversion 和 <span style="color:red">**access specifier**</span>



下面证明了: friend 定义在derived 中 access base member 的protected  只能用derived class object 而不能用base class object, 原因是friend 定义在derived 中 而不是定义在base 中. 如果可以access base class 的 protected member 通过base class object, 就即使不是friend 也有更改它的风险, 所以prevent such usage, 禁止这么做

```c++
class Base { 
protected:
    int prot_mem; // protected member
};
class Sneaky : public Base {
    friend void clobber(Sneaky&); // can access Sneaky::prot_mem 

    friend void clobber(Base&); // can't access Base::prot_mem 
    
    int j; // j is private by default

};
// ok: clobber can access the private and protected members in Sneaky objects 

void clobber(Sneaky &s) { s.j = s.prot_mem = 0; }

// error: clobber can't access the protected members in Base

void clobber(Base &b) { b.prot_mem = 0; }
```



**Accessibility of Derived-to-Base Conversion**

Whether <span style="background-color:#FFFF00">**derived-to-base conversion**</span> accessible 取决于 <span style="background-color:#FFFF00">**access specifier**</span>. 假设D inherits from B B:
- <span style="color:red">**derived-to-base conversion** : user can use only if D inherits **public**</span> from B. 不accessible if D inherits from B using either **protected** or **private**.
- <span style="color:red">**Member functions** and **friends**</span> of D can use conversion to B regardless <span style="color:red">**public**, **private**, **protected**</span>
-  <span style="color:red">**Member functions** and **friends** of classes derived from D</span> can the conversion if D inherits from B is <span style="color:red">**public** or **protected**</span>
- Tip: 如果base class B 的<span style="color:red">public member 可以accessible</span>, then <span style="color:red">**derived-to-base conversion** is also **accessible**</span>


**Friendship and Inheritance**

- <span style="background-color:#FFFF00">**friendship is not transitive, friendship is not inherited**</span>. Transitive 表示 B 是 A 的友元, C是B的友元, 但是 C 不能访问A. **Inherited**: 可以通过friend 的 inherited class 访问 base class member(下面例子). The access to Base objects 是embedded in object derived from Base
    - <span style="color:red">base class 的friends 没有access to members of its derived class</span>
    - <span style="color:red">derived class 的 friends 没有acess to the base class</span>
- 当一个class(A) make another class(B) friend, 只能是another class (B) 访问 这个class (A), 两个friend 的 base class, derived class 都没有对彼此(A,B)的 special access
- 如果想<span style="background-color:#FFFF00">**change access level**</span> of a name that derived class inherits. 可以这么做by providing a <span style="background-color:#FFFF00">**using declaration**</span> (using declaration <span style="color:red">**accessibility 取决于 access specifier**</span> )
    - 比如using declaration is <span style="color:red">**private**</span>, name is accessible to <span style="color:red">**members** and **friends** only</span>
    - using declaration is <span style="color:red">**public**</span>, name is available to <span style="color:red">**all users of the class**</span>
    - using declaration is <span style="color:red">**protect**</span>, name is available to <span style="color:red">**memeber, friends, derived classes**</span>



下面例子 ```f3``` 看起来奇怪但是是okay 的, 因为用```Sneaky``` object 访问的是 ```Base``` 的member, ```Pal```is a friend of ```Base```. 
```c++
class Base {
    // added friend declaration; other members as before

    friend class Pal; // Pal has no access to classes derived from Base

protected:
    int prot_mem;
};
class Sneaky: public Base{
    int j;
};
class Pal { 
public:
    int f(Base b) { return b.prot_mem; } // ok: Pal is a friend of Base

    int f2(Sneaky s) { return s.j; } // error: Pal not friend of Sneaky 
    
    // access to a base class is controlled by the base class, even inside a derived  object

    int f3(Sneaky s) { return s.prot_mem; } // ok: Pal is a friend 

};
```

```c++
// D2 has no access to protected or private members in Base 

class D2 : public Pal {
    public:
     int mem(Base b)
        { return b.prot_mem; } // error: friendship doesn't inherit

};
```

**change access level**: 下面例子 因为use **private inheritance**. 所以```size``` and ```n``` 是 private members of ```Derived```. The <span style="color:red">**using declarations** adjust the **accessibility**</span> of these members.

```c++
class Base { 
public:
    std::size_t size() const { return n; } 
protected:
    std::size_t n;
};
class Derived : private Base { // note: private inheritance 

public:
    // maintain access levels for members related to the size of the object

    using Base::size; 
protected:
    using Base::n;
};
```

**Default Inheritance Protection Levels**

By default, a derived class defined with the **class** keyword has **private** inheritance; a derived class defined with **struct** has **public** inheritance:
- 尽管class 是private by default, 但是<span style="color:red">最好explicit specify **private**</span>(make it clear)

```c++
class Base { /* ... */ };
struct D1 : Base { /* ... */ }; // public inheritance by default 

class D2 : Base { /* ... */ }; // private inheritance by default

```

#### (g). Class Scope under Inheritance

- 每一个class 都define 了自己的scope. <span style="color:red">在inheritnace, scope of derived class nested inside scope of base classes</span>. 
    - 如果在当前class scope 内 a name unresolved, 会继续search for a definition in enclosing base-class scopes.
- <span style="background-color:#FFFF00">**Name Lookup Happens at Compile Time**</span>: The **static type** of an object, reference, or pointer <span style="color:red">determines which members of that object are visible</span>. 即使当dynamic types 出现时, 仍用static type determines what members can be used. 看下面例子
- Name Collisions: a derived class can **reuse**(redefine) a name defined in direct or indirect base classes. <span style="color:red">Names defined in an inner scope (e.g., a derived class) hide name in the outer scope(base class)</span>
    - <span style="background-color:#FFFF00">use a hidden base-class member by using the **scope operator**</span>: can <span style="color:red">**overrides the normal lookup**</span> and directs the compiler to <span style="color:red">look for in the scope of class Base</span>.
    - 除了override virtual, derived class 不应该reuse names defined in its base class.
    - 如果Derived class override function from base, 但也<span style="color:red">想要base all overloaded instances of that function available(而不是hide) in derived class cope</span>, 可以提供 <span style="color:red">**using declaration**</span>, specifies only a name, 不需要parameter list.

**Name Lookup and Inheritance**: Given call ```p->mem()```, following 4 steps happen: <span style="background-color:#FFFF00">**Name lookup before Type Checking**</span>
1. determine the static type of ```p```, 因为我们call member, type 必须是class type 
2. Look for ```mem``` in class that correponds to **static type** of ```p```. 如果```mem``` 没有找到, look in direct class, chain of classes 直到 ```mem``` 被发现. 如果```mem``` 没有被发现, call won't compile
3. 一旦```mem``` 被找到, do the normal <span style="color:red">**type checking**</span> to see if call is legal given  the definition that was found
4. 假设call is legal, compiler generate code, 取决于if call is virtual or not
    - 如果 ```mem``` is <span style="color:red">**virtual**</span> and call is made through **reference** or **pointer**, compiler gnerates code to <span style="color:red">determine at run time which version to run 基于 **dynamic type**</span> of the object
    - 如果 call is nonvirtual, or if the <span style="color:red">call is on object 而不是reference or pointer</span>, compiler gnerates a <span style="color:red">normal function call</span>, 即使是pointer 和 reference, 也是由**static type** 决定call 哪个versio
5. 注意:  <span style="background-color:#FFFF00">**Name lookup before Type Checking**</span>: 如果a member in a derived class (i.e., in an inner scope) <span style="background-color:#FFFF00">**has the same name** as a base- class member</span>(i.e., a name defined in an outer scope), <span style="color:red">derived member 会 **hides** base-class member 在derived class scope 内(即使function have different parameter lists is different for derived class and base class)</span>
    - 但是<span style="color:red">可以用**scope operator** call base class version </span>
    - 如果<span style="color:red">base 和 derived 的 virtual function 的parameter list 不同</span>, no way to call derived version through a reference or pointer to base class 


比如下面例子call ```isbn```:
    1. search ```isbn``` in ```Bulk_quote```, not found 
    2. search ```isbn``` 在 ```Disc_quote``` (```Bulk_quote``` derived from ```Disc_quote```), not found
    3. search ```isbn``` 在 ```Quote``` (```Disc_quote``` derived from ```Quote```), use of ```isbn``` is resolved

```c++
Bulk_quote bulk;
cout << bulk.isbn();
```

<span style="background-color:#FFFF00">Static type determines what members can be used</span>. 比如下面例子, 给```Disc_quote``` 加了一个public member. (继承是Quote<-Disc_quote<- Bulk_quote) 尽管```bulk```确实含有```discount_policy``` 对于```itemP``` 却是看不见的, ```itemP``` 是 ```Quote``` 的指针, 意味着对```discount_policy``` <span style="background-color:#FFFF00">搜索从 ```Quote```开始</span>, 但是```Quote``` 不包含名为 ```discount_policy``` 的成员。所以无法通过```Quote``` 的对象, 引用，指针 call ```discount_policy```

```c++
class Disc_quote : public Quote { 
public:
    std::pair<size_t, double> discount_policy() const { 
        return {quantity, discount}; 
    }
// other members as before 

};

Bulk_quote bulk;
Bulk_quote *bulkP = &bulk; // static and dynamic types are the same 

Quote *itemP = &bulk; // static and dynamic types differ 

bulkP->discount_policy(); // ok: bulkP has type Bulk_quote* 

itemP->discount_policy(); // error: itemP has type Quote*

```

**Name Collision**: Derived class ```mem``` hide 了 base class 的 ```mem```

```c++
struct Base {
    Base(): mem(0) { }
protected:
    int mem;
};
struct Derived : Base {
    Derived(int i): mem(i) { } // initializes Derived::mem to i 
    
                                // Base::mem is default initialized

    int get_mem() { return mem; } // returns Derived::mem 

protected:
    int mem; // hides mem in the base 
    
};

Derived d(42);
cout << d.get_mem() << endl; // prints 42
```

可以use scope operator to use 被隐藏的base-class member, 比如 .The <span style="background-color:#FFFF00">scope operator **overrides the normal lookup**</span> and directs the compiler to look for ```mem``` starting in the scope of class Base.

```c++
struct Derived : Base {
    int get_base_mem() { return Base::mem; }
};
```

**Name Lookup**

```c++
struct Base {
    int memfcn(); 
};
struct Derived : Base {
    int memfcn(int);
    // hides memfcn in the base
    
};
Derived d; Base b;
b.memfcn(); // calls Base::memfcn

d.memfcn(10); // calls Derived::memfcn

d.memfcn(); // error: memfcn with no arguments is hidden d.Base::memfcn(); 

d.Base::memfcn();// ok: calls Base::memfcn

```

```D1``` 的 ```fcn``` 并没有覆盖 ```Base``` 的virtual (<span style="color:red">**不是override, 而是hide** ```fcn```</span>), 因为是<span style="background-color:#FFFF00">parameter list 不同</span>. D1 有两个函数```fcn```, 一个是从 Base 继承的virtual, 一个是自己定义nonvirtual and takes an int parameter. 

```c++
class Base { 
public:
    virtual int fcn();
};
class D1 : public Base {
public:
    // hides fcn in the base; this fcn is not virtual

    // D1 inherits the definition of Base::fcn()

    int fcn(int); // parameter list differs from fcn in Base 
    
    virtual void f2(); // new virtual function that does not exist in Base

};

class D2 : public D1 { 
public:
    int fcn(int); // nonvirtual function hides D1::fcn(int) 
    
    int fcn(); // overrides virtual fcn from Base 
    
    void f2(); // overrides virtual f2 from D1
    
};
```

- 前三条语句都是通过pointers to base class call 的. 因为 ```fcn``` 是virtual, compile run time 根据pointer bound的对象 决定哪个version to call. ```bp2``` underlying object 是 ```D1```. class 没有override ```fcn``` function that takes no argument. 所以call Base 的version 
- 接下来三条 calls are through pointers with differing types. ```bp2->f2(); ``` is illegal 因为没有 static type of ```bp2``` is ```Base```, no ```f2()``` in Base. 
- 最后三组, <span style="color:red">**dynamic type** doesn't matter when call a nonvirtual function</span>. The version that is called <span style="color:red">depends only on the **static type**</span> of the pointer.

```c++
Base bobj; D1 d1obj; D2 d2obj;
Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj; 

bp1->fcn(); // virtual call, will call Base::fcn at run time 

bp2->fcn(); // virtual call, will call Base::fcn at run time

bp3->fcn(); // virtual call, will call D2::fcn at run time


D1 *d1p = &d1obj; D2 *d2p = &d2obj;
bp2->f2(); // error: Base has no member named f2 

d1p->f2(); // virtual call, will call D1::f2() at run time

d2p->f2(); // virtual call, will call D2::f2() at run time


Base *p1 = &d2obj; D1 *p2 = &d2obj; D2 *p3 = &d2obj; 
p1->fcn(42); // error: Base has no version of fcn that takes an int 

p2->fcn(42); // statically bound, calls D1::fcn(int)

p3->fcn(42); // statically bound, calls D2::fcn(int)

```

下面例子okay的, 注意顺序, 
1. 声明Derived, 因为Base 中的friend  用到derived类
2. 定义Base 类, 因为只有Base定义了, 才能作为Base Class 用于Derived class
3. Derived Class 再 friend function 前, 因为friend function 用到了 derived function 的member
4. 因为```get``` 是Base friend, 所以可以access Base的中所有member, 即使是通过Derived class 来access的, 但是不可以通过Derived class 访问Derived 的member

```c++
class Derived;

class Base {
protected:
   int i = 10;
public:
   friend void get(Derived& d);
};
class Derived: public Base {
protected:
   int j = 5;
};

void get(Derived& d) {
   cout << " friend" << d.i << endl;
}
Derived i;
get(i);
```




#### (h). Constructors and Copy Control

**1. Virtual Destructors**
- <span style="color:red">**Base classes** ordinarily should define a **virtual destructor**</span>. Virtual destructors are needed even if they do no work.
- **destructor** is run when we delete a pointer to a **dynamically allocated** object
- 有可能 <span style="color:red">**static type** of pointer 与 **dynamic types** of pointer 指向 不同object 的情况(inheritance) </span>. 需要run proper **destructor** by defining the destructor as **virtual** in the base class
- Like any other virtual, the **virtual** nature of the destructor is **inherited**
- Executing ```delete``` on a pointer to base that points to a derived object has <span style="color:red">**undefined**</span> behavior <span style="color:red">if the base’s destructor is not virtual</span>.
- base class needs a virtual destructor还有个重要影响:  <span style="background-color:#FFFF00">如果有destructor, even if use ```=default``` to use sythesize version, compiler 不会sythesize **move operation** (copy 是 deprecated) for that class</span>

```c++
class Quote { 
public:
    // virtual destructor needed if a base pointer pointing to a derived object is deleted
    
    virtual ~Quote() = default; // dynamic binding for the destructor 

};

Quote *itemP = new Quote; // same static and dynamic type 

delete itemP; // destructor for Quote called

itemP = new Bulk_quote;  // static and dynamic types differ

delete itemP;  // destructor for Bulk_quote called

```

**2.Synthesized Copy Control and Inheritance**

- <span style="color:red">constructor 顺序: base -> derived. Destructor 顺序(**reverse order**) : derived -> base</span>. 当base-class constructor executing, derived part unititialized. 当base-class destructor run, derived part 已经被destoryed
    - 所以在base class destructor execute member, the object is **incomplete**, 因为derived part 已经被删除
    - To accommodate this incompleteness, the compiler treats the object <span style="color:red">**type changes** during construction or destruction</span>. If a constructor or destructor calls a **virtual**, the **version** that is run is the one 与call 的 constructor/destructor 类型相同.
        - 在base constructor 里call virtual function, call base class version. 因为base class members 的还没有生成 
- derived class **destructor** 只负责clean 自己的, 不用负责clean base class (implicitly destoryed, base class 是virtual destructor). 

    
**copy control**:
- If the <span style="background-color:#FFFF00">**default constructor**, **copy constructor**, **copy-assignment operator**, **move constructor**, **move-assignment operator**, or **destructor**</span> in the <span style="background-color:#FFFF00"> **base class** is **deleted** or **inaccessible**</span> , then the corresponding member in the <span style="color:red">derived class</span>  is defined as <span style="color:red">**deleted**</span> , because the compiler can’t use the base-class member to construct, assign, or destroy the base-class part of the object.
- If the <span style="background-color:#FFFF00">**base class** has an **inaccessible** or **deleted destructor**</span>, then the <span style="color:red">**synthesized default and copy/move constructors** in the **derived classes** are defined as **deleted**</span>, because there is no way to destroy the base part of the derived object.



下面因为copy constructor defined, <span style="background-color:#FFFF00">不会生成move constructor</span> for class B, 因为 B 不能copy or move
```c++
class B{
public:
    B();
    B(const B&) = delete;
    // other members, not including a move constructor

};
class D : public B {
};
D d; // ok: D's synthesized default constructor uses B's default constructor 

D d2(d); // error: D's synthesized copy constructor is deleted

D d3(std::move(d)); // error: implicitly uses D's deleted copy constructor

```

因为大多数base class 定义了 virtual destructor. 因此 base classes 不会生成 move operations (copy operations deprecated). 从而derived class 也不 synthesized.如果定义move, 也应该定义copy, 因为只定义move, copy 不会生成. 下面例子
```Quote``` objects will be memberwise **copied**, **moved**, **assigned**, and **destroyed**. Moreover, classes derived from ```Quote``` will automatically obtain synthesized move operations as well

```c++
class Quote { 
public:
    Quote() = default; // memberwise default initialize 
    
    Quote(const Quote&) = default; // memberwise copy 
    
    Quote(Quote&&) = default; // memberwise copy

    Quote& operator=(const Quote&) = default; // copy assign Quote& 
    
    operator=(Quote&&) = default; // move assign 
    
    virtual ~Quote() = default;
    // other members as before 

};
```

```

**Derived-Class Destructor**

```c++
class D: public Base { 
public:
    // Base::~Base invoked automatically
    
    ~D() { /* do what it takes to clean up derived members*/ }
};
```

**3. Derived-Class Copy/Move constructor**

- When a <span style="background-color:#FFFF00">**derived class**</span> defines a <span style="background-color:#FFFF00">**copy** or **move** operation</span>, that operation is responsible for copying or moving the entire object, including <span style="color:red">**base-class** members</span>
    - derived <span style="color:red">**synthesized copy constructor**</span> 会自动call base (synthesized or defined) constructor 
    - derived <span style="color:red">**defined copy constructor**</span> 但没有call base copy constructor, 会<span style="color:red">call **base default constructor**</span>，因为没有explicitly 指出, 所以B 的copy constructor 会先initialize base member using base default constructor. 
    - derived <span style="color:red">defined copy constructor call base copy constructor</span>, <span style="color:red">**explicitly call** base copy constructor</span> in <span style="color:red">derived’s copy constructor **initializer list**</span> 这样initialize base member using base copy constructor. 
    - 如果self-define assignment operator in derived class, 同理必须**explicitly** **call copy / move assignment operator** in derived class copy/move assignment operator 

```c++
//derived synthesized copy constructor

class A {
public:
    A() {
        std::cout << "A::Default constructor" << std::endl;
    }
    A(const A& rhs) {
        std::cout << "A::Copy constructor" << std::endl;
    }
};
class B : public A {
public:
    B() {
        std::cout << "B::Default constructor" << std::endl;
    }
};

std::cout << "Creating B" << std::endl;
B b1;
std::cout << "Creating B by copy" << std::endl;
B b2(b1);
/*
Creating B

A::Default constructor

B::Default constructor

Creating B by copy

A::Copy constructor
*/
```


```c++
class A {
public:
    A() {
        std::cout << "A::Default constructor" << std::endl;
    }
    A(const A& rhs) {
        std::cout << "A::Copy constructor" << std::endl;
    }
};
class B : public A {
public:
    B() {
        std::cout << "B::Default constructor" << std::endl;
    }
    B(const B& rhs) {
        std::cout << "B::Copy constructor" << std::endl;
    }
};
std::cout << "Creating B" << std::endl;
B b1;
std::cout << "Creating B by copy" << std::endl;
B b2(b1);
return 0;
/*
Creating B

A::Default constructor

B::Default constructor

Creating B by copy

A::Default constructor

B::Copy constructor
*/
```

```c++
class A {
public:
    A() {
        std::cout << "A::Default constructor" << std::endl;
    }
    A(const A& rhs) {
        std::cout << "A::Copy constructor" << std::endl;
    }
};

class B : public A {
public:
    B() {
        std::cout << "B::Default constructor" << std::endl;
    }
    B(const B& rhs):A(rhs) {
        std::cout << "B::Copy constructor" << std::endl;
    }
};

std::cout << "Creating B" << std::endl;
B b1;
std::cout << "Creating B by copy" << std::endl;
B b2(b1);
/*
Creating B

A::Default constructor

B::Default constructor

Creating B by copy

A::Copy constructor

B::Copy constructor
*/
```

注意下面 ```Base(d)``` pass ```D``` object to base-class constructor 是 **derived-to-base conversion**. 因为base class copy constructor 接受是 const reference and copy the base part of ```d```. 假如copy constructor 忽略 base initializer ```Base(d)```, 那么Base 的  <span style="color:red">**default constructor**</span> 用于 initialize base part. 

```c++
class Base{/* ... */}; 
class D: public Base { 
public:
    // by default, the base class default constructor initializes the base part of an object 
    
    // to use the copy or move constructor, we must explicitly call that

    // constructor in the constructor initializer list

    D(const D& d): Base(d) // copy the base members

    /* initializers for members of D */ { /* ... */ }
    
    D(D&& d): Base(std::move(d)) // move the base members

    /* initializers for members of D */ { /* ... */ }
 };
``` 
 
D 的<span style="color:red">**assignment operator**</span>, 注意因为是<span style="color:red">self-define assignment operator 并不会自动call base class synthesized/self-define assignment operator</span>,
```c++
// Base::operator=(const Base&) is not invoked automatically 

D &D::operator=(const D &rhs)
{
    Base::operator=(rhs); // assigns the base part

    // assign the members in the derived class, as usual,

    // handling self-assignment and freeing existing resources as appropriate 
    
    return *this;
}
```



#### (i). Inherited Constructors: 
- Class <span style="background-color:#FFFF00">*可以继承**base constructor**</span>, 但 <span style="color:red">**cannot inherit** the default, copy, and move constructors</span>. If the derived class does not directly define these constructors, the compiler synthesizes them 
    - inherit base-class constructor by providing a <span style="color:red">**using declaraction**</span> that names its (direct) base class
    - 通常情况下using declaration only <span style="color:red">makes a name **visible** in the current scope</span>. When applied to a <span style="color:red">**constructor**, a **using declaration** causes the compiler to **generate code**</span>. 因此对于<span style="color:red">每一个constructor in base</span>, compiler generates a constructor in derived that <span style="color:red">has the same parameter list</span>
        - These compiler-generated constructors have the form ```derived(parms) : base(args) { }```
        - 如果derived class 有任何data members of its own, 都**default initialized**

```c++
class Bulk_quote : public Disc_quote { 
    public:
    using Disc_quote::Disc_quote; // inherit Disc_quote's constructors 
    
    double net_price(std::size_t) const;
};

//using Disc_quote::Disc_quote 等同于

Bulk_quote(const std::string& book, double price, std::size_t qty, double disc):
    Disc_quote(book, price, qty, disc) { }
```



**Characteristics of an Inherited Constructor**
- Unlike using declarations for ordinary members, a constructor using declaration <span style="background-color:#FFFF00">does not **change the access level**</span> of the inherited constructor(s). 比如regardless of where the using declaration, base 的private constructor 在derived 还是private, base 的 protected constructor 在 derived 还是 protected 
-  a using declaration <span style="background-color:#FFFF00">**can’t specify explicit or constexpr**</span>. If a constructor in the base is explicit or constexpr , the <span style="color:red">
inherited constructor has **the same property**</span>
- If a base-class constructor has <span style="background-color:#FFFF00">**default arguments**</span>, those arguments <span style="background-color:#FFFF00">are not **inherited**</span>. Instead, the derived class gets <span style="color:red">**multiple inherited constructors**</span> in which each parameter with a  <span style="color:red">default argument is **successively omitted**</span>. 
    - 比如base class 有一个constructor with two parameters, second has default-value, 在derived class 将会有两个constructors, 一个with both parameters (第二个没有default), 另一个只有一个parameters(left-most, non-defaulted parameter) 
- derived class 会继承大多数base constructor,但有两个例外
    - 例外一: <span style="color:red">derived class defines a constructor with **the same parameters** as base class</span>, base 这些constructor 不会继承, <span style="color:red">derived defined constructor 会 代替 base 的</span>
    - 例外二: <span style="background-color:#FFFF00">**default**, **copy**, and **move constructor** 不会被inherited</span>. 这些函数不被继承, 而<span style="color:red">按照规则被synthesize</span>  
- <span style="background-color:#FFFF00">**Inherited constructor** 不被 treat as **user-defined** constructor</span>, 因为class <span style="color:red">只包括了 inherited constructor 会有 synthesized default constructor</span>

#### (j). Containers and Inheritance

不能push object in vector, 比如Quote 是 Bulk_quote 的base, 让 ```vector``` 存```Quote```, 但是当push ```Bulk_quote``` 进vector, vector 存放的就不在是 ```Bulk_quote``` object, 因为<span style="color:red">进行了 **derived-to-base** conversion(在copy constructor, not pointer/reference) and derived part is ignored</span>
```c++
vector<Quote> basket; 
basket.push_back(Quote("0-201-82470-1", 50));
// ok, but copies only the Quote part of the object into basket 

basket.push_back(Bulk_quote("0-201-54848-8", 50, 10, .25)); 

// calls version defined by Quote, prints 750, i.e., 15 * $50

cout << basket.back().net_price(15) << endl;
```

- **Put (Smart) Pointers, Not Objects, in Containers**: When we <span style="color:red">need a container that holds objects related by **inheritance**</span>, we typically define the container to hold pointers (preferably smart pointers) to base class.

下面例子中的```basket.back()->net_price``` 取决于**dynamic type** 的version. <span style="background-color:#FFFF00">**Derived-to-Base conversion** 也适用于 smart pointer</span>, we can also convert a smart pointer to a derived type to a smart pointer to an base-class type. ```make_shared<Bulk_quote>``` returns a ```shared_ptr<Bulk_quote>``` object, which is converted to ```shared_ptr<Quote>```
```c++
vector<shared_ptr<Quote>> basket; 
basket.push_back(make_shared<Quote>("0-201-82470-1", 50)); 
basket.push_back(
    make_shared<Bulk_quote>("0-201-54848-8", 50, 10, .25)); 
// calls the version defined by Quote; prints 562.5, i.e., 15 * $50 less the discount 

cout << basket.back()->net_price(15) << endl;
```

**Basket Class**

- 使用multiset, no less-than operator for ```shared_ptr```, 因此必须<span style="background-color:#FFFF00">provide our own **comparison operator**</span> to order elements, 定义了个private **static member**, compared isbn
- ```upper_bound``` 在```multiset``` 中用的很巧妙, 跳过相同的所有元素
- ```print_total```  调用了 virtual call to ```net_price```, resulting price <span style="color:red">取决于**dynamic type**</span> of ```**iter```
- Users of Basket still have to **deal with dynamic memory**,因为 ```add_item``` takes a ```shared_ptr```
    - 可以redefine ```add_item``` to take a ```Quote``` object instead of ```shared_ptr```. 

```c++
class Basket { 
public:
    //Basket uses synthesized default constructor and copy-control members

    void add_item(const std::shared_ptr<Quote> &sale) { items.insert(sale); }

    // prints the total price for each book and the overall total for all items in the basket

    double total_receipt(std::ostream&) const; 

private:
    // function to compare shared_ptrs needed by the multiset member

    static bool compare(const std::shared_ptr<Quote> &lhs,
        const std::shared_ptr<Quote> &rhs) 
    { return lhs->isbn() < rhs->isbn(); }
    // multiset to hold multiple quotes, ordered by the compare member

    std::multiset<std::shared_ptr<Quote>, decltype(compare)*>items(compare);
};


double Basket::total_receipt(ostream &os) const {
    double sum = 0.0;
    // iter refers to the first element in a batch of elements with the same ISBN

    // upper_bound returns an iterator to the element just past the end of that batch 

    for (auto iter = items.cbegin(); 
            iter!=items.cend();
            iter = items.upper_bound(*iter)) {
            // we know there's at least one element with this key in the Basket 
            
            // print the line item for this book

            sum += print_total(os, **iter, items.count(*iter)); 
            //*iter, shared_ptr, **iter is Quote object in shared_ptr

    }    
    os << "Total Sale: " << sum << endl; // print the final overall total

    return sum;

}

//user 

Basket bsk;
bsk.add_item(make_shared<Quote>("123", 45)); 
bsk.add_item(make_shared<Bulk_quote>("345", 45, 3, .15));
```

重新定义 ```add_item```, 但可能不正确, 比如下面定义的, somewhere there will be a new expression 例如 ```new Quote(sale)```. 不幸的是, expression won't do right thing: 因为```sale``` 可能不是 ```Quote```, 而是Derived class ```Bulk_quote``` the object will be <span style="color:red">**sliced down**</span>.
```c++
void add_item(const Quote& sale); // copy the given object 

void add_item(Quote&& sale); // move the given object

```

**Clone Function**

- 解决上面的问题可以定义 **clone function**
- we have a **copy** and a **move** version of ```add_item```, we defined <span style="color:red">**lvalue** and **rvalue** versions of **clone**</span>. lvalue reference member copies itself into that newly allocated object; rvalue reference member moves its own data. 
- Like ```add_item```, ```clone``` is overloaded based on whether its is called on **lvalue** or **rvalue**
    - 需要注意的是 rvalue verson 的 ```sale``` 是<span style="color:red">**rvalue reference**</span>, 但<span style="color:red">```sale``` is **lvalue**</span>. 所以可以call ```move``` to bind an rvalue reference to ```sale```
- ```clone``` function is vritual. Whether ```Quote``` or ```Bulk_quote``` function is run, 取决于 **dynamic type** of ```sale```. 无论是copy or move, ```clone``` 返回a pointer to newly allocated object. 因为<span style="color:red">```shared_ptr``` support **derived-to-base conversion**</span>, we can bind a ```shared_ptr<Quote>``` to a ```Bulk_quote*```


```c++
class Quote { 
public:
    // virtual function to return a dynamically allocated copy of itself 
    
    // these members use reference qualifiers
    
    virtual Quote* clone() const & {return new Quote(*this);}
    virtual Quote* clone() && Quote(std::move(*this));}
    // other members as before

};
class Bulk_quote : public Quote {
    Bulk_quote* clone() const & {return new Bulk_quote(*this);}
    Bulk_quote* clone() &&  { return Bulk_quote(std::move(*this));}
// other members as before 

};

class Basket { 
public:
    void add_item(const Quote& sale) // copy the given object

    { items.insert(std::shared_ptr<Quote>(sale.clone())); }
    
    void add_item(Quote&& sale) // move the given object 
    
    { items.insert(
        std::shared_ptr<Quote>(std::move(sale).clone())); } // other members as before

};
```


**15.9. Text Queries Revisited**

把之前的shared_ptr 做了下更改加上了```get_file``` function 和 ```begin```, ```end``` iterator

```c++
//顺序 先run TextQuery query 然后再print result 

ifstream is("file.txt");
TextQuery tq(is);
QueryResult qr = tq.query("has");
print(cout, qr);

class QueryResult
{
     friend ostream& print(ostream&, const QueryResult&);
public:
     using line_no = vector<string>::size_type;
     QueryResult(string s, shared_ptr<set<line_no>>p, shared_ptr<vector<string>>f) :
	 sought(s), lines(p), file(f) {}
     shared_ptr<vector<string>>get_file() const {
	return file;
     }
     set<line_no>::const_iterator cbegin() const { return lines->cbegin();}
     set<line_no>::iterator begin() { return lines->begin(); }
     set<line_no>::const_iterator cend() const { return lines->cend(); }
     set<line_no>::iterator end() { return lines->end(); }
     string sought;
     shared_ptr<set<line_no>>lines;
     shared_ptr<vector<string>>file;
};

string make_plural(size_t ctr, const string& word, const string& ending) {
     return ctr > 1 ? word : word + ending;
}


ostream& print(ostream& os, const QueryResult& qr) {
     os << qr.sought << " occurs " << qr.lines->size()
	<< " " << make_plural(qr.lines->size(), "time", "s") << endl;

     for (auto num : *qr.lines) 
	 os << "(line " << num + 1 << " " << (*qr.file)[num] << endl;
     return os;
}

class TextQuery
{
public:
     TextQuery(ifstream&);
     QueryResult query(const string&) const;
private:
     using line_no = vector<string>::size_type;
     shared_ptr<vector<string>>file;
     map <string, shared_ptr<set<line_no>>>wm;
};

TextQuery::TextQuery(ifstream& is):file(new vector<string>) {
    string text;
    while (getline(is,text)) {
	int n = file->size();
	file->push_back(text);
	istringstream line(text);
	string word;
	while (line >> word) {
	     auto& lines = wm[word]; 
	     if (!lines) 
	          lines.reset(new set<line_no>);     
	     lines->insert(n); 
	}
    }
}

QueryResult TextQuery::query(const string& sought) const {
     static shared_ptr<set<line_no>>empty = make_shared<set<line_no>>();
     auto loc = wm.find(sought);
     if (loc == wm.end())
	return QueryResult(sought, empty, file);
     return QueryResult(sought, loc->second, file);
}
```

现在像改进上面方面让他们work for some operator 比如 ```&```, ```|```, ```~```, 比如下面例子
```
1 has 
2 not
3 has
5 not 
6 we do
```
run ```Query q = Query("1") & Query("has") | ~Query("not");```返回 
```
(（1 & has） | ~(not)) occurs 3 time 
(line 1) 1 has 
(line 3) 3 has 
(line 6) 6 we do 
```

通过定义operator overloading, 我们想让有这样的structure 
```
			
		Query_base 
		/    |      \
               /     |        \
	WordQuery   NotQuery   BinaryQuery
			       /   \
			      /     \
			 AndQuery    orQuery 
```

Query是user call, 如果call Query时
- 没有operator, 会initialze WordQuery 作为QueryBase(Query 的member), call eval 时 直接用``` t.query(单个word) ```, t是 TextQuery 类
- 如果周围有operator, 会右元的operator 中定义是 初始化AndQuery, OrQuery, or NotQuery 作为QueryBase(Query 的member)

因为Query 是QueryBase friend, 所以当最后eval时,call QueryBase 的private virtual 找 dynamic type(WordQuery? AndQuery? OrQuery? NotQuery?) 真正的virtual runtime version

```c++
//call 下面code 的方法是：

ifstream is("file.txt");
TextQuery tq(is);
Query q = Query("1") & Query("has") | ~Query("not");
QueryResult qr = q.eval(tq);
print(cout, qr);


//因为不能instanitate class, all members non public

//member of Query will call Query_base

//定义virtual private 是因为 call virtual 是右元 friend call, private 可以被access

class Query_base
{
     friend class Query;
protected:
     using line_no = TextQuery::line_no;
     virtual ~Query_base() = default;
private:
     virtual QueryResult eval(const TextQuery&) const = 0;
     virtual std::string rep() const = 0;
};


//private constructor: 因为operator 是 friend, 可以access 

class Query {
     friend Query operator~(const Query&);
     friend Query operator|(const Query&, const Query&);
     friend Query operator&(const Query&, const Query&);
public:
     Query(const string&);
     QueryResult eval(const TextQuery& t) const {
          return q->eval(t);
     }
     std::string rep() const {
          return q->rep();
     }
private:
     Query(std::shared_ptr<Query_base>query) : q(query) {}//可以有type conversion
     
     shared_ptr<Query_base>q;
};

std::ostream& operator<< (ostream& os, const Query& query) {
     os << query.rep();
     return os;
}


class WordQuery :public Query_base {
     friend class Query;
     WordQuery(const string& s) : query_word(s) {}
     QueryResult eval(const TextQuery& t) const override {
          return t.query(query_word);
     };
     std::string rep() const override {
          return query_word;
     }
     string query_word;
};


inline Query::Query(const std::string& s) : q(new WordQuery(s)) {}

class NotQuery : public Query_base {
     friend Query operator~(const Query&);
     NotQuery(const Query& q) : query(q) {}
     string rep() const { return "~(" + query.rep() + ")"; }
     QueryResult eval(const TextQuery& t)const override;
     Query query;
};

inline Query operator~(const Query& operand) {
     return shared_ptr<Query_base>(new NotQuery(operand));
}

//shared_ptr<Query_base>(new NotQuery(operand)); 等同于

//allocate a new NotQuery objet and 

//binding the result NotQuery pointer to a shared_ptr<Query_base>

//shared_ptr<Query_base> tmp ( new NotQuery(expr)); 

// return Query(tmp);


//注意: BinaryQuery 没有define eval 继承 pure Virtual. BinaryQuery是abstract class

class BinaryQuery : public Query_base {
protected:
     BinaryQuery(const Query& l, const Query& r, string s) :
          lhs(l), rhs(r), opSym(s) {}
     string rep() const override {
          return "(" + lhs.rep() + " " + opSym + "" + rhs.rep() + ")";
     }
     Query lhs, rhs;
     string opSym;
};



//AndQuery 和 OrQuery 继承 BinaryQuery的rep, 但是overrides the eval function

class AndQuery :public BinaryQuery {
     friend Query operator& (const Query&, const Query&);
     AndQuery(const Query& left, const Query& right) :
     BinaryQuery(left, right, "&") {}
     QueryResult eval(const TextQuery&)const override;
};

inline Query operator&(const Query& lhs, const Query& rhs) {
     return shared_ptr<Query_base>(new AndQuery(lhs, rhs));
}

class OrQuery : public BinaryQuery {
     friend Query operator| (const Query&, const Query&);
     OrQuery(const Query& left, const Query& right) :
          BinaryQuery(left, right, "|") {}
     QueryResult eval(const TextQuery&) const override;
};

inline Query operator|(const Query& lhs, const Query& rhs) {
      return shared_ptr<Query_base>(new OrQuery(lhs, rhs));
}


//Or eval function, union

//因为lhs,rhs 都有一样file, get_file 来自于哪个都可以的

QueryResult  OrQuery::eval(const TextQuery& text) const {
     QueryResult right = rhs.eval(text), left = lhs.eval(text);
     auto ret_lines = make_shared<set<line_no>>(left.cbegin(), left.cend());
     ret_lines->insert(right.cbegin(), right.cend());
     return QueryResult(rep(), ret_lines, left.get_file());
}


//And eval function, interesection
QueryResult AndQuery::eval(const TextQuery& text) const {
     QueryResult right = rhs.eval(text), left = lhs.eval(text);
     auto ret_lines = make_shared<set<line_no>>(); 
     //不可以写 shared_ptr<set<lines_no>> ret_lines 否则是未初始化的pointer
     
     
     set_intersection(left.cbegin(), left.cend(), right.cbegin(), right.cend(),
		inserter(*ret_lines, ret_lines->begin()));
     shared_ptr<set<line_no>> rhs_ret_lines = 
     		make_shared<set<line_no>>(right.cbegin(), right.cend());
     return QueryResult(rep(), ret_lines, left.get_file());
}

//Not eval function,
QueryResult NotQuery::eval(const TextQuery& text)const {
     QueryResult result = query.eval(text);
     auto ret_lines = make_shared<set<line_no>>();
     auto it = result.cbegin(), end = result.cend();
     for (size_t i = 0; i < result.get_file()->size(); i++) {
          if (it != end && i == *it) ++it;
	  else ret_lines->insert(i);
     }
     return QueryResult(rep(), ret_lines, result.get_file());
}

```

























***

<br/><br/><br/>


## 16. Templates and Generic Programming

#### (a). Function Templates

- 比如overload functions and only parameter differs. 有多个repeat function body is <span style="color:red">**error-prone**</span>
  - 比如```compare``` function 可以overload很多个**built-in** type 版本, <span style="color:red">但是对于compare user-defined type(class) 无法work, 因为不知道 user 怎么定义class</span>


A template definition starts with the keyword <span style="background-color:#FFFF00">**template**</span> followed by a <span style="background-color:#FFFF00">**template parameter list**</span>, which is a <span style="background-color:#FFFF00">comma-separated list of one or more **template parameters**</span> bracketed by the less-than (<) and greater-than (>) tokens.

- Compare function 是 <span style="color:red">**reference to const**</span>. 确保types 不能被copied. 许多types, 包括built-in types 除了 ```unique_ptr``` 和 ```IO``` types 都可以copies. 不allow copy, make is faster for large objects
- 注: passing in 的 ypede只需要定义 ```<``` operator 既可以, 无需提供 ```>```, 如果concerned **type independence** and **portability**, 应该定义function using ```less``` , 原来版本缺陷是, 如果定义pointers. <span style="color:red">如果两个pointers not point to the array, code is undefined</span>

```c++
template<typename T>
int compare(const T& v1, const T& v2)
{
    if (v1 < v2) return -1;
    if(v2  < v1) return 1;
    return 0;
}

// version of compare that will be correct even if used on pointers; see § 14.8.2 (p. 575)

template <typename T> int compare(const T &v1, const T &v2)
{
    if (less<T>()(v1, v2)) return -1; 
    if (less<T>()(v2, v1)) return 1; 
    return 0;
}
```

- In a template definition, the <span style="background-color:#FFFF00">**template parameter list cannot be empty**</span>.
    - When use a template, 需要 specify either <span style="color:red">**implicitly** or **explicitly**</span> - **template arguments** to bind to the **template parameter(s)**. 
    - use name ```T``` to refer to a type. 实际type ```T``` determined at <span style="color:red">**compile time**</span> based on how ```compare``` is used. 
- 当 function template, compiler <span style="background-color:#FFFF00">uses the arguments of the call to **deduce template arguments**</span>. 比如下面例子argument 是 ```int```. The compiler deduce ```int``` as template argument and <span style="color:red">bind that to template parameter</span> ```T```. 
    - compiler uses the deduced template parameter(s) to **instantiate** a specific version of function. 会用<span style="color:red">**actual** template arguments 代替 corresponding template parameter(s)</span>
- <span style="color:red">**type parameter**</span>: 上面例子中的 ```T```. Type parameter 可以用作 <span style="background-color:#FFFF00">**return type**</span> or <span style="background-color:#FFFF00">**function parameter type**</span>, and for <span style="background-color:#FFFF00">**varaible declarations**</span> or <span style="background-color:#FFFF00">**casts**</span> inside the function
    - 每一个<span style="color:red">type parameter 前面</span>必须跟一个keyword <span style="color:red">**class** or **typename**</span>
- <span style="color:red">**Nontype Template Parameters**</span>: can define templates that nontype parameters. A **nontype parameter** represents a <span style="color:red">**value**</span> rather than a type. 
    - Nontype parameter 是 <span style="color:red">specified by type name</span> 而不是 keyword class or typename 
    -  <span style="color:red">An argument **bound** to a **nontype parameter** 必须是**constant expression**</span>. Arguments bound to a pointer or reference nontype parameter must have <span style="color:red">**static lifetime**(静态生存期, 在stack上, 而不是heap)</span> 所以<span style="color:red">不能是local(nonstatic) object or a dynamic object as **nontype template argument**</span> 来作为reference or pointer 的参数. A **pointer parameter** can also be instantiated by **nullptr** or a **zero-valued constant expression**
    - 当template is <span style="color:red">**instantiated**</span>, <span style="color:red">**nontype parameters**</span> are replaced with a <span style="color:red">**value**</span> supplied by the user or <span style="color:red">deduced by the compiler</span>. <span style="color:red">Values 必须是  **constant expression**</span>, 允许compiler to instantiate the templates during compile time.
- function template 可以被 declared ```inline``` or ```constexpr``` defined same as nontemplate function. ```inline``` 和 ```constexpr``` 需要在template paramerter list 之后, return type 之前
- Template programs should try to minimize the number of requirements placed on the argument types. (比如定义template 不能接受pointer 就是 minimize requirement of argument types)

Compiler 使用argument to deduce the type, 比如下面
```c++
// instantiates int compare(const int&, const int&)

cout << compare(1, 0) << endl; // T is int

vector<int> vec1{1, 2, 3}, vec2{4, 5, 6};
// instantiates int compare(const vector<int>&, const vector<int>&)

cout << compare(vec1, vec2) << endl; // T is vector<int>

```

**type parameter**
```c++
// ok: same type used for the return type and parameter 

template <typename T> T foo(T* p)
{
T tmp = *p; // tmp will have the type to which p points 

return tmp;
}

// error: must precede U with either typename or class

template <typename T, U> T calc(const T&, const U&);
```

**nontype parameter**

比如compare string literals. <span style="color:red">Literals are arrays of const char</span>. 我们不能copy an array, we'll define our <span style="color:red">parameters as **references** to array</span>. 我们想compare literals of different lengths, we give our template 两个 nontype parameters. 因为first template parameter 表示 size of first array, and second parameter 表示 size of second array. Compiler will use size of literals to instantiate a version of template with size 代替 N and M . 记住compiler <span style="color:red">插入一个 **null terminator** at the end of string literal</span>

```c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
return strcmp(p1, p2);
}
//call compare

compare("hi", "mom")
//等同于

int compare(const char (&p1)[3], const char (&p2)[4])
```

**inline and constexpr Function Templates**
```c++
// ok: inline specifier follows the template parameter list

template <typename T> inline T min(const T&, const T&);
// error: incorrect placement of the inline specifier

inline template <typename T> T min(const T&, const T&);
```

#### (b). Template Compilation

- When the compiler sees the definition of a template, it does not generate code. <span style="color:red">**generates code** only when we instantiate a **specific** instance of the template</span>. 
    - <span style="color:red">when **use** template 才generate code 而不是define 时候</span>, 这个affects how we organize our source code and when errors are detected
- 通常上call function, compiler 只需看见declaration for the function. 同样当使用 objects of class type, class definition 必须 available, 但是definitions of member functions 不需要present, 因此defintions and function declarations in header files and class-member functions 的definition in source files.
    - 但是template are different, To generate an instantiation, <span style="color:red">the compiler needs</span> to have the code that <span style="color:red">**defines a function template** or **class template member function**</span>. As a result, unlike nontemplate code, <span style="color:red">**Definitions** of **function templates** and **member functions** of class templates are ordinarily put into **header files**.</span>


**Key Concept: Templates and Headers**
- Templates contain two kinds of names: 
    - Those that do **not depend on** a template parameter 
    - Those that do **depend** on a template parameter
- 是template 作者保证 <span style="color:red">names **not depend on template parameter** 必须**visible** when template is used</span>.
- 此外, template 作者 必须保证 when template is instantiated, <span style="color:red">**definition of template**</span> including definitions of members of class template <span style="color:red">are **visible**</span> 
- <span style="color:red">user 保证 declarations for all functions, types and operators associated with they types(template parameter)</span> used to instantiate the template 是 visible  
- 为满足上面requirement, 
    - Authors of templates should provide a header that <span style="color:red">contains the **template definition** along with **declarations** for all the names used in the class template or in the **definitions** of its members</span>
    - Users of the template must include the header for the template and for <span style="color:red">**any types used to instantiate** that template</span>.
    - Users of the template <span style="color:red">需要保证arguments passed to the template support any operations that template uses 以及这些operations 可以在template 中正确工作</span>..

**Compilation Errors Are Mostly Reported during Instantiation**

- 通常compiler有三个stages 报告错误
    1. 第一阶段是 when <span style="background-color:#FFFF00">**compile** the template</span> itself. Compiler 不会find many errors at this stage. compiler 可能detect syntax errors 比如忘记semicolon or 错误拼写variable name 
    2. 第二个阶段是 when the compiler sees a <span style="background-color:#FFFF00">**use** of the template</span>. At this stage, there is <span style="color:red">still not much the compiler can check</span>.
        - For a call to a function template: check argument 数量是不是合适, check argument 是不是类型匹配
        - For a class template, the compiler check 是否提供了 正确数量的 template arguments
    3. 第三阶段是 during <span style="background-color:#FFFF00">**instantiation**</span>. <span style="color:red">只有这个阶段才能发现 **type related error**</span>, Depending on how the compiler manages instantiation, these <span style="color:red">**errors** may be reported at **link time**</span>. 但是template code 通常会做一些 被用到的types 假设 

比如下面. <span style="color:red">template 会做一些 被用到 type 假设, 比如下面假设 argument type 有 ```<``` operator</span>. 当compiler 处理 body of template, 不能verify 首付 condition in ```if``` 是 legal. 如果argument pass to ```compare``` 定义了 ```<``` 运算符, 代码是正确的, 否则是错误的. 比如```Sales_data``` 没有定义 ```<``` operator. <span style="color:red">这个错误直到 **instantiates the definition** of ```compare``` on type ```Sales_data```才被发现</span>.

```c++
if (v1 < v2) return -1; // requires < on objects of type T 

if (v2 < v1) return 1; // requires < on objects of type T 

return 0; // returns int; not dependent on T

Sales_data data1, data2;
cout << compare(data1, data2) << endl; // error: no < on Sales_data

```



#### (c). Class Template

- 不同于function template, <span style="color:red">compiler **cannot deduce** class template parameter types</span> 
    - user must specify element type is a list of <span style="background-color:#FFFF00">**explicit template arguments**</span> that are bound to the template's parameters. Compiler 用这些 template arguments to <span style="color:red">instantiate specific class</span> from template.
        - 当compile instantiates a class from template, 会 <span style="color:red">**rewrites** template</span>, <span style="color:red">replacing</span> each instance of the template parameter T by the <span style="color:red">given template argument</span>
        - 用一个template, template argument不同, 会<span style="background-color:#FFFF00">instantiate 不同的**distinct** classes</span>. Each **instantiation** of a class template <span style="color:red">constitutes an independent class</span>. The type ```Blob<string>``` has no relationship to, or any special access to, the members of any other Blob type.
- class template name 不是type, 当class template 被实例化, type always includes template argument(s).
- member function:
    - member <span style="color:red">defined **inside** the template class body are **implicitly inline**</span>
    - 每个instantiation of class has its **own version** of each member. 因此template class function 跟他们的template class itself <span style="color:red">都有一样的**template parameters**</span>. 所以在class 外面定义function, <span style="color:red">需要用 keyword ```template``` followed by class' template parameter list</span>
    - By default, a <span style="color:red">**member**</span> of an instantiated class template is <span style="color:red">**instantiated** only if the member is **used**</span>. member 再被用的时候才被初始化. <span style="color:red">如果function 不被用到,, it is not instantiated</span>
        - <span style="background-color:#FFFF00">这使得也许某一type 不 meet requirement for some template's operations. 我们也可以instatntiate a class with that type</span> (比如, template 有的function 需要这个type, 有```+``` overloading, 但是没有用到这个template function, 所以没关系)
    - 一个例外是: Inside the <span style="color:red">**scope of a class**</span> template, we may <span style="color:red">refer to the template without specifying template argument(s)</span>., 比如return type (value or reference, or inside template class function). 因为在class scope, <span style="color:red">compiler treats **references** to the template itself 就像提供了template arguments 一样</span>. 
    - 但是<span style="color:red">在template 外面定义时候, 记得return type is **not in class scope**, 需要提供template argument</span>. we are not in the scope of the class until the class name is seen
- template class 的声明 ```template<typename> class Blob``` 不用加T, 也可以加T ```template<typename T> class Blob``` 
- template operator 的定义 ```template<type T> bool operator==<T>(const Blob<T>&, const Blob<T>& );``` 只能用于```T``` 类的比较

e.g. 
```c++
template<typename T>class Blob{
public: 
    typedef T value_type;
    typedef typename vector<T>::size_type size_type;
    //constructors

    Blob();
    Blob(std::initializer_list<T>il);
    size_type size () const {return data->size();}
    bool empty() const {return data->empty();}
    //add and remove elements

    void push_back(const T & t) {data->push_back(t);}
    void push_back(const T &&t) {data->push_back(std::move(t));}
    void pop_back();
    T& back();
    T& operator[] (size_type i);
private: 
    std::shared_ptr<std::vector<T>>data;
    void check(size_type i, const std::string& msg) const;
};

Blob<int> ia; // empty 

Blob<int> Blob<int> ia2 = {0,1,2,3,4}; // Blob<int> with five elements

```

定义```Blob<int>``` 等同于 把所有```T``` 都换成 ```int```
```c++
template<> class Blob<int>{
    typedef typename std::vector<int>::size_type size_type; Blob();
    Blob(std::initializer_list<int> il);
    // ...

    int& operator[](size_type i);
private:
    std::shared_ptr<std::vector<int>> data;
    void check(size_type i, const std::string &msg) const;
};
```
不同的template argument 生成不同的class, 比如下面code would trigger instantiations of two distinct classes. 
```c++
Blob<string> names; // Blob that holds strings 

Blob<double> prices;// different element type

```

**定义template class member outside class**: 用keyword template +  template parameter, 因为每个template class instantiation 都有自己version of class. General form 如下
```c++
template <typename T>
ret-type Blob<T>::member-name(parm-list)
```
Blob function 定义 其中 subscript operator 和 ```back``` 还可以overload const version. constructor 有default constructor 和 接受```initializer_list```

```
template<typename T>
void Blob<T>::check（size_type i, const std::string &msg) const
{
    if (i >= data->size())
        throw std::out_of_range(msg);
}
template <typename T> T& Blob<T>::back()
{
    check(0, "back on empty Blob");
    return data->back();
}
template <typename T>
T& Blob<T>::operator[](size_type i)
{
    check(i, "subscript out of range"); 
    return (*data)[i];
}
template <typename T> void Blob<T>::pop_back()
{
    check(0, "pop_back on empty Blob");
    data->pop_back();
}
template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>>()) { }
template <typename T> Blob<T>::Blob(std::initializer_list<T> il):
data(std::make_shared<std::vector<T>>(il)) { }
```

Template member function <span style="color:red">**被实例化** 只当 程序use that member function</span>

```c++
//instantiates Blob<int> and the initializer_list<int> constructor

Blob<int> squares = {0,1,2,3,4,5,6,7,8,9}; 

// instantiates Blob<int>::size() const

for (size_t i = 0; i != squares.size(); ++i)
    squares[i] = i*i; // instantiates Blob<int>::operator[](size_t)

```
one exception to the rule that we must supply template arguments when we use a class template type. Inside the scope of the class template itself, we may <span style="color:red">use the name of the template without arguments</span>. 注意return type of prefix increment/decrement 返回 ```BlobPtr``` 和 ```BlobPtr&```, 而不是 ```BlobPtr<T>&```. 

```c++
// BlobPtr throws an exception on attempts to access a nonexistent element 

template <typename T> class BlobPtr{
public:
    BlobPtr(): curr(0) { } 
    BlobPtr(Blob<T> &a, size_t sz = 0):
        wptr(a.data), curr(sz) { } 
    T& operator*() const
    { 
        auto p = check(curr, "dereference past end");
        return (*p)[curr]; // (*p) is the vector to which this object points
    } 
    // increment and decrement

    BlobPtr& operator++(); // prefix operators 
    
    BlobPtr& operator--();
private:
    // check returns a shared_ptr to the vector if the check succeeds 
    
    std::shared_ptr<std::vector<T>>check(std::size_t, const std::string&) const;

    // store a weak_ptr, which means the underlying vector might be destroyed 
    
    std::weak_ptr<std::vector<T>> wptr;
    std::size_t curr; // current position within the array

};

//compiler treats references to the template itself 

//就像提供了template arguments 一样

BlobPtr& operator++(); 
BlobPtr& operator--();
//等同于

BlobPtr<T>& operator++(); 
BlobPtr<T>& operator--();
```
值得注意的是,return type 是outside scope of the class, 必须 specify that the return with the same type(template argument) as the class. 在function body, in scope of class and do not repeat template argument (当define ```ret```), <span style="color:red">compiler 会assumes we are using the same type as member's instantiation</span>. 

```c++
// postfix: increment/decrement the object but return the unchanged value 

template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
    // no check needed here; the call to prefix increment will do the check 
    
    BlobPtr ret = *this; // save the current value

    ++*this; // advance one element; prefix ++ checks the increment 
    
    return ret; // return the saved state

}
```

#### (d). Friends
- 当一个class 含有 friend declaration, class and friends 可以两个都是template, 一个是，或一个都不是. 
    - class template 有一个 nontemplate friend 保证了 <span style="background-color:#FFFF00">friend access to all the instantiation of the class template</span>
    - class template 有一个 template friend, 可以给all friend template 的class template access 或给 特定的 friend template 的class template access
- **class -> template class friend** (如果对应的friend template class 是唯一的关系, 需要forward declaration)
    - <span style="background-color:#FFFF00">**一对一关系: 用class 实例化template class**</span>. ，Template friend class 需要 <span style="background-color:#FFFF00">**forward declaration**</span>, ```class C; friend class Pal2<C>;```
    - <span style="background-color:#FFFF00">**一对多关系, 所有实例(instance)都是class friend**</span>. template class friend不需要foward declaration ```class C; template<typename X> class Pal2;``` 
- **template class -> class friend**
    - <span style="background-color:#FFFF00">**多对一关系**</span>: friend class 类不用forward declaration,  比如 ```template <typename T> class C2;``` 中声明 ```friend class Pal3;```
- **template class -> template class friend**, 
    - <span style="background-color:#FFFF00">**一对一关系**</span>，每个实例 将<span style="color:red">**相同实例化**</span> 声明为friend: Template friend 需要 <span style="background-color:#FFFF00">**forward declaration**</span>. e.g. ```template <typename T> class Pal;``` 中声明 ``` friend class Pal2<T>;```
    - <span style="background-color:#FFFF00">**多对多关系**</span>, 所有的实例都是 友元class 实例的 friend, template class friend<span style="color:red">不需要foward declaration</span>, 比如  ```template <typename T> class C2;``` 中声明 ```template <typename X> friend class Pal2; ```



**One-to-One Friendship** (只能是同一个type 之间的friendship)

最常见的friendship between 一个class template 和 其他的template (可以是class or function) 是建立在 friendship between instantiations of the class and its friends. 比如下面例子 ```Blob``` 有 friend ```BlobPtr``` 和 ```Blob``` equlity operator 

下面例子, 
- 需要先 声明 ```BlobPtr``` 和 ```Blob``` , 这些是 operator ```==``` 函数参数声明以及 ```Blob``` 友元声明需要的. 
- <span style="background-color:#FFFF00">Blob **friend declaratons** use Blob's **template parameter** as their own template argument</span>. 
- 因此friensdship 限定在相同type 实例化 的 Blob 和 BlobPtr 相等运算运算之前. members of ```BlobPtr<char>``` 可以access nonpublic parts of ```Blob<char>```, 但是 ```Blob<char>``` 对```Blob<int>``` 没有special access 或者 其他instantiation of ```Blob``` 

```c++
// forward declarations needed for friend declarations in Blob

template <typename> class BlobPtr;
template <typename> class Blob; // needed for parameters in operator== 

template <typename T>
    bool operator==(const Blob<T>&, const Blob<T>&); 

template <typename T> 
class Blob {
    // each instantiation of Blob grants access to the version of

    // BlobPtr and the equality operator instantiated with the same type
    
    friend class BlobPtr<T>; 
    friend bool operator==<T>
    	(const Blob<T>&, const Blob<T>&); 
    // other members as in § 12.1.1 

};

Blob<char> ca; // BlobPtr<char> and operator==<char> are friends 

Blob<int> ia; // BlobPtr<int> and operator==<int> are friends

```

**General and Specific Template Friendship**

- 一个class 可以make <span style="background-color:#FFFF00">**every instantiation**</span> of another template <span style="background-color:#FFFF00">its friend</span>, or <span style="background-color:#FFFF00">limit friendship to a **specific instantiation**</span>
  - <span style="color:red">**foward declaration**</span>: 将一个tempalte 的<span style="color:red">**specific instantiation**</span> 声明 成friend 是<span style="color:red">必须的</span>
  - 对于 <span style="color:red">**all instantiation** of template 被声明成 class 的friend, 不需要forward declaration</span>.
  - 对于 <span style="color:red">non-template class</span> 声明成 template(or non-template) class <span style="color:red">friend</span>, <span style="color:red">不需要 forward declaration</span>
  - 注意下面例子

```c++
//forward declaration:  necessary to  befriend a specific instantiation of a template

template<typename T>class Pal;
class C{// 注意C就是个普通的class

    friend class Pal<C>; //用class C 实例化 Pal 是 C的friend 

    //所有instantiation of Pal2 都是 C的friends;
    
    //因为是all instantiation friend 不需要forward declaration 
    
    template<typename T> friend class Pal2;
};

template<typename T>
class C2{ //C2 是 class template

    //each instatntiation of C2 has the same instance of Pal as friend 
    
    // C2 的每个实例 将相同的实例化的Pal 声明成friend 

    friend class Pal<T>; //a template declaration for Pal must be in scope 

    //all instances of Pal2 are friends of each instance of C2, 不需要forward declaration

    //Pal2 所有实例 都是C2 每个实例的友元

    template<typname X> friend class Pal2;

    //Pal3 nontemplate class  that is a friend of every instance of C2;

    friend class Pal3; //不需要前置声明的

};
```

<span style="background-color:#FFFF00">**Befriending the Template’s Own Type Parameter**</span>

- 可以让template type parameter be a friend. <span style="color:red">type 可以是 **built-in** type</span>


下面例子中, 无论是什么类型instantiate ```Bar``` is friend. 比如 ```Foo``` is friend of ```Bar<Foo>```, 即使通常上friend 是 class or function, 
```c++
template <typename Type>class Bar{
    friend Type; //Grants access to type used to instantiate Bar

};
```

#### (d). Type Aliases

- 可以用 ```typedef``` 在 template class refers to the <span style="color:red">**instantiated class**</span>, 比如 ```typedef Blob<string> StrBlob;```
- 因为template 不是 type, <span style="color:red">cannot define a typedef refers to a template</span>. 不能定义 a typedef  ```typedef Blob<T> TBlob```

比如下面例子, ```twin``` 用户只需指定一次类型, 而不用指定两次, ```twin<string,string>```. Users 对于```partNo```  只能specify type for the first member 不能choice about second 
```c++
typedef Blob<string> StrBlob;

template<typename T> using twin = pair<T, T>;
twin<string> authors; // authors is a pair<string, string>

twin<double> area; // area is a pair<double, double>


template <typename T> using partNo = pair<T, unsigned>; 
partNo<string> books; // books is a pair<string, unsigned> 

partNo<Vehicle> cars; // cars is a pair<Vehicle, unsigned>

```

#### (e). Static Members

- <span style="color:red">Each instantiation</span> of class has its <span style="color:red">**own instance**</span> of the <span style="color:red">**static members**</span>. 每一个class 实例都有自己的 static member 成员
- 与其他static data member 相同, <span style="color:red">只能有一个definition of each static</span> data member of a template class. class 外定义时候需要加 ```template parameter list```， <span style="color:red">**separate** ```ctr``` will be **instantiated** for different class instances 并初始化 0</span>
- <span style="color:red">可以access static member</span> through <span style="color:red">**an object of the class type**</span> or by <span style="color:red">using **scope operator**</span> to access member directly. Use a static member through the class, 必须refer to a <span style="color:red">**specific instantiation**</span>.
    - 不可以直接通过 class template 名字access static member without template argument, 比如 ```Foo::ctr```, <span style="color:red">**错误的**</span>


比如下面例子 对一个类型```X```, 比如```Foo<X>::ctr``` and ```Foo<X>::count```, <span style="color:red">共享同样</span>的```ctr``` 和 ```count``` function

```c++
template <typename T> class Foo { 
public:
    static std::size_t count() { return ctr; }
private:
    static std::size_t ctr; }; 
    // other implementation members

};

//定义static 

template<typename T> size_t Foo<T>::ctr = 0; //define and initailize ctr


// instantiates static members Foo<string>::ctr and Foo<string>::count 

Foo<string> fs;
// all three objects share the same Foo<int>::ctr and Foo<int>::count members 

Foo<int> fi, fi2, fi3;
```

访问static member 

```c++
Foo<int> fi; // instantiates Foo<int> class

            // and the static data member ctr

auto ct = Foo<int>::count(); // instantiates Foo<int>::count

size_t = Foo<int>::ctr; //okay
ct = fi.count(); // uses Foo<int>::count

ct = Foo::count(); // error: which template instantiation?

```


#### (f). Template Parameters

- template parameter name 没有内在含义, 通常用T, 可以用其他的名字
- Template Parameters and Scope
    - 像normal scoping rules. <span style="color:red">Name of template parameter can be used 在被declared 之后直到end of template declaration or defintion</span> 
    - <span style="background-color:#FFFF00">template parameters **hides** any declaration</span> of that name <span style="background-color:#FFFF00">in an outer scope</span>
    - 如果一个名字被 template parameter 用了, 不可以reused within the template. 所以name 不能被reused, 所以<span style="background-color:#FFFF00">**template parameter** 不能有**重名**</span>
- Template Declarations
    - A template <span style="background-color:#FFFF00">**declaration** must include the **template parameters**</span>
    - 对于given template，每一个declaration and definition 必须有一样 number and kind (type or nontype) of parameters
- Access class Types
    - 比如当我们用scope operator ```::```, 可以access <span style="background-color:#FFFF00">**type**</span> or <span style="background-color:#FFFF00">**static member**</span>. 但是对于template, <span style="color:red">template直到被**实例化**才知道是 type or static member</span>. 但是compiler 必须知道a name 是不是 type 才能 process. 
        - 比如 ```T::size_type *p```: compiler 需要知道我们是在define a variable named ```p``` 还是将 名为```size_type``` 的static 成员与 成员```p``` 想乘.
	- <span style="color:red">by default, languages assume access name through scope operator is not a type</span>. 当use type member of a template type parameter, must explicitly tell compiler that the name is a type by ```typename```
        - 克服上面问题, 必须显式告诉 compiler the name is type, by using  ```typename T::size_type *p```. When we want to <span style="color:red">inform the compiler that a name represents a **type**</span>, we must <span style="color:red">use the keyword **typename**, not class</span>.
- **Default Template Arguments**: default arguments for both function and class templates   
    -  像 function default argument, 只有它<span style="color:red">**右侧所有**parameters 都是 **default argument**</span>, 它才是default argument
    - 如果使用默认的template argment, 需要用空的 bracket pair ```<>``` following the template's name




template parameters 隐藏外层作用域的名字; 如果一个名字被用于template parameter, 不能用这个名字来命名其他type
```c++
typedef double A;
template <typename A, typename B> void f(A a, B b)
{
    A tmp = a; // tmp has same type as the template parameter A, not double

    double B; // error: redeclares template parameter B 

};

// error: illegal reuse of template parameter name V 

template <typename V, typename V> // ...
```

declaration, 必须包括了template parameter

```c++
// declares but does not define compare and Blob

template <typename T> int compare(const T&, const T&); 
template <typename T> class Blob;

// all three uses of calc refer to the same function template

template <typename T> T calc(const T&, const T&); // declaration 

template <typename U> U calc(const U&, const U&); // declaration 

// definition of the template

template <typename Type>
Type calc(const Type& a, const Type& b) { /* . . . */ }
```

显式告诉compiler we want to <span style="background-color:#FFFF00">use a **type member** of a template type parameter</span>, 用```typename T::value_type()```. Our ```top``` function expects a container as its argument and uses typename to specify its return type and to<span style="color:red"> generate a value initialized element if c has no elements</span>.
```c++
template <typename T>
typename T::value_type top(const T& c)
{
    if (!c.empty())
        return c.back();
    else
        return typename T::value_type();
}

```

**Default Template Arguments**

下面例子定义了a secnd type parameter 表示 callable object, specifies that ```compare``` will use library ```less``` function-object class, <span style="color:red">**instantiated** with the **same type** parameter</span> as ```compare```.  和 a new function parameter ```f``` that bound to a callable object.  The **default function** argument says that ```f``` will be a default-initialized object of type ```F```. function template parameter 可以被推断


```c++
// compare has a default template argument, less<T> 

// and a default function argument, F()

template<typename T, typename F = less<T>>
int compare(const T &v1, const T &v2, F f=F())
    if (f(v2, v1)) return 1;
    if (f(v1, v2)) return -1; return 0;
}

//因为function template parameter 可以被推断

bool i = compare(0, 42); // uses less; i is -1 , T is int

// result depends on the isbns in item1 and item2

Sales_data item1(cin), item2(cin);

bool j = compare(item1, item2, compareIsbn);
//T is Sales_data, F 是 type of compareIsbn

````

用空的尖括号 使用 default template arguments

```c++
template <class T = int> class Numbers { // by default T is int 

public:
    Numbers(T v = 0): val(v) { }
    // various operations on numbers private:

    T val;
};
Numbers<long double> lots_of_precision;
Numbers<> average_precision; // empty <> says we want the default type

```

#### (g). Member Templates
- 一个class (普通class or template class) 可能有<span style="color:red">member function itself is template, 这种members 叫做 **member templates**</span>. <span style="color:red">Member template **不能是** **virtual**</span>
- 一个普通class 可以有template member
- 一个template class 可以有template member, template class 和 template member 有各自的independent template parameters.
    - 当定义member template outside body of class tempalte, <span style="color:red">**class template parameter** list comes **first**, , followed by the **member’s** own **template parameter list**</span>:
    - **Instantiation**: 必须supply arguments for <span style="background-color:#FFFF00">**template parameters** for both **class** and **function templates**</span>
        - 与普通function template 类似: <span style="background-color:#FFFF00">compile **deduces** template arguments for the **member template**'s own parameter</span> from arguments passed in the call


**Member Templates of Ordianary (Nontemplate) Classes**

- a member template starts with its own **template parameter list**

比如定义类似 ```unique_ptr``` 的default deleter. class 有个 overloaded function-call operator that take a pointer and execute ```delete``` on given pointer. 因为想让deleter for any type, make call operator a template.  <span style="color:red">因为member function 是 template, compiler 可以从推断call 的类型</span>. 可以把```DebugDelete``` 用于 deleter of a ```unique_ptr```. 
```c++
class DebugDelete { 
public: 
    DebugDelete(std::ostream &s = std::cerr): os(s) { } 
    // as with any function template, the type of T is deduced by the compiler 
    
    template <typename T> void operator()(T *p) const
        { os << "deleting unique_ptr" << std::endl; delete p; }
private:
    std::ostream &os;
};
double *p = new double;
DebugDelete d;
d(p);  // calls DebugDelete::operator()(double*), which deletes p

int *ip = new int;
// calls operator()(int*) on a temporary DebugDelete object 

DebugDelete()(ip);
```

TO override the deleter of a a ```unique_ptr```. 必须supply tye type of the deleter inside brackets and supply an object of deleter type to **constructor**.
```c++
// destroying the the object to which p points

// instantiates DebugDelete::operator()<int>(int *)

unique_ptr<int, DebugDelete> p(new int, DebugDelete());

// destroying the the object to which sp points

// instantiates DebugDelete::operator()<string>(string*)

unique_ptr<string, DebugDelete> sp(new string, DebugDelete());

```

当```unique_ptr``` destructor instantiated, <span style="color:red">```DebugDelete``` call operator will be instantiated</span>. 上述定义会这样实例化

```c++
// sample instantiations for member templates of DebugDelete

void DebugDelete::operator()(int *p) const { delete p; } 
void DebugDelete::operator()(string *p) const { delete p; }
```

**Member Templates of Class Templates**

也可以定义class template 有自己的member template.  <span style="color:red">both the class and the member have their own, **independent**, t**emplate parameters**</span>


比如
```c++
template <typename T> class Blob {
    template <typename It> Blob(It b, It e);
    // ... 

};

//define outside class

template <typename T> // type parameter for the class 

template <typename It> // type parameter for the constructor

Blob<T>::Blob(It b, It e): data(std::make_shared<std::vector<T>>(b, e)) {
}

```

instantiation: 
- 定义```a1```时候, 显式specify compiler 应该instantiate ```Blob``` version 是 int, constructor's own paramerter 被deduced from type of ```begin(ia)``` 和 ```end(ia)``` 是 ```int*```. ```Blob<int>::Blob(int*, int*);```
- ```a2``` 是instantiated ```Blob<int>``` class and instantiates constructor with ```It``` replaced by ```vector<short>::iterator```
- ```a3```的定义实例化了一个 string 的 ```Blob```，constructor template parameter ```It``` bound to ```list<const char*>```

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
vector<long> vi = {0,1,2,3,4,5,6,7,8,9};
list<const char*> w = {"now", "is", "the", "time"}; 

// instantiates the Blob<int> class

// and the Blob<int> constructor that has two int* parameters 

Blob<int> a1(begin(ia), end(ia));

// instantiates the Blob<int> constructor that has

// two vector<long>::iterator parameters

Blob<int> a2(vi.begin(), vi.end());

// instantiates the Blob<string> class and the Blob<string>

// constructor that has two (list<const char*>::iterator parameters

 Blob<string> a3(w.begin(), w.end());
```

#### (h). Instantiations

- 当template 被用的时候 才实例化, 意味着: <span style="background-color:#FFFF00">**same instantiatio**n may appear in multiple object files</span>
    - When <span style="color:red">two or more separately compiled source files use the same template with the same template arguments</span>, 每一个soure file 中都含有template 的一个实例
    - 在large systems,  the <span style="color:red">**overhead** of instantiating the same template in multiple files can become significant</span>
    - 可以avoid this overhead through an **explicit instantiation** which suppress implicit instantiation. 包括了two parts: **explicit instantiation declaration** and **explicit instantiation definition** (Implicit instantiation 是：只有用到时候才instantiation )
        - 当<span style="color:red">
compile 看见 **extern template declaration**, **不会generate code** for that instantiation in that file</span> 
        -  Declaring an <span style="color:red">instantiation as **extern** 保证不会有 nonextern use</span> of that instantiation elsewhere in program. <span style="color:red">可以有多个 extern declarations for a given instantiation but **只能有一个 definition**</span> for that instantiation
        -  因为compiler 自动instantiates a template when use it, 所以 <span style="color:red">**extern declaration** 必须出现在code 使用实例化之前</span>
        -  file 的 ```.o``` 文件不会包括 被定义了 extern template classs的instantiation, 会包括没有被定义extern template class 的实例化. 
        -  There <span style="color:red">must be an **explicit instantiation definition(实例化定义)** somewhere in the program</span> for every instantiation declaration.
        -  当compiler 看见instantiation 定义(as opposed to a declaration), it generates code. 当build application, <span style="color:red">必须 link 有extern template definition 的 ```.o``` with 用到extern template的file</span> (e.g```Application.o```)
- <span style="background-color:#FFFF00">**Explicit Instantiation Definitions Instantiate All Members**</span>: 与普通class template instantiations 不同, <span style="color:red">compiler instantiates all member of that class 因为不知道which member functions the program uses. 即使没有用到这个member, member也会被实例化</span>. 
  - 因此, An instantiation definition can be <span style="color:red">used only for **types**</span> that can be used with <span style="color:red">**every member function**</span> of a class template.


> From StackOverflow <br/> <br/>
> <span style="color:red">**explicit instantiation** is useful **when creating library(.lib) files that uses templates** for distribution</span>, uninstantiated template definitions are not put into object (.obj) files.<br/><br/>
> 比如: ```std::basic_string<char,char_traits<char>,allocator<char> >``` (which is ```std::string```) so every time you use functions of std::string, <span style="color:red">the same function code doesn't need to be copied to objects</span>. The compiler only need to refer (link) those to ```libstdc++```.)

**An explicit instantiation**: 用下面的形式

```c++
extern template declaration; // instantiation declaration 

template declaration; // instantiation definition


//例子
// instantion declaration and definition

extern template class Blob<string>; // declaration

template int compare(const int&, const int&); // definition

```

例子1: 比如一个```Application.cc``` file: 比如 ```sa1```,```sa2```,```i``` 的instantiation 会出现在任其他位置, 而```a1```, ```a2```实例化 会只出现在这个file (```Application.cc```). <span style="background-color:#FFFF00">```Application.o``` 会包括了 ```Blob<int>``` along with the ```initializer_list``` 和 copy constructor. 但是```compare<int>``` function 和 ```Blob<string>```class 不会instantiated in ```Application.o```</span>. <span style="color:red">```compare<int>``` 和 ```Blob<string>```的  definitions 在其他 program file 中</span> 

```c++
// Application.cc

// these template types must be instantiated elsewhere in the program

extern template class Blob<string>;
extern template int compare(const int&, const int&); 
Blob<string> sa1, sa2; // instantiation will appear elsewhere

// Blob<int> and its initializer_list constructor instantiated in this file

Blob<int> a1 = {0,1,2,3,4,5,6,7,8,9};
Blob<int> a2(a1); // copy constructor instantiated in this file

int i = compare(a1[0], a2[0]); // instantiation will appear elsewhere

```

例子2: 实例化定义

```c++
///templateBuild.cc 

// instantiation file must provide a (nonextern) definition for every 

// type and function that other files declare as extern

template int compare(const int&, const int&);
template class Blob<string>; // instantiates all members of the class template

```

>from IBM: Implicit Instantiation:只有用到时候才初始化

- ```x<int>*q```: <span style="color:red">declare a pointer to class, class的definition not needed and class 不会implcitly instantiated</span>
- ```s->g()``` 才会实例化```X<float>``` and  ```X<float>::g()```
- compiler 不需要下面defintion 的实例化 
     -  <span style="background-color:#FFFF00">class X   当declare ```p```</span> 
     - ```X<int>``` when pointer q declared
     - ```X<float>``` when pointer s declared
- class 会implicitly instantiate 如果有<span style="background-color:#FFFF00">**pointer conversion**</span> or <span style="background-color:#FFFF00">**pointer to member conversion**</span> or <span style="background-color:#FFFF00">当delete pointer</span>
-  如果compiler 实例化template class 有static member, 这些static member不会被实例化. <span style="color:red">Compiler 实例化static member 只有当用static member时候</span>. Every instantiated class template specialization has its own copy of static members

```c++
template<class T> class X {
  public:
    X* p;
    void f();
    void g();
};

X<int>* q;
X<int> r;//实例化 X<int>

X<float>* s;
r.f(); //实例化 X<int>::f()

s->g(); //实例化 X<float> and  X<float>::g()
```

会实例化如果有pointer conversion (derived-to-base), ```B<double>* r = p;``` 实例化 ```D<double>```, ```delete q``` 实例化 ```D<int>```
```c++
template<class T> class B { };
template<class T> class D : public B<T> { };
void g(D<double>* p, D<int>* q)
{
  B<double>* r = p;
  delete q;
}
```

Compiler 实例化static member 只有当用static member时候.

```c++
template<class T> class X {
public:
   static T v;
};
template<class T> T X<T>::v = 0;

X<char*> a;
X<float> b;
X<float> c;
a.v //实例化 static member v

```


**Efficiency and Flexibility**

- smarter pointer type 展示了一个好的template design
- Override default deleter. ```shared_ptr``` 可以 passing a callable object when we create or reset pointer. 相反 ```deleter``` 是 ```unique_ptr``` 的 type 一部分(template parameters). User 必须提供that deleter type as an explcit template argument 当定义```unique_ptr```
- 如果访问deleter 是对性能有重要影响
    - ```shared_ptr```
        - ```shared_ptr``` 不 hold deleter as member 因为 type of deleter 不知道 until run time. 可以改变deleter type at ```shared_ptr``` lifetime. 可以假设 ```shared_ptr``` stores the pointer it manages in a member named```p```. deleter 通过```del``` 去access 
        - ```del ? del(p) : delete p; // del(p) requires run-time jump to del's location```. ```del(p)``` 运行时需要跳转到 ```del```的地址
        - <span style="color:red">deleter stored indirectly</span>, call ```del(p)``` 需要run-time jump to location stored in ```del```  to execute the code to which ```del``` points (需要一次运行时的跳转操作，转到del中保存的地址来执行)
    - ```unique_ptr```
        - ```unique_ptr``` template parameter 有两个，一个是type that ```unique_ptr``` manages 里一个是 表示 deleter 的type. 因为type of deleter 是 part of type or ```unique_tpr```. <span style="color:red">因此deleter type 必须known at compile time</span>
        - <span style="color:red">deleter store directly in ```unique_ptr``` object, **no run-time overhead**</span>
        - ```del(p); // no run-time overhead``` del 可以是default deleter type or user-supplied type.没关系 the code that wil be executed is known at compile time. 如果Deleter 类似于 上面```DebugDelele``` class, call 可以是 inlined at compile time 
- Binding the deleter at **compile time**, <span style="color:red">unique_ptr **avoids the run-time cost** of an indirect call to its deleter</span>. By binding the deleter at run time, <span style="color:red">**shared_ptr** makes it easier for users to override the deleter</span>.


#### (i). Argument Deduction

The process of <span style="background-color:#FFFF00">**determining the template arguments** from the function arguments</span> is known as <span style="background-color:#FFFF00">**template argument deduction**</span>.
    - compiler 根据argument find template argument 来generate a **best match** 的 vesion of function 

1. **Conversions**
2. **Function-Template Explicit Arguments**
3. **Trailing Return Types and Type Transformation**
4. **Function Pointers and Argument Deduction**
5. **References Deduction**
6. **Reference Collapsing and Rvalue Reference Parameters**
7. **Understanding std::move**
8. **Forwarding**




**1.Conversions**

- **function template argument -> parameter conversion**
    - <span style="background-color:#FFFF00">**top level const**</span> either in parameter or argument <span style="background-color:#FFFF00">都会被 **ignored**</span>
    - const conversions: argument 是 <span style="background-color:#FFFF00">**a reference (or pointer) to nonconst object**</span> -> parameter 是 <span style="background-color:#FFFF00">**reference (or pointer) to const object**</span>
    - <span style="background-color:#FFFF00">**如果parameter 是 nonreference type**</span>, <span style="color:red">A **array** argument 将会被 convert to a **pointer** to its first element. A **function** argument will be converted to a **pointer** to the function's type.</span> (<span style="background-color:#FFFF00">array / function to pointer conversion 属于exact match 的</span>)
    - Other conversions, 比如 <span style="color:red">**arithmetic conversion**, **derived-to-base conversion**, and **user-defined conversion**(通过constructor) 是不会被执行的</span>
    - 注: <span style="color:red">**const conversions**</span> and <span style="color:red">**array or function to pointer**</span> are the only <span style="color:red">**automatic conversions**</span> for <span style="color:red">**arguments to parameters**</span> with template types.
- function template 也可以用 <span style="color:red">普通参数</span>, do not involve a template type parameter. 这些argument <span style="color:red">no special processing</span>, 可以converted as usual to the corresponding type of the parameter. 比如可以从 derived-to-base


例子中 T 是value type, 
- call ```fobj```, ```const string``` to value (top-level const 被忽略). call ```fref```, ```s1``` from ```string``` to ```const string&``` 是合法的. 
- 在数组例子中, 因为size 不一样, 类型不同, 在call ```fobj```, 数组大小无关紧要, 因为会convert to pointer. 但是对于 ```fref``` 是非法的, <span style="color:red">因为parameter 是 reference, array 不会convert to pointer</span>, ```a``` 和 ```b``` 类型不一样

```c++
template <typename T> T fobj(T, T); // arguments are copied 

template <typename T> T fref(const T&, const T&); // references

string s1("a value");
const string s2("another value");

fobj(s1, s2); // calls fobj(string, string); const is ignored 

fref(s1, s2); // calls fref(const string&, const string&)
            
            // uses premissible conversion to const on s1 

int a[10], b[42];
fobj(a, b); // calls f(int*, int*)

fref(a, b); // error: array types don't match

```
一个<span style="color:red">template type parameter 可以被用作more than one function parameter</span>, 但是这些parameters必须有相同的类型, 如果deduced types 不匹配, call is <span style="color:red">**error**</span>. 比如下面例子, ```compare``` takes two ```const T&``` parameters. arguments 必须有 same type. 例子中一个是 ```long```, 一个是```int```, deduction fails. 

```c++
long lng;
compare(lng, 1024); // error: cannot instantiate compare(long, int)

```

function with **two type parameters**: 比如下面例子, ```<``` operator must exist that can compare values of those types

```c++
template<typename A, typename B>
int flexibleCompare(const A& v1, const B& v2)
{
    if (v2 < v1) return 1;
    if (v1 < v2) return -1; 
    return 0;
}

long lng;
flexibleCompare(lng, 1024); // ok: calls flexibleCompare(long, int)

```


**Normal Conversions Apply for Ordinary Arguments**: 如果template 是普通参数，可以进行普通的conversion, 不用服从template的conversion. 比如下面例子,因为typep of parameter 不depend on template parameter convert from ```ofstream``` to ```ostream&``` 

```c++
template <typename T> ostream &print(ostream &os, const T &obj)
{
    return os << obj;
}

print(cout, 42); // instantiates print(ostream&, int)

ofstream f("output");
print(f, 10); // uses print(ostream&, int); converts ofstream to ostream&

```

**2.Function-Template Explicit Arguments**

- **Function-Template Explicit Arguments**：compiler有时候不能deduce the types of template argument, 比如 return type 
     - <span style="color:red">**Explicit template arguments**</span> are matched to <span style="color:red">**Explicit template parameters from left to right**</span>. 所以一个explicit template argument 可能被忽视如果放在right-most
     - 可以用来进行 <span style="color:red">**normal conversion**</span>, 如果 <span style="color:red">**template type parameter is explicitly specified**</span>. 比如function argument 是 int, template parameter specify long, 会convert int to long

比如下面return type ```T1```, impossible to deduce its type, need provide an **explicit template argument**, 对于T2, T3,不需要explicitly specify, compiler will deduce the type 
```c++
// T1 cannot be deduced: it doesn't appear in the function parameter list

template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);
```

Template explicit arguments 需要放在左侧. 比如下面例子call ```alternative_sum```必须提供all three arguments 否则 error

```c++
// poor design: users must explicitly specify all three template parameters

template <typename T1, typename T2, typename T3>
T3 alternative_sum(T2, T1);

// error: can't infer initial template parameters

auto val3 = alternative_sum<long long>(i, lng);
// ok: all three parameters are explicitly specified

auto val2 = alternative_sum<long long, int, long>(i, lng);
```

<span style="background-color:#FFFF00">If we explicitly **specify the template parameter type**, normal conversions apply</span>.

```c++
long lng;
compare(lng, 1024); // error: template parameters don't match

//convert int to long

compare<long>(lng, 1024); // ok: instantiates compare(long, long)

//convert long to int 

compare<int>(lng, 1024); // ok: instantiates compare(int, int)

```


**3.Trailing Return Types and Type Transformation**

- **trailing return type**: 有时需要user determine the return type. 需要用 ```decltype``` on function parameter
     - ordinary function return type 在 parameter 前面, 所以不行
     - <span style="color:red">**trailing return type appears after parameter list**</span>, can use function's parameter

可以用 ```decltype(*beg)``` obtain the type. 不可以用普通的表达式把return type 放前面. <span style="color:red">```beg``` not exist until parameter list has been seen</span>. Must use <span style="color:red"> **trailing return type** </span>，因为trailing return appears after parameter list. 可以用function's parameters

reference operator returns a lvalue, 因为type deduced by ```decltype``` is a reference. 如果```fcn``` called on int, the return is ```int&```. 
```c++
// a trailing return lets us declare the return type after the parameter list is seen

template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
     // process the range
     
     return *beg; // return a reference to an element from the range
     
}

vector<int> vi = {1,2,3,4,5};
Blob<string> ca = { "hi", "bye" };
auto &i = fcn(vi.begin(), vi.end()); // fcn should return int&

auto &s = fcn(ca.begin(), ca.end()); // fcn should return string&

```

**Type Transformation** 

- 比如我们要获取element by value 而不是 reference to an element. 问题是we don't know the type. 比如pass iterator, no iterator operations that yield elements. 
- 所以获取element type, we use a library <span style="color:red">**type transformation**</span> template. defined in ```type_traits``` header. ```type_traits``` ared used for <span style="background-color:#FFFF00">**template metaprogramming**</span>
-  <span style="background-color:#FFFF00">如果返回是```type_traits::type```，必须用**typename**, 告诉compiler that ```type``` represents a type</span> 因为```type``` is member of a class that depends on a template parameter. 
- <span style="color:red">如果not possible to transform template's parameter. ```type``` member is template parameter itself</span>. 比如 ```remove_pointer<T>::type``` 如果```T``` is pointer type, 则type is pointer 指向的类型, 否则no tranformation is needed, ```type``` is the same type as ```T```

| For ```Mod<T>``` where ```Mod``` is   |      ```T``` is      |  ```Mod<T>::type``` is |
|----------|:-------------:|:------|
| ```remove_reference``` |  ```X&``` or ```X&&``` <br/> otherwise | ```X```<br/> ```T``` |
| ```add_const``` |  ```X&```, ```const X```, or ```function``` <br/> otherwise | ```T```<br/> ```const T``` |
| ```add_lvalue_reference``` |  ```X&``` <br/> ```X&&``` <br/> otherwise | ```T```<br/> ```X&```<br/> ```T&``` |
| ```add_rvalue_reference``` |  ```X&``` or ```X&&``` <br/> otherwise | ```T```<br/> ```T&&``` |
| ```remove_pointer``` |  ```X*``` <br/> otherwise | ```X```<br/> ```T``` |
| ```add_pointer``` |  ```X&``` or ```X&&``` <br/> otherwise | ```X*```<br/> ```T*``` |
| ```make_signed``` |  ```signed type``` <br/> otherwise | ```X```<br/> ```T``` |
| ```make_unsigned``` |  ```unsigned X``` <br/> otherwise | ```unsigned T```<br/> ```T``` |
| ```remove_extent``` |  ```X[n]``` <br/> otherwise | ```X```<br/> ```T``` |
| ```remove_all_extents``` |  ```X[n1][n2]``` <br/> otherwise | ```X```<br/> ```T``` |

比如上面定义的 ```fcn``` function, 可以用```remove_reference``` to obatin the element type. 
     - ```remove_reference``` has a template type parameter 和一个(public) type member named ```type```, 
     -if instantiate with a reference type, 则```type``` 是去reference 的type, 比如```remove_reference<int&>```, type member is int 
     - 因为返回时 ```::type```, 必须用**typename** 在trailing return 前面
```c++
template<typename It>
auto fcn2(It beg, It end) ->
     typename remove_reference<decltype(*beg)>::type
//decltype(*beg) is reference, so 

//remove_reference<decltype(*beg)>::type is value 

{
     //process
     return *beg; //return a copy of an element from the range;
}
```




**4.Function Pointers and Argument Deduction**

- when initialize or assign a  <span style="color:red">**function pointer from function template**</span>, compiler <span style="color:red"> use the type of the pointer</span> (等号右边的值) to  <span style="color:red">deduce the template arguments</span>(template 在等号左面)
     - When a function-template instaniate, <span style="color:red">the context allows a **unique type** or **value**</span> to be determined for each template parameter.否则 ambiguous, not compile
     - 注意看下面例子

The type of parameters in ```pf1``` 决定 tyep of template argument for ```T```,下面例子template argument for ```T``` is int. <span style="color:red">The pointer pf1 points to the **instantiation** of ```compare```</span> with T bound to int. 

```c++
template <typename T> int compare(const T&, const T&);
// pf1 points to the instantiation int compare(const int&, const int&)

int (*pf1)(const int&, const int&) = compare;
```

<span style="background-color:#FFFF00">It is **error** 如果template arugment cannot be determined from function pointer type</span>. 下面overload function pointer by different function parameter, 两个function pointer 都可以用来instantiate ```compare```. cannot compile. <span style="background-color:#FFFF00">解决方法是using explicit template arguments as function parameters</span>

```c++
// overloaded versions of func; each takes a different function pointer type

void func(int(*)(const string&, const string&));
void func(int(*)(const int&, const int&));
func(compare); // error: which instantiation of compare?

// ok: explicitly specify which version of compare to instantiate

func(compare<int>); // passing compare(const int&, const int&)
```

**5.Template Argument Deduction and References**

- ```template <typename T> void f(T &p);```
     - can <span style="color:red">only pass **lvalue**</span> (variable or expression returns a reference type). Argument might or might not have a const type
     - normal binding rules apply. 
     - ```const``` are <span style="color:red">**low level**</span>, not top level, 比如 ```p``` 是 ```int * const int``` , 则 ```T``` 是 ```int * const ``` pointer to const int 
- ```template <typename T> void f2(const T&p);```
     - normal binding say we can pass any kind of argument- an object, temporary, literal value. <span style="background-color:#FFFF00">paramter 的```T``` is top level的 or lower level的</span>, 比如const pointer
     - 比如```const char * const &p```, ```T``` 是 ```const char*```, char to const object (lower-level), 
     - 再比如 ```const int&p```, ```T``` 是 ```int```, const 是 lower-level 的
- ```template <typename T> void f3(T &&p);````
     - <span style="color:red">pass **rvalue**</span> to this parameter
     - deduced 跟lvalue reference  一样, <span style="background-color:#FFFF00">deduced type of ```T``` is type of rvalue</span>





**lvalue reference**

```c++
template <typename T> void f1(T&); // argument must be an lvalue

// calls to f1 use the referred-to type of the argument as the template parameter type

f1(i); // i is an int; template parameter T is int

f1(ci); // ci is a const int; template parameter T is const int

f1(5); // error: argument to a & parameter must be an lvalue

```


**const lvalue reference** 下面还是那三个call, 与上面不同的是 ```T``` 全是```int```

```c++
template <typename T> void f2(const T&); // can take an rvalue

// parameter in f2 is const &; const in the argument is irrelevant

// in each of these three calls, f2's function parameter is inferred as const int&

f2(i); // i is an int; template parameter T is int

f2(ci); // ci is a const int, but template parameter T is int

f2(5); // a const & parameter can be bound to an rvalue; T is int

```

**rvalue reference**: 接rvalue

```c++
template <typename T> void f3(T&&);
f3(42); // argument is an rvalue of type int; template parameter T is int

```

**6. Reference Collapsing and Rvalue Reference Parameters**

比如when we pass lvalue ```int i = 3``` to a template function that has rvalue reference paramter ```template <typename T> void f3(T&&);```. We would assume it as illegal, 但是language define two exceptions foundation for how library facilities ```move``` operate.

- Exception One: When we <span style="color:red">pass an **lvalue**</span> (e.g., i) to a function parameter that is an <span style="color:red">**rvalue reference**</span>  to a template type parameter (e.g, ```T&&```), the compiler <span style="color:red">deduces the template type parameter</span>  (```T```) as the <span style="color:red">argument’s lvalue reference type</span> .
- Exception Two(normal binding rule):If we <span style="background-color:#FFFF00">indirectly create a **reference to a reference**, then those references “collapse.”</span>. Reference collapsing applies only when a <span style="color:red">**reference to a reference** is created **indirectly**</span>, such as in a <span style="color:red">**type alias**</span> or a <span style="color:red">**template parameter**</span>
     - ```X& &```, ```X& &&```, and ```X&& &``` all collapse to type ```X&```
     - The type ```X&& &&``` collapses to ```X&&```
- 注意: <span style="color:red">**lvalue deduced to lvalue references, rvalues are not deduced to rvalue references**</span>. Rvalues are deduced to the type itself  
  
 根据Reference Collapse rule: 我们can 上面的例子```template <typename T> void f3(T&&);```
 
 ```c++
 f3(i);   // argument is an lvalue; template parameter T is int&

 f3(ci); // argument is an lvalue; template parameter T is const int&

 ```

<span style="background-color:#FFFF00">当Template parameter ```T``` deduced as **reference type**, collapsing rule says function parameter ```T&&``` collapses to **lvalue reference type**</span>. 因此instantiation would be something like 下面形式. 因此即使 <span style="color:red"> function parameter in ```f3``` is an **rvalue reference**, call instantiates ```f3``` with an **lvalue reference type**</span>

```c++
// invalid code, for illustration purposes only

void f3<int&>(int& &&); // when T is int&, function parameter is int& &&

// int & && collapses to int & , like 

void f3<int&>(int&); // when T is int&, function parameter collapses to int&

```

**two important consequences from these rules:**

- A function parameter that is an rvalue reference to a template type parameter
(e.g., T&&) can be bound to an lvalue; (lvalue reference and rvalue reference to lvalue reference)
- If the argument is an lvalue, then the <span style="color:red">**deduced template argument type**</span> will be an <span style="color:red">**lvalue reference type**</span> and the <span style="color:red">function parameter will be instantiated</span> as an (ordinary) <span style="color:red">**lvalue reference parameter**</span> (```T&```), 表示即使template function 是 rvalue reference, can be used by lvalue as well
- 如果用rvalue pass 到 ```T&&```, deduced type ```T``` 是 rvalue 的类型 (no reference)
- <span style="color:red">可以 pass **any type** </span> to a function parameter that is an <span style="color:red">**rvalue reference**</span>(i.e., T&&).

**Writing Template Functions with Rvalue Reference Parameters
The**


```c++
template <typename T> void f3(T&& val)
{
     T t = val; // copy or binding a reference?
     
     t = fcn(t); // does the assignment change only t or val and t?
     
     if (val == t) { /* ... */ } // always true if T is a reference type
     
}
```

- 当call ```f3``` on rvalue, 比如literal 42, ```T``` is int. The local varaible ```t``` is <span style="color:red">**initialized by copy** value of ```val```. 当we assign to ```t```, parameter is ```val``` <span style="color:red">**remains unchanged**</span>
- 当call ```f3``` on lvalue ```i```, then ```T``` is ```int&``` 当define and initialize local variable ```t```, variable has type ```int&```. This <span style="color:red">initialization of ```t``` **binds**(reference) ```t``` to ```val```</span>. when <span style="color:red">assign to ```t```, **change** ```val``` at the same time</span>. In this instantiation of ```f3```, <span style="background-color:#FFFF00">```if``` test always yields true</span>
- 所以 it is <span style="color:red">very **hard** to write code correct when types involved 是 plain (nonreference) types or reference types</span> (尽管type transformation classes such as ```remove_reference``` can help)
     - rvalue reference 只用于两个地方, <span style="color:red">**forwarding its argument**</span> or <span style="color:red">**template overloading**</span>
     - function templates that use rvalue references often use overloading in the same way as before
	
use rvalue reference for overloading (跟以前一样), 如果下面function 不是template 的话,first version bind to modifiable rvalues and 第二个版本 bind to lvalues or const 
```c++
template <typename T> void f(T&&); // binds to nonconst rvalues

template <typename T> void f(const T&); // lvalues and const rvalues

```

**7. Understanding std::move**

- Although we <span style="color:red">cannot directly bind an **rvalue reference** to an **lvalue**</span>, we <span style="color:red">can use ```move```</span> to obtain an rvalue reference bound to an lvalue.

standard defines ```move```: 注需要用typename 来显示是 type. 

- move's function parameter is ```T&&``` rvalue reference to template parameter type, <span style="background-color:#FFFF00">通过 **reference collapsing**, parameter can match arguments of any type</span>. 我们可以pass lvalue or rvalue to ```move```
- ```remove_reference<T>``` 如果 ```T``` 是 ```X&&``` or ```X&```, ```remove_reference<T>::type``` is  ```X```, then ```remove_reference<T>::type&&``` is rvalue reference
- 不能把 lvalue 绑定到 rvalue, 所以利用```move```, 获得的 rvalue reference  可以绑定到lvalue 

```c++
// for the use of typename in the return type and the cast see § 16.1.3

 // remove_reference is covered in § 16.2.3 

template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    //static_cast covered in § 4.11.3

    return static_cast<typename remove_reference<T>::type&&>(t);
}

string s1("hi!"), s2;
s2 = std::move(string("bye!")); // ok: moving from an rvalue

s2 = std::move(s1); // ok: but after the assigment s1 has indeterminate value

```


**How std::move Works**

- ```std::move(string("bye!")```:  call instantiates```move<string>``` which is the function ```string&& move(string &&t)```
  - The deduced type of ```T``` is ```string```.
  -  Therefore, ```remove_reference``` is instantiated with ```string```.
  - The type member of ```remove_reference<string>``` is ```string```. 
  - The return type of move is ```string&&```.
  - move’s function parameter, t, has type ```string&&```.
  - body of function returns ```static_cast<string&&>(t)```. the type of t 已经是 ```string && ```, <span style="background-color:#FFFF00">cast does nothing </span>
-  ```std::move(s1)```
   - The deduced type of T is ```string&``` (<span style="background-color:#FFFF00">reference to string</span>, not plain string). 
   - Therefore, ```remove_reference``` is instantiated with ```string&```.
   - The type member of ```remove_reference<string&>``` is ```string```,
   - The return type of move is still ```string&&```.
   - move’s function parameter, t, <span style="background-color:#FFFF00">instantiates as ```string& &&```, which collapses to ```string&```</span>.
   - call instantiates ```move<string&>``` which is ```string&& move(string &t)``` 就是我们想要的, want bind rvalue reference to an lvalue. 
      - the type of t is ```string&``` which cast converts to ```string&&```

**static_cast from an Lvalue to an Rvalue Reference Is Permitted**: 尽管我们不能implicitly convert an lvalue to rvalue reference, 但是我们可以explictly <span style="background-color:#FFFF00">cast an **lvalue** to **rvalue reference** using ```static_cast```</span>. 用cast, 这样language prevent us from casting lvalue to rvalue reference implicitly. 绑定到rvalue reference, lvalue 被 clobber(截断)


**8. Forwarding**

- 一些function 需要 forward 一个或多个 arguments with their types unchanged to another function, 需要<span style="color:red">**preserve everything about forwared arguments**, 包括是不是**const**, argument 是 **lvalue** or **rvalue**</span>
- we an <span style="color:red">preserve all the type information</span> by defining function parameter as <span style="color:red">**rvalue reference** to a <span style="color:red">**template type parameter**</span>. 
  - use a reference parameter ( either lvalue or rvalue) lets us <span style="color:red">**preserve constness**</span> and <span style="color:red">**lvalue/rvalue property**</span> of its corresponding argument, 因为 const in reference type 是 low-level
  - 还有个问题是, 所有 <span style="color:red">**function parameter** 都是**lvalue** 即使type is rvalue reference</span>, 所以如果forward 到的function 有rvalue reference 是error, 因为不能用 lvalue 去绑定到 rvalue reference
    - 可以解决的这个问题用 ```forward``` (in ```utility``` header) that <span style="color:red">**preserves the types** of the original arguments</span>
    - 不像 ```move```, ```forward``` must be called with an **explicit argument type**(上面第二点). <span style="color:red">```forward<T>``` returns a **rvalue reference**</span>(```T&&```) to that explicit argument type. 
    - 通常用 ```forward``` <span style="color:red">pass **function parameter** (定义为 rvalue reference) to **template type parameter**</span>. Through <span style="background-color:#FFFF00">**reference collapsing**</span> on its return type, forward <span style="background-color:#FFFF00">preserves the **lvalue/rvalue** nature</span> of its given argument
    - same as ```move``` , 不用 using declaration for ```std::forward``` (cover at § 18.2.3)


即使function takes <span style="background-color:#FFFF00">**rvalue reference**, parameter is consider as **lvalue to an rvalue reference**</span> 

```c++
template <typename T>
void pass(T&& v) {
    reference(v);
}
```
This is why Perfect Forwarding is needed, to get full semantics, use ```std::forward```
```c++
template <typename T>
void pass(T&& v) {
    reference(std::forward<T>(v));
}
// do something like this
template <typename T>
void pass(T&& v) {
    reference(static_cast<T&&>(v));
}
```

	

下面例子的```flip1``` 用来对调两个参数, 但是顶层const 和 references 都丢掉了 
```c++
// template that takes a callable and two parameters

// and calls the given callable with the parameters ''flipped''

// flip1 is an incomplete implementation: top-level const and references are lost

template <typename F, typename T1, typename T2> void flip1(F f, T1 t1, T2 t2)
{
    f(f2, f1);    
}
```

但是上面的works fine 直到 遇到 reference parameter，比如直接call ```f``` 改变 绑定到 ```v2``` 的值, 但是 call ```f``` through ```flip1``` 不会改变原来的值, ```j``` passed to ```t1``` 是 a plain, non reference type ```int``` not ```int&```.  相当于实例化了 ```void flip1(void(*fcn)(int, int&), int t1, int t2);```, reference parameter 绑定到 ```t1``` 上 而不是 ```j``` 上


```c++
void f(int v1, int &v2) // note v2 is a reference
{ 
    cout << v1 << " " << ++v2 << endl;
}
f(42, i); // f changes its argument i

flip1(f, j, 42); // f called through flip1 leaves j unchanged

//the instantiation of the call, reference parameter 被绑定到 t1 上 而不是 j 上

void flip1(void(*fcn)(int, int&), int t1, int t2);

```

通过define rvalue reference 来 preserve all the type information
- 在 ```flip2``` 中, ```flip1(f, j, 42); ```  type dedeuced for ```T1``` is ```int&```, collapses to ```int&```. The reference ```t1``` bound to ```j```. 改变 ```t1``` 改变 ```j``` 的value

```c++
template <typename F, typename T1, typename T2> void flip2(F f, T1 &&t1, T2 &&t2)
{ 
    f(t2, t1);
}
```

但是还有个问题, 当call a function that has an **rvalue reference** parameter, 比如call ```g``` through ```flip2```, 因为 <span style="background-color:#FFFF00">**function parameter**</span> 都是 <span style="background-color:#FFFF00">**lvalue expression**</span>. 相当于 pass <span style="color:red"> **lvalue** to ```g``` **rvalue reference** parameter</span>

```c++
void g(int &&i, int& j)
{
    cout << i <<" " << j <<endl;
}

flip2(g, i, 42); // error: can't initialize int&& from an lvalue

```


**forward**: 如果arg 是 rvalue reference to a template type parameter 会represent all the type information 

- 如果argment 是 <span style="color:red">**rvalue**</span>, ```Type``` is ordinary type and ```forward<Type>``` return ```Type&&```  <span style="color:red">**rvalue reference**</span> 
- 如果argument 是 <span style="color:red">**lvalue**</span>, 通过 reference collapsing, ```Type``` is lvalue reference type(```Type&```), ```forward<Type>``` return ```Type& &&``` is ```Type&``` <span style="color:red">**lvalue reference type**</span>.  

```c++
template <typename Type> intermediary(Type &&arg)
{
    finalFcn(std::forward<Type>(arg));
 }
```

所以上面```flip``` 可以写成 下面形式, ```i``` passed as ```int&``` and 42 passed as an ```int&&```

```c++
template<typename F, typename T1, typename T2>
void flip(F f, T1 &&t1, T2 &&t2){
    f(std::forward<T2>(t2, std::forward<T1>(t1)));
}

flip(g, i, 42);
```





#### (j). Overloading

- Function templates can be **overloaded** by other templates or by ordinary, nontemplate functions. function 必须是 具有不同数量参数 或 不童类型 的参数
- 函数匹配规则受 几方面影响
  - **candidate functions** 包括所有 <span style="color:red">**function-template instantiation**</span> for which <span style="color:red">template argument deduction succeeds</span>
  - **candidate functions**  是 可行的(viable),因为 <span style="color:red">**template argument deduction** 排除了不行的</span>
  - <span style="color:red">可行的 function 是**根据 conversions 来rank的**</span>. 当然 conversions used to call a function template 是不多的 (const & array/function to pointer) 
  - 如果有一个better than others, functions s selected. 但是如果several functions that provides equal match，那么
    - 如果仅有一个 <span style="color:red">**nontemplate function**</span> equally good matches, 选择nontemplate function
    - 如果没有 nontemplate function 都是 function templates, <span style="background-color:#FFFF00">one of these templates is **more specialized**</span>(更特例化) than any of the others, the more specialized function template is called
    - 除此之外, call is ambiguous 

好的定义 set of overloaded function templates <span style="background-color:#FFFF00">需要好的理解 **relationship among types and of restricted conversons** applied to arguments</span> in template functions


**Writing Overloaded Templates** (注意e.g. 3)

定义 template function, returns a string, <span style="background-color:#FFFF00">可以用于 any type that has an **output operator**, to generate a string
```c++
// print any type we don't otherwise handle
	
template <typename T> string debug_rep(const T &t)
{
    ostringstream ret; // see § 8.3 

    ret << t; // uses T's output operator to print a representation of t 
    
    return ret.str(); // return a copy of the string to which ret is bound

}
```

define a version of ```debug_rep``` to print pointers. 注意下面function cannot print ```char*```, 因为 IO library deines a version of ```<<``` for ```char*``` values(假定pointer denotes a null-terminated character array, 打印数组内容, 而不是地址). 

```c++
//打印指针的值, 后跟指针指向对象

//不能用于 char* 

template <typename T> string debug_rep(T *p)
{
    ret << "pointer: " << p; // print the pointer's own value 
    
    if (p)
        ret << " " << debug_rep(*p); // print the value to which p points
    
    else
        ret << " null pointer"; // or indicate that the p is null

    return ret.str(); // return a copy of the string to which ret is bound 

}
```


E.g.1: 对于 下面code, 只有第一个版本是可行的, 第二个版本不可行, 因为其需要pointer parameter. no way to **instantiate a function template** that expects a pointer type from a nonpointer argument, so argument deduction fails. 只有一个viable function.

```c++
string s("hi");
cout << debug_rep(s) << endl;
```

E.g.2: 对于下面code,  both functons generate viable instantiations: 
    - ``` debug_rep(const string* &)```, which is the instantiation of the first version, T is ```string*```
    - ```debug_rep(string*)```, which is the instantiation of the second version of ```debug_rep``` with T bound to string
    - <span style="color:red">第二个version is better match. 因为第一个版本需要conversion of plain pointer to a pointer to ```const```(lower-level)</span>

```c++
cout << debug_rep(&s) << endl;
```

E.g.3: both tmeplates ar viable and both provide an exact match
- ```debug_rep (const string * const &)```, the instantiation of the first version of the template with ```T``` bound to ```const string*``` (lower-level const), ```debug_rep``` 的template parameter 的 const 是 top-level const 
- ```debug_rep(const string*)```, the instantiation of the second version of the template with ```T``` bound to ```const string```
-  ```debug_rep(T*)``` is better match 因为<span style="color:red">more **specialized** template</span>. 因为```debug_rep(const T&)``` 本质上可以用于任何类型, 包括指针类型, 而```debug_rep(T*)``` 只能用于指针

```c++
const string *sp = &s;
cout << debug_rep(sp) << endl;
```

E.g.4: nontemplate function and template function
- ```debug_rep<string>(const string&)```, template ```T``` bound to ```string```
- ```debug_rep(const string&)``` ordinary, nontemplate function
- nontemplate function selected, nontemplate 和 template 比选nontemplate的, 因为it is more specialized, 

```c++
string debug_rep(const string &s)
{
     return '"' + s + '"';
}
string s("hi");
cout << debug_rep(s) << endl;
```

E.g 5. Pointers to C-style character strings and string literals

- ```debug_rep(const T&)``` with ```T``` bound to ```char[10]```
- ```debug_rep(T*)``` with ```T``` bound to ```const char```
- ```debug_rep(const string&)``` which requires a conversion from ```const char*``` to ```string```, 因为需要user-defined conversion 所以不优于前两个
- 第二个template require conversion from array to pointer(满足exact match in §6.f), 所以选择```debug_rep(T*)```, most specialized than first one

```
cout << debug_rep("hi world!") << endl; // calls debug_rep(T*)
```

如果我们想<span style="color:red">handle character pointers as ```string```</span>, 可以define 两个nontemplate overloads

```c++
string debug_rep(char *p)
{
     return debug_rep(string(p));
}
string debug_rep(const char *p)
{
     return debug_rep(string(p));
}
```

记着declare ```string debug_rep(const string &s)``` before ```string debug_rep(const char *p)``` <span style="color:red">否则**wrong version** will be called</span>, compiler instantiate the call from template, 比如例子中如果不declare ```debug_rep``` with ```string```, compiler instantiate template version that takes a ```const T&```. <span style="background-color:#FFFF00">好习惯是declare every function in an overloaded set before any functions</span>

```c++
template <typename T> string debug_rep(const T &t);
template <typename T> string debug_rep(T *p);
// the following declaration must be in scope

string debug_rep(const string &);
string debug_rep(char *p)
{
   // if the declaration for the version that takes a const string& is not in scope
  
   // the return will call debug_rep(const T&) with T instantiated to string
   
   return debug_rep(string(p));
}
```

E.g. 6 
- "hi" 类型是 ```const char[3]```
- ```const T&a``` 实例化是 ```const char (&a)[10]```
- ```const T*a``` 实例化是 ```const char * const a```
- 两个都是viable,但是 ```const T*a``` is more specialized

```c++
template<typename T>
void func(const T& a) {
	cout << " in reference " << endl;
}
template<typename T>
void func(const T* a) {
	cout << " in pointer " << endl;
}

func("hi"); //print in pointer 

//因为 "hi" 是 const char array, call pointer need conversion to pointer(但属于exact match)

```

E.g 7 如果同时 ```T&&``` 和 ```const T&``` 对于lvalue 都available, call ```T&&```, 因为更specialized. 但对于 const rvalue reference, call  ```const T& t```, 因为对于```T&&``` 需要const version, ```T``` bound to ```const int```， 不如```const T&```

```c++
template<typename T>
void debug(const T& t) {
	cout << "in lvalue " << endl;
}
template<typename T>
void debug(T&& t) {
	cout << " in rvalue " << endl;
}
int r = 1;
debug(r); // print in rvalue;

const int&& i = r*3;
debug(i); //print in lvalue

```




#### (k). Variadic Templates

1. **Writing a Variadic Function Template**
2. **Pack Expansion**
3. **Forwarding Parameter Packs**

- variadic template is template function or class that can take <span style="background-color:#FFFF00">**verying number of parameters**</span>
   - varying parameter are known as <span style="background-color:#FFFF00">**parameter pack**</span>. There are two kinds of parameter pack
   	- A <span style="background-color:#FFFF00">**template parameter pack**</span> represents zero or more template parameters (pack 可以是不同类型)
	- A <span style="background-color:#FFFF00">**function parameter pack**</span> represents zero or more function parameters (pack 可以是不同类型)
- use ellipsis 表示template or function <span style="color:red">represents a pack</span>, In template parameter list, ```class...``` or ```typename...``` <span style="color:red">表示following prameter 是 a list of zero or more types</span>; <span style="color:red">the **name**</span> of a type followed by an ellipsis represents a list of zero or more nontype parameters of the given type.
- As usual, compiler deduces template parameter types from function's argument. For variadic template, <span style="color:red">compiler **deduces the number of parameters** in the pack</span>
- ```sizeof...(pack)```, how many elements in a pack(either template or function), 用```sizeof...(pack)```, returns a constant expression and does not evaludate its argument
- <span style="color:red">**initializer_list**</span> take a verying number of arguments with <span style="color:red">the **same type**</span>. <span style="color:red">**Variadic functions**</span> are used when <span style="color:red">不知道 number or types (可以是different types) of arguments</span> we want to process

```c++
// Args is a template parameter pack; rest is a function parameter pack

// Args represents zero or more template type parameters

// rest represents zero or more function parameters

template <typename T, typename... Args>
void foo(const T &t, const Args& ... rest);
```


下面例子, type of ```T``` is deduced from first argument. The remainng arguments <span style="color:red">provide the number of, and types for, the addiational arguments</span> to the function

```c++
int i = 0; double d = 3.14; string s = "how now brown cow";
foo(i, s, 42, d); // three parameters in the pack

foo(s, 42, "hi"); // two parameters in the pack

foo(d, s); // one parameter in the pack

foo("hi"); // empty pack


//compiler instantiate 4 instances of foo

void foo(const int&, const string&, const int&, const double&);
void foo(const string&, const int&, const char[3]&);
void foo(const double&, const string&);
void foo(const char[3]&);
```

**sizeof**

```c++
template<typename ... Args> 
void g(Args ... args) {
   cout << sizeof...(Args) << endl; // number of type parameters
   
   cout << sizeof...(args) << endl; // number of function parameters
   
}
```

**1. Writing a Variadic Function Template**

- define a function ```print```, argument types 可以变化, that will print the contents of a given list of arguments on a given stream.
- <span style="color:red">**Variadic functions** 通常是 recursive 的</span>, The call process first argument in the pack 再call itself on remaining arguments.
- To stop the recursion, need to define a nonvariadic print function, 在我们例子中, 最好一个```rest``` 就只有一位数, 这时call ```print``` 不会call variadic version
- key part of ```print``` 是 ```return print(os, rest...); //``` <span style="color:red">**the first argument**</span> in pack ```rest``` 会被 <span style="color:red">**removed from the pack**</span> and becomes the argument bound to ```t```. The remaining arguments in ```rest``` for the next call to ```print``` 的 parameter pack
- 注意 <span style="color:red">A **declaration for nonvariadic version** of ```print``` must be in scope</span> when the variadic version is defined. Otherwise, the variadic function will <span style="color:red">**recurse indefinitely**</span>.

```c++
// function to end the recursion and print the last element

// this function must be declared before the variadic version of print is defined

template<typename T>
ostream &print(ostream &os, const T &t)
{
return os << t; // no separator after the last element in the pack
}
// this version of print will be called for all 除了 last element in the pack

template <typename T, typename... Args>
ostream &print(ostream &os, const T &t, const Args&... rest)
{
   os << t << ", "; // print the first argument

   return print(os, rest...); // recursive call; print the other arguments

}
```

用一个call 来说明 ```print(cout, i, s, 42); // two parameters in the pack``` ， 分成了3个call, 前两个call variadic version 因为 nonvariadic version 不viable. 最后一个call ```print(cout, 42)```, variadic(parameter pack 是empty) 和 nonvariadic 都viable, 但是<span style="color:red">**nonvariadic template is more specialized than variadic template**</span>, nonvariadic version is chosen

| Call | t | rest... | 
|----------|-------------|------|
| ```print(cout, i, s, 42)``` | ```i``` | ```s,42``` |
| ```print(cout, s, 42)``` | ```s``` | ```42``` |
| ```print(cout, 42)``` | | call nonvariadic version |



**2.Pack Expansion**

- 除了获取size, we can **expand** the parameter pack
- when expand a pack, 需要provide a <span style="background-color:#FFFF00">**pattern**</span> to be used on each expanded element. pattern 适用于每个被expanded 的elements
- We trigger an expansion by <span style="color:red">putting an ellipsis (```. . .``` ) to the right of the pattern</span>.
- The <span style="color:red">**pattern**</span> in an expansion <span style="color:red">**applies separately** to each element</span> in the pack.

比如下面例子有两个 expansions. 
- 第一个expansion: expands the template pack and <span style="color:red">generates function parameter list</span> for ```print```
   - The expansion of ```Args``` applies pattern ```const Args&``` to 每一个elements in template parameter pack ```Args```. 
   - The expansion of this pattern is a <span style="color:red">comma-separated **list** of zero or more parameter types</span>, each of which will have the form ```const type&```.
- 第二个expansion happens in recusive call to ```print```. pattern is the name of the function parameter pack (i.e., rest) (pattern 就是function parameter pack 名字自己). This pattern expands to a **comma-separated list** of the elements in the pack. the call 等同于 ```print(os, s,42)```

```c++
template <typename T, typename... Args>
ostream & print(ostream &os, const T &t, const Args&... rest)// expand Args
{
     os << t << ", ";
     return print(os, rest...); // expand rest
     
}

```
比如有```print(cout, i, s, 42); ```, The type of last two arguments <span style="color:red">along with **pattern** determine the types of **trailing parameter**</span>. Call is instantiated as 

```c++
ostream& print(ostream&, const int&, const string&, const int&);
```


**Understanding Pack Expansions**: more complicated pattern

下面例子用 pattern ```debug_rep(rest)```. pattern says 我们想 call ```debug_rep``` on each element in function parameter pack ```rest```. 


```c++
// call debug_rep on each argument in the call to print
template <typename... Args>
ostream &errorMsg(ostream &os, const Args&... rest)
{
	// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)
	
	return print(os, debug_rep(rest)...);
}
```

比如call 

```c++
errorMsg(cerr, fcnName, code.num(), otherData, "other", item);
``` 
等同于execute as 
```
print(cerr, debug_rep(fcnName), debug_rep(code.num()), 
     debug_rep(otherData), debug_rep("otherData"),
     debug_rep(item));
```

而下面的pattern <span style="color:red">**not compile**</span>.因为attempt to call ```debug_rep``` with a list of five arguments. ```debug_rep``` function is not variadic 并且也没有 ```debug_rep``` function has five parameters 

```c++
// passes the pack to debug_rep;  print(os, debug_rep(a1, a2, ..., an))

print(os, debug_rep(rest...)); // error: no matching function to call


//The call is executed as 

print(cerr, debug_rep(fcnName, code.num(),
	otherData, "otherData", item));
```

**3. Forwarding Parameter Packs**

- Under new standard, 可以<span style="color:red">use variadic templates together with ```forward```</span> to write functions that pass their arguments **unchanged** to some other function.

E.g. add ```emplace_back``` member to ```StrVec``` class. 
- <span style="background-color:#FFFF00"> Library container的 ```emplace_back``` 是 **variadic member templates**</span> that uses arguments to construct an element directly in space managed by container
- 必须是variadic member,因为string constructor differ in terms of parameter. 而且想要 string move constructor, <span style="color:red">必须preserve all type information about the arguments</span>. Perserve 分为two-step
   - <span style="background-color:#FFFF00">define parameter as **rvalue reference**</span> to template type parameter, 所以可以pass any type to function
   - must <span style="background-color:#FFFF00">use ```forward```</span> to preserve arguments' <span style="color:red">**original types**</span> when ```emplace_back``` passes those arguments to ```construct``` (another function)

- 例子中 ```std::forward<Args>(args)...``` <span style="color:red">**expands both template parameter pack**</span> ```Args``` and <span style="color:red">**function parameter pack**</span> ```args```. 
   - Pattern generate form ```std::forward<Ti>(ti)```: ```Ti```: ith element in tempalte parameter pack. ```ti```: ith element in function parameter pack
- By using ```forward``` in this call, we guarantee  if ```emplace_back``` is <span style="color:red">called with an rvalue, then construct will also get an rvalue</span>
- 比如 ```svec.emplace_back(s1 + s2); ```. Putting in emplace back 是 rvalue, result from ```forward<string>``` is ```string&&```, will forward argument to string move constructor

```c++
class StrVec{
public:
   template<class ...Args> void emplace_back(Args&&... );
};

template<class ...Args> 
inline 
void StrVec::emplace_back(Args&& ... args){
     check_n_alloc();//reallocate if necessary
     
     alloc.constructor(first_free++, 
        std::forward<Args>(args) ...);
}

//假设svec is a StrVec

svec.emplace_back(10, 'c'); // adds cccccccccc as a new last element

//constructor will expand to 

std::forward<int>(10), std::forward<char>(c)


svec.emplace_back(s1 + s2); // uses the move constructor

//the argument to emplace_back is an rvalue

//The result type from forward<string> is string&&, 

//so construct will be called with an rvalue reference.

```


#### (l). Template Specializations

1. **Function Overloading versus Template Specializations**
2. **Class Template Specializations**
3. **Class-Template Partial Specializations**
4. **Specializing Members but Not the Class**



- 使template is best for every possible tmplate argument which template 可以被实例化 是不可能的. 有时general template definition is wrong for a type. 有时候 也许write more efficient code than instantiated from template. 
- When we <span style="color:red">**specialize a function template**</span>, we must <span style="color:red">supply arguments for **every template parameter**</span> in the original template
  - in order to specialize a template, a <span style="background-color:#FFFF00">**declaration** for original template **must be in scope**</span>.  <span style="color:red">**declaration**</span> for a specialization <span style="color:red">**must be in scope before any code uses that instantiation**</span> of the template(specilization 就是instantiation)
    - 对于普通functions, missing declaration 是容易发现的, 但是对于spcialization declaration is missing, <span style="color:red">**compiler 通常generate code using original template**</span>, 因为compiler 可以用original template 实例化 when a specialization is missing. 所以declaration  order error between template and its specialization 容易犯但不容易发现
    - 如果程序用了specialization and instantiation of original template with **the same set of template argument** 是error. 这种错误compiler unlikely to detect
    - Best Practices: <span style="background-color:#FFFF00">templates and their specialization declared in same header. Declaration for all templatess 先appera, followed by any specializations of those template</span>
  - to indicate specialing a template, 用 keyword ```template``` 后跟一个 empty angle brackets ```<>```: 指出 <span style="color:red">argument will be supplied for **all** the template parameters</span> of original template
  - the <span style="color:red">function parameter types(s) 必须 **match** corresponding types in previously declared template</span>
  - 注意有时候function parameter type 如果是 const type, type aliases, pointer, 会annoyed. 比如function parameter 是 ```const T&```, 要specialize ```const char *```类， 那么特例化的function parameter 是 ```const char * const &```(在下面例子中) 


比如我们```compare``` function, compare character pointer by ```strcmp``` 而不是 cmparing pointer values. <span style="color:red">第二个版本</span> called only when <span style="color:red">pass **string literal**</span> or an <span style="color:red">**array**</span>. 如果对比 <span style="color:red">**character pointers**</span>, <span style="color:red">first version</span> of template will be called.

- ```compare(p1, p2);``` calls the first template: 因为<span style="background-color:#FFFF00">**no way to convert a pointer to a reference to an array**</span>. 因此第二个版本的 ```compare``` not viable
- ```compare("hi", "mom");```

```c++
// first version; can compare any two types

template <typename T> int compare(const T&, const T&); 

// second version to handle string literals

template<size_t N, size_t M>
int compare(const char (&)[N], const char (&)[M]);

const char *p1 = "hi", *p2 = "mom";
compare(p1, p2); // calls the first template

compare("hi", "mom"); // calls the template with two nontype parameters

```

e.g. <span style="background-color:#FFFF00">specialization 的 ```T``` 类型是 ```const char *```</span>, 我们template function 的parameter 是 ```const T&```, <span style="background-color:#FFFF00">这里const 表示是pointer 是const, 而不是a pointer to const</span>. 因此 need to use in specialization is ```const char* const &```, a reference to const pointer to const char

```c++
template <typename T> int compare(const T&, const T&);

// special version of compare to handle pointers to character arrays 

template <>
int compare(const char* const &p1, const char* const &p2)
{
     return strcmp(p1, p2);
}
```


**1. Function Overloading versus Template Specializations**

- 当定义 a function template specialization, 是take over job of compiler. <span style="color:red">是**supply definition** to use for a specific **instantiation** of original template</span>. 
  - <span style="background-color:#FFFF00">**specialization is an instantiation**</span>. It is <span style="color:red">**not an overloaded instance**</span> of the function name。 因此, <span style="color:red">**specialization not affect function matching**</span>
- 定义 function as <span style="color:red">**specialization** or **independent nontemplate function** 可以影响function matching</span>
  - 注意下面例子


比如定义two versions ```compare```, 一个是template specialization parameter 是 ```char (&arr)[10]```, 另一个是 ```const T&```. 下面的function call```compare("hi", "mom")``` , <span style="background-color:#FFFF00">两个function template 都viable. 会选择specialization 版本的, 因为more specialized</span>
```c++
template<typename T>
int compare(const T& a, const T&b);

template<>
compare(const char * const &a, const char * const & b );

compare("hi", "mom");
```

但是如果我们定义一个nontemplate function. 两个function template 和nontemplate function 都可行, 但是<span style="background-color:#FFFF00">选择nontemplate function</span>

```c++
compare(const char * a, const char * b);
```

**2.Class Template Specializations**

比如define a specialization of library ```hash``` template , 用来store ```Sales_data``` objects in an unordered container. 
- By default, unordered container use ```hash<key_type>``` to organize their elements. To use this default with our own data type, 必须define a specialization of ```hash``` template. 一个specializaed ```hash``` 必须定义 
  - An <span style="color:red">**overloaded call operator** that returns a ```size_t```</span> and takes an object of the container’s key type as parameters
  - Two type members, ```result_type``` and ```argument_type```, which are the return and argument types, respectively, of the call operator
  - The **default constructor** and a **copy-assignment operator** (which can be implicitly defined )
- 必须 <span style="color:red">**specialize** a template in **the same namespace** which original template is defined</span>. Any definition 注意namespace close no semicolon after curly brace.



注意 
- Any definitions that appear between open and close curlies 是 part of ```std``` namespace 
- Our ```hash<Sales_data>``` definition starts with ```template<>```, which indicates that we are <span style="color:red">defining a **fully specialized template**</span>. template we specialize is named ```hash``` and specialized version is ```hash<Sales_data>```
- As with any other class, we can <span style="color:red">define the **members of a specialization** inside the class or out of it</span>, 我们定义的```operator()``` outside class. 
- The overloaded **call operator** must define a **hashing function** over the values of the given type(```Sales_data```). 好的hash function 总会yield different results for unequal object  
  - 这里 我们将hash function 交给了标准库, 标准库 defines specializations of the ```hash``` class for built-in types and for many of library types. 
- By default, the <span style="color:red">**unordered containers** use the **specialization of hash**</span> that corresponds to the ```key_type``` along with the <span style="color:red">**equality operator**</span> on the key type.
  - 假设<span style="color:red">specialization is in scope</span>, it will be <span style="color:red">**used automatically**</span> when we use ```Sales_data``` as a key to unordered containers
- 因为```hash<Sales_data>``` 使用 ```Sales_data``` private members (```bookNo```, ```revenue```), <span style="background-color:#FFFF00">必须make ```hash<Sales_data>``` as **friend** of ```Sales_data```</span>. 因为```hash<Sales_data>``` <span style="color:red">**instantiation 定义在 std namespace**, our friend declarations 使用 ```std::hash```</span>
- To enable users of ```Sales_data``` to use the specialization of ```hash```, we should <span style="color:red">define this specialization(hash) in the ```Sales_data``` header</span>.
  
```c++
//open the std namespace so we can specialize std::hash

namespace std {
template <> // we're defining a specialization with 

struct hash<Sales_data> // the template parameter of Sales_data 
{   
    // the type used to hash an unordered container must define these types

    typedef size_t result_type;
    typedef Sales_data argument_type; //默认情况下, this type 需要 ==

    size_t operator()(const Sales_data& s) const;
    // our class uses synthesized copy control and default constructor

};
size_t hash<Sales_data>::operator()(const Sales_data& s) const {
    return  hash<string>()(s.bookNo) ^ 
            hash<unsigned>()(s.units_sold) ^
            hash<double>()(s.revenue);
}
} // close the std namespace; note: no semicolon after the close curly

```

因为使用了Sales_data private member, 必须make ```std::hash<Sales_data>``` as ```Sales_data``` friend 

```c++
template <class T> class std::hash; // needed for the friend declaration

class Sales_data {
friend class std::hash<Sales_data>;
    // other members as before 

};
```


如果specialiation of ```hash``` in scope, will be used automatically when use ```Sales_data``` as key to unordered container,比如
```c++
// uses hash<Sales_data> and Sales_data operator==from § 14.3.1 

unordered_multiset<Sales_data> SDset;
```


**3. Class-Template Partial Specializations**

- We <span style="background-color:#FFFF00">can **partially specialize only a class template**</span>. We cannot partially specialize a function template.
- 不同于function templates, a <span style="color:red">**class template specialization** 不需要提供 argument for every template parameter. 可以specify some, but not all template parameters</span> or some, but not all, aspects of the parameters.
-  A class **template partial specialization** 本身是 **template**. Users must **supply arguments** for those 特例化版本中未指定的 template parameters.

比如 ```remove_reference```. That template works through a series of specializations 
- 第一个template 定义most general version. can be instantiated with any type. 它uses template argument as type for its member named ```type```. 接下来两个class 是 **partial specializations** of original template. 
- Because a partial specialization is a template, class name 与template 一样. The specialization’s <span style="color:red">**template parameter list** 包括了 template parameter whose type is not fixed by this partial specialization</span> (未被确定的参数).
- 在class name 后的```<>```中 <span style="color:red">specify arguments for the template parameter we are specializing(提供特例化的实参)</span>. 这些arguments <span style="color:red">与原始模板中 的参数 按位置对应</span>.
- The **template parameter list** of a partial specialization is a <span style="color:red">**subset** of, or a **specialization** of, the parameter list of the original template</span>
    -在下面例子中, 特例化有一样数量的parameter as original template, parameter's type in specialization differ from original template. specialization 用于lvalue 和 rvalue reference type

```c++
//original, most general template 

template <class T> struct remove_reference {
typedef T type;
};

// partial specializations that will be used for lvalue and rvalue references

template <class T> struct remove_reference<T&> // lvalue references

{ typedef T type; };
template <class T> struct remove_reference<T&&> // rvalue references

{ typedef T type; };
```

下面是三个变量 a,b,c 均为 int 类型

```c++
int i;
// decltype(42) is int, uses the original template 

remove_reference<decltype(42)>::type a;
// decltype(i) is int&, uses first (T&) partial specialization 

remove_reference<decltype(i)>::type b;
// decltype(std::move(i)) is int&&, uses second (i.e., T&&) partial specialization 

remove_reference<decltype(std::move(i))>::type c;
```


**4. Specializing Members but Not the Class**

- 可以只特例化特定成员函数 而不是 特例化整个模板 (比如上面的```hash<Sales_data>```, 只特例化了call operator, result_type 和 argument_type)

e.g. 如果 ```Foo``` is a template class witha a member ```Bar```, 可以只specialize that member. 只特例化了 ```Foo<int>``` 类的一成员, 其他类由```Foo``` template 提供. 如果use ```Foo``` with 任何 type, members are instantiated as usual. If  use ```Bar``` member of ```Foo<int>```, 则使用我们定义的特例化版本

```c++
template <typename T> struct Foo 
{
    Foo(const T &t = T()): mem(t) { } 
    void Bar() { /* ... */ }
    T mem;
    // other members of Foo 

};

template<> // we're specializing a template

void Foo<int>::Bar() // we're specializing the Bar member of Foo<int>

{
    // do whatever specialized processing that applies to ints 

}

Foo<string> fs; // instantiates Foo<string>::Foo()

fs.Bar(); // instantiates Foo<string>::Bar()

Foo<int> fi; // instantiates Foo<int>::Foo()

fi.Bar(); // uses our specialization of Foo<int>::Bar()

```


> [From Scott Meyers](https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers)


**rvalue references, move semantics, or perfect forwarding**. **Auto** variables with ```&&```  跟type deduction for function template parameter 原理是一样的. so lvalues of type T are deuced to have type ```T&```, rvalue of type T to have type ```T```. 


declare using ```&&``` 不一定表示是 rvalue reference, 比如下面code, 如果see ```&&``` assume its rvalue reference, misread lot of c++ code 

```c++
Widget&& var1 = someWidget;  // here, “&&” means rvalue reference, 

//but var1 is lvalue, 因为take address of var1
 
auto&& var2 = var1;// here, “&&” does not mean rvalue reference
 
template<typename T>
void f(std::vector<T>&& param);  // here, “&&” means rvalue reference
 
template<typename T>
void f(T&& param);     // here, “&&”does not mean rvalue reference

```

references declared with ```&&``` that may be either lvalue references or rvalue references may bind to anything.  Such unusually flexible references deserve their own name. I call them **universal references**. ```&&``` indicates a universal reference only where **type deduction** takes place

```c++
template<typename T>// deduced parameter type ⇒ type deduction;

void f(T&& param);  // && ≡ universal reference
       
 
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs); // fully specified parameter type ⇒ no type deduction;
    
    ...       // && ≡ rvalue reference
};
 
template<typename T1>
class Gadget {
    ...
    template<typename T2>
    Gadget(T2&& rhs); // deduced parameter type ⇒ type deduction;
    
    ...    // && ≡ universal reference
};
 
void f(Widget&& param); / fully specified parameter type ⇒ no type deduction;
      
      // && ≡ rvalue reference
      
```

decltype is different deduction from auto, 比如下面的第二个例子, won't compile 

> a) if the value category of expression is **xvalue**, then decltype yields ```T&&```;<br/>
> b) if the value category of expression is **lvalue**, then decltype yields ```T&```;<br/>
> c) if the value category of expression is **prvalue**, then decltype yields ```T```.<br/>


```c++
Widget w1, w2;
 
auto&& v1 = w1; // v1 is an auto-based universal reference being
                  
	// initialized with an lvalue, so v1 becomes an
                                 
	// lvalue reference referring to w1.
 
decltype(w1)&& v2 = w2; // v2 is a decltype-based universal reference, and
             
	     // decltype(w1) is Widget, so v2 becomes an rvalue reference.
             
	     // w2 is an lvalue, and it’s not legal to initialize an
            
	    // rvalue reference with an lvalue, so
           
	   // this code does not compile.

```


***
<br/> <br/> <br/>


## 17. Specialized Library Facilities


#### (a). Tuple

1. **Defining and Initializing tuples**
2. **Using a tuple to Return Multiple Values**



- Tuple can have <span style="color:red">any number of members</span>. Each distinct tuple type has a fixed number of members. 不同 tuple type 的 member 数量可以不同
- Tuple is useful when combine some data into one object but 不想建立 a data structure. 
- tuple can be think as quick and dirty data structure

Tuple type, along with its companion types, and functions defined in ```tuple``` header.

| syntax | description | 
|----------|:-------------|
| ```tuple<T1,T2, ... , Tn>t``` | a tuple with members types are ```T1```... ```Tn```. members are <span style="background-color:#FFFF00">**value initialized**</span>  |
| ```tuple<T1, T2,..., Tn>t(v1,v2,...vn);``` | members initialized from <span style="background-color:#FFFF00">**initializer**</span> vi. The <span style="background-color:#FFFF00">constructor is **explicit** </span> |
| ```make_tuple<v1,v2,...,vn)``` | returns a tuple initialized from given initializer. The <span style="background-color:#FFFF00">type</span> of the tuple is <span style="background-color:#FFFF00">**inferred from types of initializer**</span> | 
| ```t1 == t2```<br/> ```t1 != t2``` | two tuples are equal if they 一样数量member and each pair of members are equal. Use member 的 ```==``` operator. <span style="background-color:#FFFF00">一旦发现不一样, subsequent members are not tested</span> | 
| ```t1 relop t2```  | Relational operations. <span style="background-color:#FFFF00">两个tuples must have the 一样数量的member</span> | 
| ```get<i>(t)``` | return <span style="background-color:#FFFF00">**reference**</span> to ith data member of t. <span style="background-color:#FFFF00">如果t is lvalue, result is **lvalue reference**, otherwise it is **rvalue reference**</span>. 所有member of tuple 是 public | 
| ```tuple_size<tupleType>::value``` | A class template that can be instantitated by a tuple type and has a <span style="background-color:#FFFF00">**public constexpr static data member** named ```value``` 是 ```size_t``` type</span> 表示number of members in specified tuple type, 因为是constexpr, 可以用于array declare, 比如 ```int a[tuple_size<..>:value]``` |
| ```tuple_element<i, tupleType>::type``` | A class template that can be instantiated by an integral constant and a tuple type and has a public member named ```type``` that is <span style="background-color:#FFFF00">type of specified members</span> in specified tuple type  | 

**1. Defining and Initializing tuples**

- when create a tuple, use default tuple constructor, <span style="color:red">**value initialized** each member</span>
- 因为tuple constructor is explicit. must use direct initialization syntax.
- ```make_tuple``` generateds tuple object
- use ```get``` through library function template <span style="color:red">必须specify **explicit template argument**</span>
   - ```get``` <span style="color:red">returns a **reference**</span> to specified member
   - inside bracket ```<>``` must be <span style="color:red">**integral constant expression**</span>
-  To use ```tuple_size``` or ```tuple_element```, need to <span style="color:red">know **type** of ```tuple``` object</span>.如果有tuple type 不知道, 可以用 ```decltype```.
   - ```tuple_size``` has <span style="color:red">**public static** data member ```value```</span>: 是members的数量 in specified ```tuple```. 
   - ```tuple_element``` take index 和 tuple type. has <span style="color:red">**public type member ```type```**</span>: the type of spcified member of specified tuple type. indices 从 0 开始 
- relational and equality operators: 
   -  <span style="color:red">必须有 same number of members</span>. to compare, 必须legal to use ```<``` and ```==``` to compare each pair of members (left-hand tuple vs right-hand tuple)
   - 因为tuple defines ```<``` and ```==``` operators, <span style="background-color:#FFFF00">可以pass sequences of tuples to algorithms  and use tuples as **key type in ordered container**</span> 

```c++
tuple<size_t, size_t, size_t> threeD; // all three members set to 0

tuple<string, vector<double>, int, list<int>>
	someVal("constants", {3.14, 2.718}, 42, {0,1,2,3,4,5});
```

Tuple 必须用 <span style="background-color:#FFFF00">**direct initialization**</span>. 因为tuple constructor 是```explicit tuple (const Types&... elems);``` 和  ```explicit tuple (UTypes&&... elems); ```， 不能用copy constructed 的形式

```c++
tuple<size_t, size_t, size_t> threeD = {1,2,3}; // error

tuple<size_t, size_t, size_t> threeD{1,2,3}; // ok

```

library 定义了 ```make_tuple``` function that generates a ```tuple``` object. <span style="background-color:#FFFF00">Uses the types of the supplied initializers to **infer** the type of the tuple</span>

```c++
// tuple that represents a bookstore transaction: ISBN, count, price per book

auto item = make_tuple("0-999-78345-X", 3, 20.00);
```


```get``` function 定义是, 所以<span style="background-color:#FFFF00">必须specify **explicit template argument**</span>
```c++
template <size_t I, class... Types>
typename tuple_element< I, tuple<Types...> >::type& get(tuple<Types...>& tpl) noexcept;

template <size_t I, class... Types>
typename tuple_element< I, tuple<Types...> >::type&& get(tuple<Types...>&& tpl) noexcept;

template <size_t I, class... Types>
typename tuple_element< I, tuple<Types...> >::type const& get(const tuple<Types...>& tpl) noexcept;

auto book = get<0>(item); // returns the first member of item

auto cnt = get<1>(item); // returns the second member of item

auto price = get<2>(item)/cnt; // returns the last member of item

get<2>(item) *= 0.8; // apply 20% discount

```

<span style="background-color:#FFFF00">如果有tuple type 不知道, 可以用 ```decltype```</span>
```c++
typedef decltype(item) trans; //trans is type of item 

//return the number of members in trans

size_t sz = tuple_size<trans>::value

//cnt has the same type as second item in trans

tuple_element<1, trans>::type cnt  = get<1>(item); // is int

```

Relational operator 

```c++
tuple<string, string> duo("1", "2");
tuple<size_t, size_t> twoD(1, 2);
bool b = (duo == twoD); // error: can't compare a size_t and a string

tuple<size_t, size_t, size_t> threeD(1, 2, 3);
b = (twoD < threeD); // error: differing number of members

tuple<size_t, size_t> origin(0, 0);
b = (origin < twoD); // ok: b is true

```

**2. Using a tuple to Return Multiple Values**

- common use of tuple is to <span style="color:red">**return multiple values**</span> from function.


E.g. 有几个书店, 每个书店hold data for 每个transaction saved in ```Sales_data```. structure is ```vector<vector<Sales_data>>```, 假设每个书店的```vector<Sales_data>``` 是按照```isbn```来排序的, write function to find given book, output structure 是第一个参数第几个书店发现, 第二个参数和 第三个参数表示出现的range, 因为一本书可能多个书店出现, 用```vector<tuple<>>```

注意：
- 因为```equal_range``` 需要 ```<``` operator, ```Sales_data``` 没有定义 ```<``` operator, we pass a pointer to ```compareIsbn``` function
- 因为Sales_data 定义了 addition operator, can use accumulate, pass ```Sales_data``` as functor initialized by constructor that takes a string as starting point for summation 
	  

```c++
typedef tuple<vector<Sales_data>::size_type
	vector<Sales_data>::const_iterator
	vector<Sales_data>::const_iterator> matches;

vector<matches>
findBook(const vector<vector<Sales_data>>& files, const string &book)
{
     vector<matches> ret;
     for(auto it = files.cbegin(); it!=files.cend(); ++it)
     {
          auto found = equal_range(it.cbegin(), it.cend(), book, compareIsbn);
     	  if(found.first != found.second)
	     ret.push_push_back(make_tuple(it - files.cbegin(),
	        found.first, found.second));
     }
     return ret;
}

void reportResults(istream &in, ostream& os, 
     const vector<vector<Sales_data>>& files)
{
     string s;
     while(in >> s){
          auto trans = findBook(files, s); 
	  if(trans.empty()){
	  	cout << s << "not found in any stores"<<endl;
		continue
	  }
          for(const auto & store: trans)
	        os <<"store" << get<0>(store) << " sales: "
     		<< accumulate(get<1>(store), get<2>(store), 
		             Sales_data(s))
	        <<endl;
     }
}
```



#### (b). bitset

- bitset defined in ```bitset``` header
- bitset possible to deal with collections of bits 大于 longest integral type
- Like tuple, bitset has <span style="color:red">**fixed size**</span> size must be constant expression： how many bits bitset contains 
- starting 在0 的位置bits叫做 <span style="background-color:#FFFF00">**low-order** bits</span>
- ending 在最后一位的位置bits <span style="background-color:#FFFF00">**high-order** bits</span>
- 当use integral value as initializer for a bitset, <span style="background-color:#FFFF00">value convert to ```unsigned long long``` and treat as **bit pattern**. The bits in bitset are **copy** of that pattern</span>
- 如果<span style="color:red">size of bitset 小于 number of bits, only **lower-order bits**</span> from given value ar used. higher order bits beyond size discarded
- 当initialize bitset from pointer to element in char array or string. <span style="background-color:#FFFF00">chars in **lower indices correspond to high-order bits**</span>. The indexing conventions are <span style="background-color:#FFFF00">**inversely related**</span>. The character in string with the highest subscript (the rightmost character) is used to initialize the low-order bit(the bit with subscript 0).
   - 听起来绕口, 跟读数字顺序是一样的
   - 如果string contains few characters than size, <span style="color:red">**high-order bits are set to zero**</span>

| syntax | description | 
|----------|:-------------|
| ```bitset<n>b``` | ```b``` <span style="color:red">has n bit; **each bit is 0**</span>. The constructor is <span style="background-color:#FFFF00">**constexpr**</span> | 
| ```bitset<n>b(u)``` | b is <span style="background-color:#FFFF00">**copy** of n low-order bits</span> of unsigned long long value ```u```. 如果 n 大于 size of an unsigned long long, <span style="background-color:#FFFF00">higer-order bit beyond  are set to zero</span>. The constructor is <span style="background-color:#FFFF00">**constexpr**</span> | 
| ```bitset<n>b(s, pos, m, zero, one)``` | b is <span style="background-color:#FFFF00">**copy**</span> of 从pos 开始 m 个 chars from string ```s```.  <span style="background-color:#FFFF00">```s``` **只能有 ```zero``` or ```one```** </span>. 如果含有其他的 character, throws ```invalid_argument```.  The characters stored in ```b``` is 0 or . <span style="background-color:#FFFF00">```pos``` default 是 0,, ```m default``` 是 ```string::npos```, ```zero``` default to '0', ```one``` default to '1'</span> | 
| ```bitset<n>b(cp, pos, m, zero, one)``` | 跟上面一样, copies from character array ```cp``` points. <span style="background-color:#FFFF00">如果```m``` 没有提供, ```cp``` must point to **C-style string**</span>. 如果```m``` is supplied, 必须at least ```m``` characters that are ```zero``` or ```one``` starting at ```cp```|
| | 注: constructor takes string or char pointers are <span style="background-color:#FFFF00">**explicit**</span> |


下面例子：
- 定义 ```bitvec``` holds 32 bits 
- Like element in vector, <span style="color:red">the bits in bitset not named</span>
- refer positionally: start from 0 through 31. 
- bits <span style="background-color:#FFFF00">**starting at 0**</span> are reffered to as the <span style="background-color:#FFFF00">**low-order** bits</span>
- those <span style="background-color:#FFFF00">**ending at 31**</span>  are referred to as <span style="background-color:#FFFF00">**high-order** bits.

```c++
bitset<32> bitvec(1U); // 32 bits; low-order bit is 1, remaining bits are 0

```



如果bitset size < given value, 只有lower-order 被copy, high-order bit 被丢弃 
```c++
// bitvec1 is smaller than the initializer; high-order bits from the initializer are discarded

bitset<13> bitvec1 (0xbeef); // bits are 1111011101111

// bitvec2 is larger than the initializer; high-order bits in bitvec2 are set to zero

bitset<20> bitvec2(0xbeef); // bits are 00001011111011101111

// on machines with 64-bit long long 0ULL is 64 bits of 0, so ~0ULL is 64 ones

bitset<128> bitvec3(~0ULL); // bits 0 ... 63 are one; 63 ... 127 are zero


0xbeef = 48879
f -> 15 * (16 to power of 0) = 15 * 1 = 15
e -> 14 * (16 to power of 1) = 14 * 16 = 224
e -> 14 * (16 to power of 2) = 14 * 256 = 3584
b -> 11 * (16 to power of 3) = 11 * 4096 = 45056
```

**initializing a bitset from a string**: 可以initialize a bitset from either string or a pointer to an element in character array. 哪种情况, characeters 都表示 bit pattern directly. 但是string 的 <span style="background-color:#FFFF00">highest suscript (最右侧的) is used to initialize **low-order bit**</span>

```c++
bitset<32> bitvec4("1100"); // bits 2 and 3 are 1, all others are 0

// 也可以用substring 

string str("1111111000000011001101");
bitset<32> bitvec5(str, 5, 4); // four bits starting at str[5], 1100, 剩下的都是0

bitset<32> bitvec6(str, str.size()-4); // use last four characters, 1101

```
**operation on bitset** 

- support bitwise ( § 4.8 中), have the same meaning when applied to bitset as built-in operator for unsigned operands (```&```, ```|```)
- ```set```, ```reset```, ```flip``` change state of bitset 是 overloaded, <span style="color:red">如果no argument applies, the given operation to entire set</span>
- <span style="color:red">```b.size()``` is **constexpr**</span> and can be used when a const expression is required.
- <span style="color:red">subscript operator is overloaded on const</span> 
   - <span style="color:red">**const version** 返回 bool value</span> true if bit at given index is on, false otherwise 
   - <span style="color:red">**nonconst version**</span> returns a special type defined by bitset that <span style="color:red">lets us manipulate the bit value at the given index position</span>
- ```~bitvec[0];``` 等于 ```bitvec.flip(0)```
- ```b.to_ulong()();``` and ```b.to_ullong()``` <span style="color:red">only work if **size** of bitset less than or queal to crresponding size</span>
   - Throw an ```overflow_error``` exception (§ 5.6) if the
<span style="color:red">value in the bitset **does not fit** in the specified type</span>.
- input operator reads character from input stream into <span style="color:red">**temporary object of type string**</span>. Read until it has <span style="color:red">read as many characters as size of corresponding ```bitset```, or encounter character 不是1 or 0, or it encounters end-of-file or an input error</span>
   - then bitset is initialized from that temporary string. 如果fewer characters read than size of bitset, higher-order 用0 补充

| syntax | description | 
|----------|:-------------|
| ```b.any()``` | Is any bit in b on ? |
| ```b.all()``` | Are all the bits in b on ? |
| ```b.none()``` | Are no bits in b on ? |
| ```b.count()``` | number of bits in b are on  |
| ```b.size()``` | A <span style="background-color:#FFFF00">**constexpr**</span> function that returns number of bits in b |
| ```b.test(pos)``` | return true if bit at position ```pos``` is on, false otherwise  |
| ```b.set(pos,v)``` <br/> ```b.set()``` | set the bit at position ```pos``` to the <span style="background-color:#FFFF00">**bool value**</span> ```v```. v is defaults to true, If no arguments, turns on all the bits in b |
| ```b.reset(pos)``` <br/>```b.reset()``` | Turns off the bit at position pos or turns off all the bits in b |
| ```b.flip(pos)``` <br/>```b.flip()``` | Change the state of the bit at position pos or every bit in b |
| ```b[pos]``` | Gives access to bit in b at position ```pos```; 如果 b is const, then ```b[pos]``` returns a bool value true if the bit is on, false otherwise |
| ```b.to_ulong()``` <br/> ```b.to_ullong()``` | returns an unsigned long or unsinged long long with same bits in b. <span style="color:red">Throw ```overflow_error``` if the bit pattern in b won't fit the indicated result type</span> |
| ```b.to_string(zero,one)``` | returns a string  表示 bit pattern in b. ```zero``` and ```one``` are default to ```'0'``` and ```'1'```, 表示 bits 中的 0 and 1 |
| ```os << b``` | prints the bit in b as characters 1 or 0 to stream ```os``` |
| ```is >> b``` | Read characters from ```is``` into b. <span style="background-color:#FFFF00"> Reading stops when next character is not a 1 or 0 or when ```b.size()``` bit haven been read</span> |



例子 
```c++
bitset<32> bitvec(1U); // 32 bits; low-order bit is 1, remaining bits are 0

bool is_set = bitvec.any(); // true, one bit is set

bool is_not_set = bitvec.none(); // false, one bit is set

bool all_set = bitvec.all(); // false, only one bit is set

size_t onBits = bitvec.count(); // returns 1

size_t sz = bitvec.size(); // returns 32

bitvec.flip(); // reverses the value of all the bits in bitvec

bitvec.reset(); // sets all the bits to 0

bitvec.set(); // sets all the bits to 1

bitvec.flip(0); // reverses the value of the first bit

bitvec.set(bitvec.size() - 1); // turns on the last bit

bitvec.set(0, 0); // turns off the first bit

bitvec.reset(i); // turns off the ith bit

bitvec.test(0); // returns false because the first bit is off


//subscript operator

bitvec[0] = 0; // turn off the bit at position 0

bitvec[31] = bitvec[0]; // set the last bit to the same value as the first bit

bitvec[0].flip(); // flip the value of the bit at position 0

~bitvec[0]; // equivalent operation; flips the bit at position


//Retrieving the Value of a bitset

unsigned long ulong = bitvec3.to_ulong();
cout << "ulong = " << ulong << endl;


//bitset IO Operators

bitset<16> bits;
cin >> bits; // read up to 16 1 or 0 characters from cin

cout << "bits: " << bits << endl; // print what we just read



```

比较code 用bitwise operator 和 bitset

```c++
bool status;
// version using bitwise operators

unsigned long quizA = 0; // this value is used as a collection of bits

quizA |= 1UL << 27; // indicate student number 27 passed

status = quizA & (1UL << 27); // check how student number 27 did

quizA &= ~(1UL << 27); // student number 27 failed


// equivalent actions using the bitset library

bitset<30> quizB; // allocate one bit per student; all bits initialized to 0

quizB.set(27); // indicate student number 27 passed

status = quizB[27]; // check how student number 27 did

quizB.reset(27); // student number 27 failed

```

#### (c). Regular Expressions


**2. Error in Specifying or Using a Regular Expression** <br/>
**3. The Match and Regex Iterator Types** <br/>
**4. Using Subexpressions** <br/>
**5. Using regex_replace** <br/>

- RE library defined in ```regex``` header
- 可以搜索多种类型的输入序列, Input sequence 可以是 ```char``` data or ```wchar_t```data and those character 被存储到 ```string``` or array or ```char``` (或则wide character versions, ```wstring``` or array of ```wchar_t```)
    - ```regex``` hold regular expression of type ```char```. library 还定义了 ```wregex``` class that hold type ```wchar_t``` and has same operations as ```regex```. 唯一不同是 initializers of ```wregex``` 必须用 ```wchar_t``` 而不是 ```char```
    - 差异还在if in string or an array. ```smatch``` represents **string** input sequences, ```cmatch``` **character array** sequence. ```wsmatch``` **wide string** input, ```wcmatch``` **arrary of wide characters**


| syntax | description | 
|----------|:-------------|
| ```regex``` | class that represent regular expression |
| ```regex_match``` | Matches a sequence of characters against a regular expression. Returns true if <span style="background-color:#FFFF00">**entire input seqeunce**</span> matches the expression |
| ```regex_search``` | Finds the first subseqence that mathces regular expression. Returns true if there is a <span style="background-color:#FFFF00">**substring**</span> in the input seqeunces that matches  |
| ```regex_replace``` | Replaces a regular expression using a given format |
| ```sregex_iterator``` |  Iterator adaptor that calls ```regex_search``` to iterate through the matches in a <span style="background-color:#FFFF00">**string**</span> |
| ```smatch``` | Container class that holds the results of searching a string |
| ```ssub_match``` | Results for a matched subexpression in a string |


<center> Arguments to regex_search and regex_match. 返回类型是bool 表示whether match was found </center>
 
| syntax | description | 
|----------|:-------------|
| ```(seq, m, r)``` <br/> ```(seq, m, r, mft)``` <br/>  ```(seq, r)``` <br/> ```(seq, r, mft)``` | 在character sequence ```seq``` 查找regex 对象 ```r``` 中的regular expression.<br/> ```seq``` can be <span style="background-color:#FFFF00">a **string**, a pair of **iterators** denoting a range, or a pointer to a **null-terminated character array**</span><br/>. ```m``` is a match object , 用来保存匹配结果细节. ```m``` and ```seq``` must have compatible types.<br/> ```mft``` is an optional ```regex_constant::match_flag_type``` value. (in §17.13) | 


下面例子:
- ```regex``` 使用的 regular expression 是 ECMAScript. 在ECMAScrip中, pattern ```[[:alpha:]]``` 表示匹配任意字母, 符号 ```+``` and ```*``` 分别表示 "one or more" or "zero or more"
    - ```[[:alpha:]]*``` will match zero or more characters
- 我们想要 match pattern "freind" and "theif" and words "receipt" 和 "receive" 
- 定义```smatch``` object ```result```, 如果a match is found, ```results``` will hold details about where match occurred
- ```regex_search``` functions stops 当只要找到一个匹配字串, ```results```  member ```str()```, print the part of ```test_str``` that match our pattern. 
    - 因此打印的是 ```freind```


```c++
// find the characters ei that follow a character other than c

string pattern("[^c]ei");

pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*"; 
regex r(pattern); // construct a regex to find pattern

smatch results; // define an object to hold the results of a search 

// define a string that has text that does and doesn't match pattern

string test_str = "receipt freind theif receive";

// use r to find a match to pattern in test_str

if (regex_search(test_str, results, r)) // if there is a match

cout << results.str() << endl; // print the matching word

```

下面表中 Constructor and assignment operations 也会throw exceptions of type ```regex_error```

<center> regex (and wregex) Operations </center>

| syntax | description | 
|----------|:-------------|
| ```regex r(re)``` <br/>  ```regex r(re,f)``` | re 表示个regular expression, can be a <span style="background-color:#FFFF00">**string**</span>, a <span style="background-color:#FFFF00">**pair of iterators** denoting a range of characters</span>, a <span style="background-color:#FFFF00">pointer to a <span style="background-color:#FFFF00">**null-terminated character array**</span>, a <span style="background-color:#FFFF00">**character pointer and a count**</span>, or a <span style="background-color:#FFFF00">**braced list of character**</span>. ```f``` is aflags that specify how object will execute. ```f``` 是通过下面列出来的值设置. If f is not specified, it defaults to ```ECMAScript``` |
| ```r1 = re``` |  ```r1``` 中正则表达式替换为 ```re```. ```re```(regex object) 表示一个正则表达式, can be  <span style="background-color:#FFFF00">**string**</span>, a <span style="background-color:#FFFF00">pointer to a <span style="background-color:#FFFF00">**null-terminated character array**</span>, or a <span style="background-color:#FFFF00">**braced list of character**</span> | 
| ```r1.assign(re,f)``` | Same effect as ```=```. and optional flag ```f```, 与```regex``` constructor 是一样的 | 
| ```r.mark_count``` | Number of subexpressions in ```r``` |
| ```r.flags()``` | Returns the flags set for ```r``` | 


Flag Specified when a ```regex``` is Defined: Defined in ```regex``` and ```regex::syntax_option_type```

| syntax | description | 
|----------|:-------------|
| ```icase``` | Ignore case during the match |
| ```nosubs``` | Don't store subexpression mathces |
| ```optimize``` | Favor speed of execution over speed of construction |
| ```ECMAScript``` | use grammar as specied by ECMA-262 |
| ```basic``` | Use POSIX basic regular-expression grammar |
| ```extended``` | Use POSIX extended regular-expression grammar |
| ```awk``` | Use grammar from the POSIX versionf of ```awk``` language |
| ```grep``` | Use grammar from the POSIX versionf of ```grep```  |
| ```egrep``` | Use grammar from the POSIX versionf of ```egrep```  |


e.g.  找文件ends in ```.cc```, or ```.Cc``` or ```.cC``` or ```.CC```

- ```.``` 匹配任意字符
- we want to <span style="color:red">**escape the special nature**</span> of a character by preceding with backslash. 因为blash 也是 special character, 所以用两个backslash. <span style="color:red">```\\.``` 表示一个match 一个点</span>

```c++
regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);
smatch results;
string filename;
while (cin >> filename)
if (regex_search(filename, results, r))
    cout << results.str() << endl; // print the current match

```

可以搜索多种类型的输入序列。

| syntax | description | 
|----------|:-------------|
| ```string``` | ```regex```, ```smatch```, ```ssub_match```, ```sregex_iterator``` | 
| ```const char*``` | ```regex```, ```cmatch```, ```csub_match```, ```cregex_iterator``` |
| ```wstring``` | ```wregex```, ```wsmatch```, ```wssub_match```, ```wsregex_iterator``` | 
| ```const wchar*``` | ```wregex```, ```wcmatch```, ```wcsub_match```, ```wcregex_iterator``` |




第一段代码编译失败,因为 the type of match argument and type of nput sequence do not match

```c++
regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase); 
smatch results; // will match a string input sequence, but not char*

if (regex_search("myfile.cc", results, r)) // error: char* input
    
    cout << results.str() << endl;

cmatch results; // will match character array input sequences 

if (regex_search("myfile.cc", results, r))
    cout << results.str() << endl; // print the current match

```












**2.Error in Specifying or Using a Regular Expression**

- 可以把regular expression 想成simple programming language. <span style="color:red">**not interpreted by c++ compiler**</span>. Instead, a regular expression is <span style="color:red">compiled at **run time**</span> when ```regex``` object is initialized with or assigned a new pattern
- Regulation Expression <span style="color:red">**语法正确**(sytactic correctness) 与否 evaluated at **run time**</span>
    - if make mistake writing regular expression, **run time library** will throw an exceptionf of ```regex_error```.
    - 就像standard exception types, ```regex_error``` 有 ```what``` operation describe the error that occurred
    - ```regex_error``` 也有 value ```code``` returns a <span style="color:red">**numeric code** 表示 **type of error**</span> that was encountered
- Avoid creating 不必要的正则表达式
    - 因为正则表达式 <span style="background-color:#FFFF00">**compiled at rune time**</span>. Compiling a regular expression 是<span style="background-color:#FFFF00">**suprising a slow operation**</span>. 除非using extended regular expression grammar or using complicated expression. 因此<span style="color:red">regex object constructor and assignment 是time-consuming</span>
    - 如果loop 中用了regular expression, <span style="color:red">应该在loop 外面创建 而不是recompiling it on each iteration</span>


<center> Regular Expression Error Conditions</center>

| syntax | description | 
|----------|:-------------|
| ```error_collate```| Invalid collating element request (无效元素校对请求) | 
| ```error_ctype``` | Invalid character class | 
| ```error_escape``` | Invalid escape character or trailing escape | 
| ```error_backref``` | Invalid back reference | 
| ```error_brack``` | Mismatched bracket (```[or]```) |
| ```error_paren``` | Mismatched parentheses (```(or)```) | 
| ```error_brace``` | Mismatched brace (```{or}```)  |
| ```error_badbrace``` | Invalid range inside a ```{}``` |
| ```error_range``` | Invalid charater range ```e.g. [z-a]``` | 
| ```error_space``` | <span style="background-color:#FFFF00">Insufficient memory</span> to handle this regular expression (no memory to convert expression) | 
| ```error_badrepeat``` | A repetition character (```*, ?, + {```) 之前没有有效的正则表达式 | 
| ```error_complexity``` | 要求匹配过于复杂 | 
| ```error_stack``` | <span style="background-color:#FFFF00">Insufficient memory</span> to evaluate regular expression match specified sequence |


例如我们忽略了一个方括号 
```c++
try {// error: missing close bracket after alnum; the constructor will throw 
    
    regex r("[[:alnum:]+\\.(cpp|cxx|cc)$", regex::icase);
} catch (regex_error e)
{ 
    cout << e.what() << "\ncode: " << e.code() << endl; 
}

//program generates 

this program generates
regex_error(error_brack): The expression contained mismatched [ and ]. 
code: 4
```

**3. The Match and Regex Iterator Types**

- The regex itearator are <span style="background-color:#FFFF00">**iterator adaptors**</span>(§ 9.6) that bound to an input that are bound to an <span style="background-color:#FFFF00">**input sequence**</span> and a <span style="background-color:#FFFF00">**regex object**</span>.
- 当bind an ```sregex_iterator``` to a string and a regex object. iterator <span style="color:red">自动定位到 **first match** in given string</span>
    - ```sregex_iterator``` constructor calls ```regex_search``` on given string and regex
- when <span style="color:red">**dereference** the iterator</span>, get an ```smatch``` object corresponding to the <span style="color:red">results from **most recent search**</span>. 
- when increment the iterator, it calls ```regex_search``` to <span style="color:red">find the next match in input string</span> 


| syntax | description | 
|----------|:-------------|
| ```sregex_iterator it(b,e,r)``` | it is an sregex_iterator that iterates through string denoted by iterator ```b``` and ```e```, calls ```regex_search(b,e,r)``` to position it on the first match the input  | 
| ```sregex_iterator end``` | off-the-end iterator for ```sregex_iterator``` | 
| ```*it``` <br/> ```it->``` | Returns a <span style="background-color:#FFFF00">**reference** to ```smatch``` object or a **pointer** to the ```smatch``` object</span> from the most rececent call to ```regex_search``` | 
| ```++it``` <br/> ```it++``` | Calls ```regex_search``` on input sequence <span style="background-color:#FFFF00">starting just after the current match</span>. The <span style="background-color:#FFFF00">**prefix** version returns a **reference**</span> to the incremnted iterator; <span style="background-color:#FFFF00">**postfix** returns **old value**</span> |
| ```it1 == it2``` <br/> ```it1 != it2``` | 如果两个regex_iterator 都是<span style="background-color:#FFFF00">off-the-end iterator 则他们相等</span>. Two non-end iteartors are <span style="background-color:#FFFF00">**equal**</span> if they are <span style="background-color:#FFFF00">constructed from **the same input sequence and regex object**</span> |


跟上面例子一样查找所有的 ```[^c]ie``` 的pattern. 

- 当define ```it```, ```sregex_iterator``` constructor calls ```regex_search``` to 定位 ```it``` on first match in ```file```. 
- increment ```it``` for advances iterator by calling ```regex_search```
- dereference the iterator, <span style="color:red">get an ```smatch``` object represent current match</span>. 

```c++
// find the characters ei that follow a character other than c

string pattern("[^c]ei");

// we want the whole word in which our pattern appears

pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";

regex r(pattern, regex::icase); // we'll ignore case in doing the match 

// it will repeatedly call regex_search to find all matches in file

for (sregex_iterator it(file.begin(), file.end(), r), end_it; it != end_it; ++it){
    
    cout << "size :" << it->size() << << " position: " << it->position(0) << endl;
    
    cout <<"match :" << it->str() << " prefix: " <<it->prefix()
         << " suffix: "<<it->suffix() << endl;
}

//output 

size :1 position :9
match :rei prefix: receipt f suffix: nd theif receive
size :1 position :16
match :hei prefix: nd t suffix: f receive
```


![](/img/post/C++/sregex_iterator.PNG)


Smatch Operations. These operations also apply to ```cmatch```, ```wsmatch```, ```wcmatch``` and the corresponding ```csub_match```, ```wssub_match```, and ```wcsub_match``` types


| syntax | description | 
|----------|:-------------|
| ```m.ready()``` | true if m has been set by a call to ```regex_search``` or ```regex_match```. false otherwise. <span style="background-color:#FFFF00">Operations on ```m``` are **undefined** if ```ready``` returns false</span> |
| ```m.size()``` | Zero if ```match``` failed; othersise, return one plus the number of subexpressions in most recently matched regular expression | 
| ```m.empty()``` | return true if ```m.size()``` is zero | 
| ```m.prefix()``` | An ```ssub_match``` representing the sequence **before match** |
| ```m.suffix()``` | An ```ssub_match``` representing the sequence the part **after end of the match** |
| ```m.format(...)``` | see (§ 17.12) |  

下面的operations that take an index, ```n``` defaults to 零 且 必须小于 ```m.size()``` . The first submatch (index 0) represents the overall match.

| syntax | description | 
|----------|:-------------|
| ```m.length(n)``` | Size of the nth matched **subexpression** (string 的 大小) |
| ```m.position(n)``` | <span style="background-color:#FFFF00">**Distance**</span> of the nth **subexpression** from the start of the sequence |
| ```m.str(n)``` | The matched string for the nth subexpressions |
| ```m[n]``` | ```ssub_match``` object corresponding to the nth subexpression |
| ```m.begin(), m.end()``` <br/> ```m.cbegin(), m.cend()``` | Iterators across the ```sub_match``` elements in ```m```. ```cbegin``` and ```cend``` return ```const_iteartors``` |

还是需要```[^c]ie``` 的pattern 的例子, we call ```prefix``` returns an ```ssub_match``` object 表示 the part of ```file``` ahdead of current match. We call ```length``` on ```ssub_match``` to find, 获得前缀部分的数目字数.   

```c++ 
for(sregex_iterator it(file.begin(), file.end(), r), end_it; it != end_it; ++it){
    auto pos = it->prefix().length(); // size of the prefix
    
    pos=pos>40?pos-40:0; //we want up to40 characters
    
    cout << it->prefix().str().substr(pos) //last part of prefix

        << "\n\t\t>>> " << it->str() << " <<<\n" // matched word 

        << it->suffix().str().substr(0, 40) // first part of the suffix
        
        << endl;
}

//打印出来形式

hey read or write according to the type 
        >>> bei <<<
ng handled. The input operators ignore whi

```


**4. Using Subexpressions**

- A pattern in a regular expression often contains <span style="color:red">**one or more subexpressions**</span>.  Regular-expression grammars typically <span style="color:red">use **parentheses** to denote subexpressions</span>.
- 当用括号分组， 也就声明这些选项(allternatives) 行程a subexpression.  
- The first submatch from ```smatch``` object <span style="background-color:#FFFF00">**index at 0,** 表示 match for **entire pattern**</span>. 每个subexpression appears in order. 
- One <span style="color:red">**common use for subexpressions**</span> is to validate data that must match a <span style="color:red">**specific format**</span>.
- ECMAScript regular expression
    - ```{d}``` 表示单个数字,<span style="color:red">```{d}{n}``` 表示n个数字序列</span>, 比如 ```{d}{3}``` 匹配 a sequence of three digits. In C++ ```\\d{3}{3}```
    - A collection of characters <span style="color:red">**inside square brackets** allows a match to any of those character</span> 比如 ```[-. ]``` matches a dash, a dot, or space. <span style="color:red">Note a dot has no special meaning inside bracket</span>
    - A component <span style="color:red">followed by ```?``` is **optional**</span>. E.g. ```\{d}{3} [-. ]? \{d}{4}``` 匹配开始是三个数字, followed by an optional  dash, period or space, followed by four more digits, 比如patten match 555-0132 or 555-0132 or 555 0132 or 5550132  
    - Like C++, ECMAScript use backslash 表示character represent itself rather than special meaning. 因为pattern 有时include parentheses, which are special character in ECMAScipt, 比如用parentheses that are part of pattern as ```\(or\)```, 因为c++， backslash 有special meaning, 必须有双backslash.  <span style="color:red">interprets ```\\``` as an **escape sequence** that represents a single backslash in memory</span>
        - regex 中必须用 双backslash ```\\``` 才能表示单个 ```\``` 因为string 中有单个```\``` 表示escape special meaning, 但是regex 接受string, construct regex时候保留string 形式, 需要string 中有 ```\``` 形式, 所以要保留成 ```\``` 必须接受两个backslash 
        - 比如 ```regex  reg(\\+)```  因为加号有特殊含义，要escape, The actual string data get  stored in memory is ```\+``` . 
        - ```regex  reg(\\++)``` 表示match ```+``` 一次或者多次, 所以 string ```+```, ```++``` matches.  
        - ```regex  reg("\\\\+");```    Matches one or more backslashes.


Submatch Operations: These operations apply to ```ssub_match```, ```csub_match```, ```wssub_match```, ```wcsub_match```

| syntax | description | 
|----------|:-------------|
| ```matched``` | A public bool data member that 表示 whether this ```ssub_match``` was matched | 
| ```first``` <br/> ```second``` | public data members that are iterators  to the start and one past the end of the matching sequence. <span style="background-color:#FFFF00">如果no match, then ```first``` and ```second``` are equal</span> |
| ```length()``` | The size of this match. Returns 0 if ```matched``` is false | 
| ```str()``` | Returns a string <span style="background-color:#FFFF00">containing the **matched portion** of the input</span>. <span style="background-color:#FFFF00">Returns **empty string** if ```matched``` is **false**</span> |
| ```s = ssub``` | Convert the ```ssub_match``` object ```ssub``` to string ```s```. Equivalent to ```s = ssub.str()```. The <span style="background-color:#FFFF00">**convert operator** is **nonexplicit**</span> | 





例如下面表达式有两个parenthesized subexpression

- ```([[:alnum:]]+)```, which is a sequence of one or more characters 
- ```(cpp| cxx| cc)``` which is the file extension
- 比如 the file name is ```foo.cpp```, then ```results.str(0)``` hold ```foo.cpp```. ```results.str(1)``` will be ```foo```;  ```results.str(2)``` will be ```cpp```

```c++
// r has two subexpressions: the first is the part of the file name before the period 

// the second is the file extension

regex r("([[:alnum:]]+)\\.(cpp|cxx|cc)$", regex::icase);
```

print first subexpression

```c++
if (regex_search(filename, results, r))
    cout << results.str(1) << endl; // print the first subexpression

```


```c++
std::string s ("test subject");
std::smatch m;
std::regex e ("(sub)(.*)");

std::regex_search ( s, m, e );

for (unsigned i=0; i<m.size(); ++i) {
    std::cout << "match " << i << " (" << m[i] << ") ";
    std::cout << "at position " << m.position(i) << std::endl;
}

//print

match 0 (subject) at position 5
match 1 (sub) at position 5
match 2 (ject) at position 8
```

One common **use for <span style="color:red">subexpressions**</span> is to validate data that must match a <span style="color:red">**specific format**</span>. 比如美国手机号10位数, The area code enclosed in parentheses. remaining 7个 digits  可以separated by a dash, a dot or a space. or not spearated at all. 我们希望可以接受任何上面的形式 and reject 其他形式的, 首先用regular expression to find sequences that ight be phone number then call a function to complete valiation of data. 比如 ```(908.555.1800``` we would like to reject

define regular expression using subexpressions
1. ```(\\()?```  (\\()? an optional open parenthesis for the area code 
2. ```(\\d{3})``` the area code
3. ```(\\))?``` an optional close parenthesis for the area code 
4. ```([-. ])?``` an optional separator after the area code
5. ```(\\d{3})``` the next three digits of the number 
6. ```([-. ])?``` another optional separator
7. ```(\\d{4})``` the final four digits of the number




```c++
// our overall expression has seven subexpressions: ( ddd ) separator ddd separator dddd 

// subexpressions 1, 3, 4, and 6 are optional; 2, 5, and 7 hold the number

"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})";
```

完整code: pattern 有7个subexpressions. 因此 ```smatch``` object contain 8个 ```ssub_match``` elements. The element at ```[0]``` represent the overall match. The elements ```[1]...[7]``` represent each of the corresponding subexpressions. 

```c++
string phone = "(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})";
regex r(phone); // a regex to find our pattern smatch m;

string s;
while (getline(cin, s)) {
    // for each matching phone number
    
    for (sregex_iterator it(s.begin(), s.end(), r), end_it;
            it != end_it; ++it)
    // check whether the number's formatting is valid 
    
    if (valid(*it))
        cout << "valid: " << it->str() << endl; 
    else
        cout << "not valid: " << it->str() << endl;
}

bool valid(const smatch& m)
{
    // if there is an open parenthesis before the area code 
    
    if(m[1].matched)
        //区号后必须有一个右括号, 之后紧跟剩余好嘛或者一个空格

        return m[3].matched && (m[4].matched == 0 || m[4].str() == " ");
    else 
        //否则 区号后不能有右括号

        //另两组部分间 分隔符必须 匹配

        return !m[3].matched && m[4].str() == m[6].str();
}
```



**5. Using regex_replace**

- takes an input character sequence and a ```regex``` object 
- <span style="color:red">**refer to a particular subexpression** by using a ```$``` followed by **index number**</span> for a subexpression.
- library 定义了 <span style="background-color:#FFFF00">**flags**</span> that we can use to <span style="background-color:#FFFF00">**control match process** or **formatting**</span> done during a replacement
  - These flags can be passed to ```regex_search``` or ```regex_match``` functions or ```format``` members of class ```smatch```


<center>Regular Expression Replace Operations</center>

| syntax | description | 
|----------|:-------------|
| ```m.format(dest,fmt,mft)``` <br/> ```m.format(fmt,mft)``` | <span style="background-color:#FFFF00">Produced **formatted output** using **format string**</span> ```fmt```. the match in ```m```, and optional ```match_flag_type``` flags in ```mft```, 第一个版本是write to **output iterator** ```dest``` (§10.5.1) and takes ```fmt``` either a <span style="background-color:#FFFF00">**string**</span> or a <span style="background-color:#FFFF00">**pair of pointers** denoting a **range** in character array</span>. 第二个版本是returns a ```string``` that holds the output and takes ```fmt``` that is a <span style="background-color:#FFFF00">**string**</span> or <span style="background-color:#FFFF00">a **pointer to null-terminated character array**</span>. ```mft``` defaults to ```format_default```  |
| ```regex_replace(dest, seq, r, fmt, mft)``` <br/> ```regex_replace(seq, r, fmt, mft)``` | Iterators ```seq```. <span style="background-color:#FFFF00">using ```regex_search``` to **find successive matches** to regex ```r```</span>. 用format string ```fmt``` and optional ```match_flag_type``` falgs in ```mft``` to produce its output. 第一个版本是<span style="background-color:#FFFF00"> writes to **output iterator**</span> ```dest``` and takes <span style="background-color:#FFFF00">**a pair of iterators**</span> to denote ```seq```. 第二个版本是 返回 a string 保存输出 and ```seq``` can be either <span style="background-color:#FFFF00">**string**</span> or <span style="background-color:#FFFF00">**pointer to a null-terminated character array**</span>. In all cases, ```fmt``` can be a <span style="background-color:#FFFF00">**string**</span> or <span style="background-color:#FFFF00">**pointer to null-terminated character array**</span>. ```mft``` defaults to ```format_default```  |


比如上面的例子，我们想把电话转换为 “ddd.ddd.dddd“ 的形式,

```c++
string fmt = "$2.$5.$7"; // reformat numbers to ddd.ddd.dddd

string phone = "(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";
regex r(phone); // a regex to find our pattern

string number = "(908) 555-1800";
cout << regex_replace(number, r, fmt) << endl;

//print 908.555.1800

```

replace phone numbers that are embeded in large file
```c++
//比如

morgan (201) 555-2368 862-555-0123
drew (973)555.0130
lee (609) 555-0132 2015550175 800.555-0000

//转换成

morgan 201.555.2368 862.555.0123
drew 973.555.0130
lee 609.555.0132 201.555.0175 800.555.0000

string phone = "(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})";
regex r(phone); // a regex to find our pattern

smatch m;

string s;

string fmt = "$2.$5.$7"; // reformat numbers to ddd.ddd.dddd 

while (getline(cin, s))
    cout << regex_replace(s, r, fmt) << endl; return 0;
```



<center>Match Flags</center>

| syntax | description | 
|----------|:-------------|
| ```match_default``` | Equivalent to ```format_default``` |
| ```match_not_bol``` | Don't treat the first character as the beginning of the line |
| ```match_not_eol``` | Don't treat the last character as the end of the line |
| ```match_not_bow``` | Don't treat the first character as the beginning of the word |
| ```match_not_eow``` | Don't treat the last character as the end of the word |
| ```match_any``` | 如果存在多于一个匹配，则可返回任意一个匹配 |
| ```match_not_null``` | 不匹配任何空序列 |
| ```match_continuous``` | 匹配序列必须从输入的首字符开始 |
| ```match_prev_avail``` | 输入序列包含第一个匹配之前的内容 |
| ```format_default``` | Replacement string uses the ```ECMAScript``` rules |
| ```format_set``` | 用 POSIX sed 规则 替换 string |
| ```format_no_copy``` | 不输出 input序列中的未匹配部分 |
| ```format_first_only``` | Replace only the first occurence | 


上面例子，加上一个flag ```format_no_copy``` 不输出未匹配的部分

```c++
string fmt2 = "$2.$5.$7 "; // put space after the last number as a separator

// tell regex_replace to copy only the text that it replaces

cout << regex_replace(s, r, fmt2, format_no_copy) << endl;

//打印
201.555.2368 862.555.0123
973.555.0130
609.555.0132 201.555.0175 800.555.0000
```

```c++
 std::cmatch m;
 std::regex_match ( "subject", m, std::regex("(sub)(.*)") );
 std::cout << m.format ("the expression matched [$0].\n");
 std::cout << m.format ("with sub-expressions [$1] and [$2].\n");
 
//Output:

the expression matched [subject].
with sub-expressions [sub] and [ject].
```


#### (d). Random Numbers

1. **Random-Number Engines and Distribution**
2. **Seeding a Generator**
3. **Other Kinds of Distributions**



- Prior to new standard, Both C and C++ 依靠于 simple C library function ```rand```. <span style="color:red">函生成均匀分布(uniformly distributed)的 伪随机数(pseudorandom integers)</span>. 范围是从 0 到 system-dependent maximum value at least 32767. 但```rand``` 有一些问题:
    - 一些程序需要<span style="color:red">**different range**</span> from produced by ```rand```, 一些需要random floating-point numbers. Some 需要non-uniform distribution.  Programmers often introduce <span style="color:red">**nonrandomness** when they try to transform the range, type, or distribution</span> of the numbers generated by ```rand```
- defined in ```random``` header, 解决了这些问题through a set of cooperating classes: <span style="background-color:#FFFF00">**random-number engines** and **random-numberdistribution classes**</span>. 
    - An <span style="color:red">**engine**</span> generates a sequence of <span style="color:red"> ```unsigned``` random numbers</span>. 
    - A <span style="color:red">**distribution**</span> uses an <span style="color:red">**engine**</span> to <span style="color:red">generate random numbers of a specified type, in a given range, distributed</span> according to a particular probability distribution.
- C++ programs <span style="background-color:#FFFF00">不应该使用 ```rand``` function, 而是使用 ```default_random_engine```</span> along with an appropriate distribution
- output of calling a ```default_random_engine``` similar to output of ```rand```. <span style="color:red">**Engines**</span> 生成unsinged intergers in <span style="color:red">**system-defined range**</span>. <span style="color:red">**rand**</span> 生成范围是 <span style="color:red">0 到 ```RAND_MAX```</span>
- The <span style="color:red">**range**</span> of an engine type is returned calling ```e.min()``` and ```e.max()``` members on an object of that type


<center> Random Number Library Compoinents </center>

| Name | description | 
|----------|:-------------|
| Engine | Types that generate a sequence of random ```unsigned``` integers | 
| Distribution | Types that use an engine to return numbers according to a particular probability distribution | 


engine 的 min and max
```c++
cout << "min: " << e.min() << " max: " << e.max() << endl;
//print min: 1 max: 2147483646

```


**1. Random-Number Engines and Distribution**

-  random-number <span style="color:red">**engines** are **function-object classes** 定义了**call operator** takes no arguments and returns a random ```unsigned``` number</span>
    - 如果 ```e``` is engine, ```e()``` is to obtain the next random number.
- The library defines several <span style="background-color:#FFFF00">**random-number engines**</span> that differ in terms of their <span style="background-color:#FFFF00">**performance** and **quality of randomness**</span>. 每一个compiler 都会<span style="color:red">指定其中一个做为 **default_random_engine type**</span>。 此类型一般具有最常用的特性
    - 大多数情况, the <span style="color:red">**output of an engine** is **not directly used**</span>. The problem is that the numbers usually span a range that differs from the one we need. Correctly transforming the range of a random number is surprisingly hard.
- To get a number in a specified range, we <span style="color:red">use an object of a **distribution type**</span>:
    - Like engine type, <span style="background-color:#FFFF00">**distribution**</span> types are also <span style="background-color:#FFFF00">**function-object classes**</span>. Distribution types <span style="color:red">定义了 **call operator** that **takes a random-number engine**</span> as its argument. Distribution object 用engine to produce <span style="color:red">random number maps to specified distribution</span>
    - 如果pass the engine object itself, ```u(e)``` (u is distribution, e is engine). 如果我们写成 ```u(e())```  含义变成, 将```e``` 生成**下一个值**传递给 ```u```, 会**compile-time error**.<span style="color:red"> We **pass the engine, not the next result of the engine**</span>, 因为some distribution may need to call the engine <span style="color:red">**more than once**</span>


<center>Random Number Engine Operations</center>

| Syntax | Description | 
|----------|:-------------|
| ```Engine e;``` | Default constructor; uses the <span style="background-color:#FFFF00">**default seed** for the **engine type**</span> |
| ```Engine e(s);``` | Uses the integral value ```s``` as the seed | 
| ```e.seed(s)``` | <span style="background-color:#FFFF00">**Reset the state**</span> of engine using the seed ```s``` | 
| ```e.min()``` <br/> ```e.max()```| 此引擎可生成的最小值和最大值 | 
| ```Engine::result_type``` | 此引擎生成的 ```unsigned``` 整数类型 (integral type) | 
| ```e.discard(u)``` | Advance the engine by u steps; us has type ```unsigned long long``` |  




E.g. 

```c++
default_random_engine e; // generates random unsigned integers 

for (size_t i = 0; i < 10; ++i)
    // e() "calls" the object to produce the next random number 
    
    cout << e() << " ";//生成random numer 16807 282475249...

```

use an object of a distribution type to geet a number in specified range. <span style="background-color:#FFFF00">**注意只能写成** ```u(e)```, 不能是 ```u(e())```</span>

```c++
// uniformly distributed from 0 to 9 inclusive 

uniform_int_distribution<unsigned> u(0,9); 
default_random_engine e; // generates unsigned random integers 

for (size_t i = 0; i < 10; ++i)
    // u uses e as a source of numbers
    
    // each call returns a uniformly distributed value in the specified range 
    
    cout << u(e) << " ";

```

**2.Seeding a Generator**

- 即使numbers that are generated appear to be random, a given <span style="color:red">generator returns **the same sequence of number** 每次run</span>
  - It's very helpful during testing
- A given <span style="color:red">**random-number generator** always p**roduces the same sequence**</span> of numbers. A function with a local random-number generator should <span style="color:red">make that generator (both the **engine** and **distribution objects**) **static**</span>. Otherwise, the function will generate the identical sequence on each call.
- 产生相同的随机数在Debugging 时候有用, 一旦完成debugging, want each run to generate different random results, by <span style="color:red">providing a **seed**</span>. 种子是一个数值, 引擎可以利用它从sequence中重新开始生成新的随机数. 两种方式seed an engine
  - provide seed when create an engine 
  - call the engine's **seed** member
-  Pick a good seed 就像generate a good random numer，是非常难的. <span style="color:red">最常见的方法call system ```time```function</span> (defined in ```ctime``` header), return number of seconds since a given epoch. ```time``` function <span style="color:red">takes a single **paramter**</span> that is <span style="color:red">a pointer 指向用于**写入时间的数据结构**</spam>. 如果<span style="color:red">pointer 是空, the function just returns the time</span>  
   -  因为```time`` <span style="color:red">返回time 以秒计算, 因此这种方式值用于生成种子 **间隔为秒级** 或更长的应用</span>
      -  Using ```time``` as a seed usually doesn’t work if the program is run **repeatedly** as part of an automated process; it might wind up with the same seed several times.

比如, print equval, 因为```v1``` 和 ```v2``` 具有一样的值, 所以编写此函数的好方法 <span style="background-color:#FFFF00">make the engine and associated distribution objects **static**</span>
```c++
vector<unsigned> bad_randVec()
{
    default_random_engine e; 
    uniform_int_distribution<unsigned> u(0,9); 
    vector<unsigned> ret;
    for (size_t i = 0; i < 100; ++i)
        ret.push_back(u(e)); 
    return ret;
}

vector<unsigned> v1(bad_randVec());
vector<unsigned> v2(bad_randVec());
// will print equal

cout << ((v1 == v2) ? "equal" : "not equal") << endl;

//static 

vector<unsigned> good_randVec()
{
    // because engines and distributions retain state, they usually should be 
    
    // defined as static so that new numbers are generated on each call
    
    static default_random_engine e;
    static uniform_int_distribution<unsigned> u(0,9); 
    vector<unsigned> ret;
    for (size_t i = 0; i < 100; ++i)
        ret.push_back(u(e)); 
    return ret;
}
```

Provide a seed : ```e1``` 和 ```e2``` 有不同的 seeds 生成different sequences. ```e3``` 和 ```e4``` 有一样的seed value. 生成一样的 sequence.

```c++
default_random_engine e1; // uses the default seed 

default_random_engine e2(2147483646); // use the given seed value 

// e3 and e4 will generate the same sequence because they use the same seed 

default_random_engine e3; // uses the default seed value 

e3.seed(32767); // call seed to set a new seed value 

default_random_engine e4(32767); // set the seed value to 32767

for (size_t i = 0; i != 100; ++i) {
    if (e1() == e2())
        cout << "unseeded match at iteration: " << i << endl;   
    if (e3() != e4())
        cout << "seeded differs at iteration: " << i << endl; 
}
```

```c++
default_random_engine e1(time(0)); // a somewhat random seed

```

**3. Other Kinds of Distributions**

- engines 产生 unsigned numbers 每个number in engine's range 产生概率是相同的. Applications 通常使用 different types or distributions. 
    - The library handles both 上面的needs 通过<span style="background-color:#FFFF00">defining different **distribution**</span>, when used an engine, produce the desired results

<center>Distribution Operations</center>

| Syntax | Description | 
|----------|:-------------|
| ```Dist d;``` | Default constructor; makes ```d``` ready to use. Other constructors depend on type of ```Dist``` (在附录 A.3.). The <span style="background-color:#FFFF00">distribution **constructor** are **explicit**</span> | 
| ```d(e)``` | Successive calls with the same ```e``` produce a sequence of random numbers acoording to distribution type of ```d```. ```e``` is a **random-number engine generator** | 
| ```d.min()``` <br/> ```d.max()``` | Return the smallest and largest numbers ```d(e)``` will generate |
| ```d.reset()``` | Reestablish the state of ```d``` so that <span style="background-color:#FFFF00">**subsequent uses** of ```d``` **don't depend** on value ```d``` has already generate</span>  |


**Generating Random Real Numbers**

- 最常见但是 **Incorrect** way to obtain a random floating-point from ```rand``` is ```rand()/RAND_MAX``` (```RAND_MAX```: system-defined upper limit that is the **largest random number** that rand ```can``` return)
    - <span style="background-color:#FFFF00">错误原因是 **less precision**</span>: random integer 的精度 通常 低于 random floating-point number, 因此<span style="color:red">some floating-point values that will never be produced as output</span>
- With new library, 可以获取floating-point random number, <span style="color:red">define an object type ```uniform_real_distribution```</span>: let library mapping random integers to random floating-point number
    - 就像```uniform_int_distribution```,  ```uniform_real_distribution```: <span style="color:red">需要specifiy **minimum and maximum** value when define</span>
-  The distribution types are <span style="background-color:#FFFF00">**templates**</span> that have a <span style="background-color:#FFFF00">single template type parameter</span> that represents <span style="color:red">**type**</span> of the numbers that the distribution generates. These types always <span style="color:red">generate either a **floating-point** type or an **integral** type</span>.
    - 每一个 distribution template <span style="color:red">都有一个**default template argument**</span>. Distribution 用于 <span style="color:red">generate floating-point values 默认是 **double**</span>. Distribution 用于生成 <span style="color:red">integral type 默认值是 **int**</span>. 当用default: 在template's name后提供一个 empty angle bracket ```<>``` 表示使用 default 


E.g.
```c++
default_random_engine e; // generates unsigned random integers 

// uniformly distributed from 0 to 1 inclusive

uniform_real_distribution<double> u(0,1); 
for (size_t i = 0; i < 10; ++i)
    cout << u(e) << " ";

```

use distribution template default template type parameter

```c++
// empty <> signify we want to use the default result type 

uniform_real_distribution<> u(0,1); // generates double by default

```


**Generating Numbers That Are Not Uniformly Distributed**

- The library 定义了 20 种 distribution types, 在附录(§ A.3, p6781 or PDF p882)


E.g. generate a series of normally distributed values. 因为```normal_distribution``` generates floating-point number, 程序使用 ```cmath``` header 中的 ```lround``` function to round 每个 result to nearest integer. 生成200个数, mean = 4 and std = 1.5

```c++
default_random_engine e; // generates random integers 

normal_distribution<> n(4,1.5); // mean 4, standard deviation 1.5

vector<unsigned> vals(9); // nine elements each 0 

for (size_t i = 0; i != 200; ++i) {
    unsigned v = lround(n(e)); // round to the nearest integer 

    if (v < vals.size()) // if this result is in range

        ++vals[v]; // count how often each number appears 

}
for (size_t j = 0; j != vals.size(); ++j)
    cout << j << ": " << string(vals[j], '*') << endl;

```

生成结果为, 注: 如果打印出的图是完美对称的(perfectly symmetrical). 反倒有理由质疑random number generator了

```c++
0: ***
1: ********
2: ********************
3: **************************************
4: ********************************************************** 
5: ******************************************
6: ***********************
7: *******
8: *
```


**The bernoulli_distribution Class**

- one distribution that does <span style="color:red">**not take a template parameter**</span> 是 ```bernulli_distribution```, which is <span style="color:red">**an ordinary class**, **not template**</span>
- The distribution always return a **bool** value. <span style="color:red">returns true with a given probability. By default that probability is 0.5</span>
- <span style="background-color:#FFFF00">**declare engines outside of loops**</span>. 否则<span style="color:red">create a new engine on each iteration and 产生the same value on each iterator</span>. 同样的 <span style="background-color:#FFFF00">**distribution**</span> may retain state and <span style="background-color:#FFFF00">**should be defined outside loop**</span>


E.g. 一个游戏，用户或者程序必须先行，可以用```uniform_int_distribution``` 来选择, 也可以用```bernoulli_distribution``` 来选择, 假定有个 ```play``` function 进行游戏.


```c++
string resp;
default_random_engine e; // e has state(保持状态), so it must be outside the loop!

bernoulli_distribution b; // 50/50 odds by default

do {
    bool first = b(e); // if true, the program will go first 

    cout << (first ? "We go first"
            : "You get to go first") << endl; 
    // play the game passing the indicator of who goes first

    cout << ((play(first)) ? "sorry, you lost"
        : "congrats, you won") << endl;
    cout << "play again? Enter 'yes' or 'no'" << endl; 
} while (cin >> resp && resp[0] == 'y');

```

如果有beeter chancing of going first 
```c++
bernoulli_distribution b(.55); // give the house a slight edge
```


#### (e). The IO Library Revisited


1. **Formatted Input and Output**
2. **Unformatted Input/Output Operations**
3. **Random Access to a Stream**


**1. Formatted Input and Output**
- The library 定义 a set of <span style="background-color:#FFFF00">**manipulators**</span> that <span style="background-color:#FFFF00">**modify the format state**</span> of a stream. 
- A  <span style="background-color:#FFFF00">**manipulator**</span> is a  <span style="background-color:#FFFF00">**function**</span> or  <span style="background-color:#FFFF00">**object**</span> that <span style="color:red">affects the state of a stream</span> and can be used as an operand to an input or output operator. Like the input and output operators, a manipulator <span style="color:red">**returns the stream object**</span> to which it is applied, so we can combine manipulators and data in a single statement. 
    - 大多数manipulator 改变format state 所以提供了 ```set/unset``` pairs.
    - <span style="color:red">Manipulators</span> that change the format state of the stream usually <span style="color:red">**leave the format state changed for all subsequent IO**</span>    
        - useful when want to use the same formatting. 
        - 很多程序(程序员) 期望stream state as default. 所以最好undo state change 当不再需要format
- ```endl```: It writes a newline and <span style="color:red">flushes the buffer</span>.
- Manipulators are used for two broad categories of output control
    - controlling the presentation of numeric values 
    - controlling the amount and placement of padding
- The ```setprecision``` manipulators and other manipulators that take arguments are defined in the ```iomanip``` header.
- 默认情况, floating-point values print 精度是小数点后六位数; 如果没有fractional part, 不打印小数点. 
- 根据<span style="background-color:#FFFF00">number value 决定print either fixed decimal or scientific notation</span>. Library chooses a format that enhances readbility of number. 非常大或者非常小的数 print using scientific notation. 其他print in fixed decimal



<center>Manipulators Defined in iostream </center>


| Syntax (```*``` 表示default stream state) | Description | 
|----------|:-------------|
| ```boolalpha``` | 将 true 和 false 输出为strings | 
| ```* noboolalpha``` | true 和 false 输出为 0,1 |
| ```showbase``` | Generate prefix 表示numeric base of integral values | 
| ```* noshowbase``` | Do not generate notaional base prefix | 
| ```showpoint``` |  Always dislay a decimal point for floating-point values |
| ```* noshowpoint``` |  Display a decimal point only if the value has a fractional part | 
| ```showpos``` | Display ```+``` in nonnegative numbers |
| ```* noshowpos``` | Do not display ```+``` in nonnegative numbers |
| ```uppercase``` | Generate upper-case letters for string  |
| ```* nouppercase``` | Don't Generate upper-case letters for string |
| ```* dec``` | 整型值显示为十进制 |
| ```hex``` | 整型值显示为十六进制(hexadecimal) |
| ```oct``` | 整型值显示为八进制(octal) |
| ```left``` |  Add fill characters to the right of the value (左对齐) |
| ```right``` |  Add fill characters to the left of the value (右对齐) |
| ```internal``` | Add fill characters between the sign and the value | 
| ```fixed``` | Display floating-point values in decimal notation | 
| ```scientific``` | Display floating-point values in scientific notation | 
| ```hexfloat``` | Display floating-point values in hex(new to C++11) | 
| ```defaultfloat``` | Reset the floating-point format to decimal (new to C++11) | 
| ```unitbuf``` | Flush buffers after every output operation | 
| ```* nounitbuf``` | Restore the normal buffer flushing |
| ```* skipws``` | Skip whitespace with input operators | 
| ```noskipws``` | Do not skip whitespace with input operators |
| ```flush``` | Flush the ```ostream``` buffer |
| ```ends``` | Insert null, then flush the ```ostream``` buffer |
| ```endl``` | Insert newline, then flush the ```ostream``` buffer |

<center> Manipulators Defined in iomanip</center>

| Syntax | Description | 
|----------|:-------------|
| ```setfill(ch)``` | Fill whitespace with ```ch``` |
| ```setprecision(n)``` | Set floating-point precision to ```n``` |
| ```set(w)``` | Read or write value to ```w``` characters | 
| ```setbase(b)``` | Output integers in base ```b``` |




**(A). Controlling the Format of Boolean Values**: 

By default, bool values print as 1 or 0. 可以override this formatting by applying ```boolalpha``` manipulator

```c++
cout << "default bool values: " << true << " " << false
     << "\nalpha bool values: " << boolalpha
    << true << " " << false << endl;
//print

default bool values: 1 0 
alpha bool values: true false
```

To undo the format state change to cout, we apply noboolalpha. 下面code change the format of ```bool``` values only to print the value of ```bool_val```. 一旦完成, reset the stream back to its initial state 
```c++
bool bool_val = get_status();
cout << boolalpha // sets the internal state of cout

    << bool_val
    << noboolalpha; // resets the internal state to default formatting

```


**(B). Specifying the Base for Integral Values**: 

Notice that like ```boolalpha```, 下面这些 manipulators change the format state. They <span style="color:red">affect the immediately following output</span> and all subsequent integral output until the format is reset by invoking another manipulator.

```c++
cout << "default: " << 20 << " " << 1024 << endl;
cout << "octal: " << oct << 20 << " " << 1024 << endl; 
cout << "hex: " << hex << 20 << " " << 1024 << endl;
cout << "decimal: " << dec << 20 << " " << 1024 << endl;
//print 

default: 20 1024 
octal: 24 2000 
hex: 14 400 
decimal: 20 1024
```

**(C). Indicating Base on the Output**

默认没有cue  as to what notational base was used. 比如 20, really 20, or an octal representation of 16? 如果我们需要print octal or hexadecimal values, we should use ```showbase``` manipulator. 

- A leading ```0x``` indicates hexadecimal(十六进制).
- A leading ```0``` indicates octal(八进制).
- The absence of either indicates decimal(十进制).


```c++
cout << showbase; // show the base when printing integral values 

cout << "default: " << 20 << " " << 1024 << endl;
cout<<"inoctal:"<<oct <<20<<""<<1024<<endl; 
cout<<"inhex:"<<hex <<20<<""<<1024<<endl; 
cout << "in decimal: " << dec << 20 << " " << 1024 << endl; 
cout << noshowbase; // reset the state of the stream

//print 

default: 20 1024
in octal: 024 02000 
in hex: 0x14 0x400
in decimal: 20 1024
```

默认情况下, hexadecimal 前导符号 ```x```是小写. We can display the ```X``` and the hex digits ```a–f``` as uppercase by applying the uppercase manipulator: ```uppercase```. Then apply the ```nouppercase```, ```noshowbase```, and ```dec``` manipulators to <span style="color:red">return the stream to its original state</span>.

```c++
cout << uppercase << showbase << hex
<< "printed in hexadecimal: " << 20 << " " << 1024 
    << nouppercase << noshowbase << dec << endl;
//print 

printed in hexadecimal: 0X14 0X400
```

**(D). Controlling the Format of Floating-Point Values**

可以控制:

- How many digits of precision are printed
- Whether the number is printed in hexadecimal, fixed decimal, or scientific notation
- Whether a decimal point is printed for floating-point values that are whole numbers


**(E).Specifying How Much Precision to Print**

The ```precision``` member is overloaded 
- 一个版本是 takes an ```int``` value and **sets** the precision to that **new value**. <span style="background-color:#FFFF00">It **returns previous precision value**</span>
- 另一个版本是 take no arguments and <span style="background-color:#FFFF00">**returns the current precision value**</span>.
- ```setprecision``` takes an argument which it uses to set the precision

下面```sqrt``` functin 定义在 ```cmath``` header 中. 不同的 ```sqrt``` function overloaded and can be called on either a float, double or long double argument. 返回square root of its argument  

```c++
// cout.precision reports the current precision value

cout << "Precision: " << cout.precision()
    << ", Value: " << sqrt(2.0) << endl; 

// cout.precision(12) asks that 12 digits of precision be printed

cout.precision(12);
cout << "Precision: " << cout.precision()
    << ", Value: " << sqrt(2.0) << endl;

// alternative way to set precision using the setprecision manipulator

cout << setprecision(3);
cout << "Precision: " << cout.precision()
    << ", Value: " << sqrt(2.0) << endl;

//print 
Precision: 6, Value: 1.41421 
Precision: 12, Value: 1.41421356237 
Precision: 3, Value: 1.41
```

**(F). Specifying the Notation of Floating-Point Numbers**

- 除非需要control presentation of floating-point number (比如 print data in columns or print data 表示money or percentage). <span style="color:red">最好用library choose the notation </span>

- ```scientific```: scientific notation
- ```fixed```: change the stream to use fixed decimal 
- ```hexfloat```: force floating-point values to use 
- ```defaultfloat```: returns the stream to its default state: 根据打印的值选择计数法
- 上面这些manipulator 也改变了 meaning of precision. 
    - After executing ```scientific```, ```fixed```, or ```hexfloat```, the precision value <span style="background-color:#FFFF00">controls the number of digits after the decimal point(控制小数点后面的数字位数)</span>. 
    - By default, precision specifies the <span style="background-color:#FFFF00">total number of digits—both before and after the decimal point(默认是小数点前和小数点后 数字总位数)</span>.

注意 下面例子默认情况下, ```e``` used in scientific notation are printed in lowercase, 可以用 ```uppercase``` manipulator 变成 upppercase 

```c++
cout << "default format: " << 100 * sqrt(2.0) << '\n'
     << "scientific: " << scientific << 100 * sqrt(2.0) << '\n'
     << "fixed decimal: " << fixed << 100 * sqrt(2.0) << '\n' 
     << "hexadecimal: " << hexfloat << 100 * sqrt(2.0) << '\n'
     << "use defaults: " << defaultfloat << 100 * sqrt(2.0) << "\n\n";

//print 

default format: 141.421 
scientific: 1.414214e+002 
fixed decimal: 141.421356 
hexadecimal: 0x1.1ad7bcp+7 
use defaults: 141.421
```

**(G). Printing the Decimal Point**

默认情况下, 不打印小数点. The ```showpoint``` manipulator forces the decimal point to be printed. The ```noshowpoint``` manipulator reinstates the default behavior. The next output expression will have the default behavior 既浮点值的小数部分为0时不打印小数点

```c++
cout << 10.0 << endl; // prints 10 

cout << showpoint << 10.0 // prints 10.0000

    << noshowpoint << endl; // revert to default format for the decimal point

```

**(H). Padding the Output**

- ```setw``` specify minimum space for the <span style="background-color:#FFFF00">**next**</span> numeric or string value
- ```left``` to left-justify the output 
- ```right``` : right-justify the output. Output is right-justified by default 
- ```internal```: 控制负数符号位置，它左对齐符号，右对齐值, 用空格填满（padding）中间所有空间
- ```setfill```: 允许指定字符代替默认空格来补白输出(pad the outut)
- 注意```setw``` 与 ```endl``` 类似,<span style="color:red">不改变stream internal state, 只决定下一个输出大小</span>

```c++
int i = -16;
double d = 3.14159;
// pad the first column（补白第一列） to use a minimum of 12 positions in the output

cout << "i: " << setw(12) << i << "next col" << '\n'
    << "d: " << setw(12) << d << "next col" << '\n'; 

// pad the first column and left-justify all columns

cout << left
    << "i: " << setw(12) << i << "next col" << '\n' 
    << "d: " << setw(12) << d << "next col" << '\n'
     << right; // restore normal justification


// pad the first column and right-justify all columns 

cout << right
    << "i: " << setw(12) << i << "next col" << '\n'
    << "d: " << setw(12) << d << "next col" << '\n'; 

// pad the first column but put the padding internal to the field

cout << internal
    << "i: " << setw(12) << i << "next col" << '\n'
    << "d: " << setw(12) << d << "next col" << '\n'; 

// pad the first column, using # as the pad character

cout << setfill('#')
    << "i: " << setw(12) << i << "next col" << '\n' 
    << "d: " << setw(12) << d << "next col" << '\n' 
    << setfill(' '); // restore the normal pad character

//print

i:         -16next col
d:     3.14159next col
i:-16         next col     
d:3.14159     next col
i:         -16next col
d:     3.14159next col
i:-         16next col
d:     3.14159next col
i:-#########16next col 
d:#####3.14159next col
```


**(I). Controlling Input Formatting**

- 默认情况下, input operators 忽略whitespace (blank, tab, newline, formfeed, and carriage return)
- The ```noskipws``` manipulator causes the input operator to <span style="background-color:#FFFF00">**read**</span>, rather than skip, <span style="background-color:#FFFF00">**whitespace**</span>.

默认情况下 下面code, 
```c++
char ch;
while (cin >> ch)
    cout << ch;
```

Input: 
```
a b  c 
d
```
执行 four times to read the characters a through d. The output from program is <span style="color:red">skipping the intervening blanks, possible tabs, and newline characters</span> Output:

```
abcd
```

The ```noskipws``` manipulator causes the input operator to <span style="background-color:#FFFF00">**read**</span>, rather than skip, <span style="background-color:#FFFF00">**whitespace**</span>.

```c++
cin >> noskipws; // set cin so that it reads whitespace 

while (cin >> ch)
    cout << ch;
cin >> skipws; // reset cin to the default state so that it discards whitespace

```

this loop <span style="color:red">makes seven iterations, reading whitespace as well as the characters in the input</span>. Output:

```
a b  c 
d
```

**2.Unformatted Input/Output Operations**

- library provides low-level operations 支持 <span style="background-color:#FFFF00">**unformatted IO**</span>. 让我们deal with <span style="color:red">stream as a sequence of **uninterpreted bytes**</span>


<center>  Single-Byte Low-Level IO Operations </center>


| Syntax | Description | 
|----------|:-------------|
| ```is.get(ch)``` | Put the next byte from ```istream is``` in character ```ch```(读取放进```ch```), Returns ```is``` |
| ```os.put(ch)``` | Put the character ```ch``` onto ```ostream os```. Returns ```os``` | 
| ```is.get()``` | Returns next byte from ```is``` as an ```int``` |
| ```is.putback(ch)``` | Put the character ```ch``` back on ```is```; return ```is``` |
| ```is.unget()``` | Move ```is``` back one type(向后移动一个字节, 将读取的值退回流); return ```is``` |
| ```is.peek()``` | Return the next byte as ```int``` but doesn't remove it | 


**Single-Byte Operations**: read 而不是 ignore whitespace. 比如下面例子<span style="color:red">**preserves the whitespace** in input. Output 跟 input 一样</span>. 与之前用```noskipws``` 一样

```c++
char ch;
while (cin.get(ch))
    cout.put(ch);
```

**Putting Back onto an Input Stream**

- ```peek```: returns a <span style="color:red">**copy** of next character on input stream  but not change the stream</span>. ```peek``` 返回的值仍留在 stream 中
- ```unget```: 使流向后移动, 从而最后读取的值又回到流中, 即使不知道最后从六中读取什么值, 仍然可以调用```unget```
- ```putback```: 特殊版本的```unget```，退回从流中读取的最后一个值, 接受一个参数, 此参数必须与最后读取的值相同
- 注: <span style="color:red">只能**put back** at most **one value** before next read</span>. 不保证call ```putback``` or ```unget``` successively without an intervening read operation.

**int Return Values from Input Operations**

- ```get``` 和 ```peek``` 都返回int,而不是char. 因为int allow them to return an <span style="color:red">**end-of- file marker**</span>. char 没有表示end-of-file 的
- 返回int 的函数 将他们要```char``` convert 到 unsigned ```char``` 再promote to ```int```. 因此character set 有character map 到负数, the ```int``` returned from 将会是正的. 
- library 用<span style="color:red">**negative value** 表示 **end-of-file**</span>. 保证了与任何合法char的值都不同.
  - ```cstdio``` 定义了一个名为 ```EOF``` 的 const, 可以用它检测从 ```get``` 返回的值是否为 **end-of-file**
  - 非常重要要用 ```int``` hold the return from the function
- 建议用 type-safe, higher-level IO operations 而不是 low-level IO operations

```c++
int ch; // use an int, not a char to hold the return from get() 

// loop to read and write all the data in the input

while ((ch = cin.get()) != EOF)
    cout.put(ch);
```

如果用了 char 而不是 int, 如果在一台 ```char``` implemented as ```unsigned char``` 的机器, 将会是灾难，程序永远不会停止, 因为get 返回 EOF 时, 被转换为 ```unsigned char```, 转化得到的值不在于 ```int``` 值相等, 在一台 ```char``` implemented as ```signed char``` 的机器, 不能确定loop的行为. what hapens to an out-of-bounds value 被assigned to a signed value 取决于compiler. 很多机器上可以正常工作除非input matches EOF valus(尽管普通input 不太可能). 比如 输入包含```\377``` , 循环终止, 因为我们机器上, -1 转换为sign char, 就会得到 ```\377```

```c++
char ch; // using a char here invites disaster!

// the return from cin.get is converted to char and then compared to an int

while ((ch = cin.get()) != EOF)
    cout.put(ch);
```


**Multi-Byte Operations**

- 下面表中operatios require us to allocate and manage character arrays 用于store and retrieve data.

Multi-Byte Low-Level IO Operations:

- ```is.get(sink,size, delim)``` : 
    - 从```is``` 中 最多读取 ```size``` 个 bytes and <span style="color:red">stores them in **char array**</span> beginning at the address pointed by ```sink```. 读取过程直至遇到字符 ```delim``` 或读取 ```size``` 个字节 或者遇到文件尾时停止, 如果遇到了```delim``` 则将其保留在input stream and not read ```delim``` into ```sink```
- ```is.getline(sink,size,delim)```:
    - 与上面版本类似，<span style="background-color:#FFFF00">但会读取并丢弃 ```delim```</span>
- ```is.read(sink,size)```: 
    - Reads up to ```size``` bytes into character array ```sink```. Returns ```is``` 
- ```is.gcount()```: 
    - Returns <span style="color:red">**number of bytes read** from the stream ```is``` by last call</span> to an unformatted read operation
    - 可以call ```gcount``` <span style="background-color:#FFFF00">before any intervening **unformatted input operation**</span>. 特别的是， single-character operation hat put character back to tream 属于 unformatted input operations. 如果 ```peek```, ```unget```, or ```putback``` are calling before ```gcount```, return value will be 0 </span>
- ```os.write(source, size)```
    - Writes ```size``` bytes from the character array ```source``` to ```os```. Returns ```os```
- ```is.ignore(size, delim)```
    - 读取并忽略最多 ```size``` 个字符, 包括```delim```. 不像其他未格式化的函数, ```ignore``` has default arguments: ```size``` defaults to 1 and ```delim``` to end-of-file.  
- ```get``` 和 ```getline``` functions  接受相同的参数, actions are similar but not identical. 
    - 相同的是 ```sink``` 都是一个char array 用来保存数据.  <span style="background-color:#FFFF00">delimiter 都不会存到 ```sink```</span>
    - 不同是 treat delimiter differently.```get``` leaves delimiter as next character in ```istream```. ```getline``` read 并丢弃 delimiter.  
    - 两个function 都一直读取数据直到: 
        - 已经读取 ```size-1``` 个characters
        - **End-of-file** is encountered 
        - The **delimiter** character is encountered



**3.Random Access to a Stream**


- library provides funcion ```seek``` to given localtion and ```tell``` current location in associated stream 
- 尽管```seek``` and ```tell``` are defined for all stream types, 但是比如绑定到```cin```, ```cout```, ```cerr```, ```clog``` 流 不支持random accesss 是没有意义的, , 比如```count``` 直接输出, 向回跳10个位置没有意义
  - 对这些流 ```seek``` and ```tell```, will <span style="color:red">fail at run time, leave the stream in an invalid state</span>
- <span style="color:red">**Support random access**</span>, IO types matiner a marker that determines where the next read or write will happen</span>
  - 定义了两对 seek and tell and distinguiushede by suffix: g 表示 getting, p 表示 putting 
    - 只能用 g version on an ```istream``` and on ```ifstream``` and ```istringstream``` (inhert from ```istream```), 不能用 ```seekg```. 
    - 只能用 p version on ```ostream``` 和 它的子类 ```ofstream``` and ```ostringstream```. 
  - ```iostream```, ```fstream```, ```stringstream``` 可以用both types, either g or p version 
- <span style="background-color:#FFFF00">There Is **Only One Marker**</span>: 即使有seek and tell 函数, 但不存在 read marker and writ marker.
  - Because there is only a single marker, we must <span style="color:red">**do a seek to reposition the marker**</span> whenever we <span style="color:red">**switch**</span> between reading and writing.
  - 比如```fstream``` 和 ```stringstream``` 可以read and write the same stream. 但<span style="color:red">**只有一个buffer** that holds data to be read and written and a **single marker** 表示current position in buffer</span>. library maps both g and p positions to this buffer

<center> Seek and Tell Functions </center>

| Syntax | Description | 
|----------|:-------------|
| ```tellg()``` <br/> ```tellp()``` | Return current position of the marker in input stream (```tellg```) or an output stream (```tellp```) | 
| ```seekg(pos)``` <br/> ```seekp(pos)``` | <span style="background-color:#FFFF00">**Reposition the marker**</span> in input or output stream to given absolute address in stream. ```pos``` 通常是前一个 ```tellg``` or ```tellp``` 的返回值 | 
| ```seekp(off,from)``` <br/> ```seekg(off,from)``` | 字啊一个输入流或者输出流中将标记定位到```from``` 之前或之后 ```off``` 个字符, ```from``` 可以是下列值之一 |
| |  - ```beg``` seek relative to the beginning of the stream | 
| |  - ```cur``` seek relative to the current position of the stream | 
| |  - ```end``` seek relative to the end of the stream | 


**Repositioning the Marker**

- <span style="background-color:#FFFF00">参数 ```new_position``` 和 ```offset```类型分别为 ```pos_type``` 和 ```off_type```. 都是**machine-dependent types**</span>(各自defined in ```istream``` 和 ```ostream```). 
- ```pos_type```表示 file position and ```off_type``` 表示offset from that position. value of type <span style="background-color:#FFFF00">```off_type``` 可以是**正的或者负的**</span>, can sek forward or backward in file

```c++
// set the marker to a fixed position

seekg(new_position); // set the read marker to the given pos_type location 

seekp(new_position); // set the write marker to the given pos_type location

// offset some distance ahead of or behind the given starting point

seekg(offset, from); // set the read marker offset distance from from 

seekp(offset, from); // offset has type off_type

```


例子
```c++
// remember the current write position in mark 

ostringstream writeStr; // output stringstream

ostringstream::pos_type mark = writeStr.tellp(); // ...

if (cancelEntry)
    // return to the remembered position 
    
    writeStr.seekp(mark);
```


**Reading and Writing to the Same File**

e.g. 写一个新行 contains the relative position at which each line begins

- 注意不用输出第一行, 因为从第一行开始的
- offset counts 每行结尾的换行符

```
abcd 
efg 
hi
j

生成: 
abcd 
efg 
hi
j
5 9 12 14
```


```c++
// open for input and output and preposition file pointers to end-of-file

fstream inOut("copyOut", fstream::ate | fstream::in | fstream::out); 
if (!inOut) {
    cerr << "Unable to open file!" << endl;
    return EXIT_FAILURE; // EXIT_FAILURE see § 6.3.2(p. 227)

}  
// inOut is opened in ate mode, so it starts out positioned at the end position

auto end_mark = inOut.tellg();// remember original end-of-file

inOut.seekg(0, fstream::beg); // reposition to the start of the  file 

size_t cnt = 0; // accumulator for the byte count 

string line; // hold each line of input

// while we haven't hit an error and are still reading the original data

while (inOut && inOut.tellg() != end_mark
        && getline(inOut, line)) { // and can get another line of input 

    cnt += line.size() + 1;  // add 1 因为换行符
    
    auto mark = inOut.tellg(); // remember the read position

    inOut.seekp(0, fstream::end); // set the write marker to the end

    inOut << cnt; // write the accumulated length

    // print a separator if this is not the last line

    if (mark != end_mark) inOut << " ";

    inOut.seekg(mark); // restore the read position 

}
inOut.seekp(0, fstream::end);  // seek to the end

inOut << "\n";  write a newline at end-of-file

```































***

## 18. Tools for Large Programs

#### (a). Exception Handling

1. **Throwing an Exception**
2. **Catching an Exception**
3. **Function try Blocks and Constructors**
4. **The noexcept Exception Specification**
5. **Exception Specifications and Pointers, Virtuals, and Copy Control**
6. **Exception Class Hierarchies**

**1. Throwing an Exception**

- <span style="background-color:#FFFF00">**Exception handlng**</span> allow to hand problems that arise at <span style="background-color:#FFFF00">**run time**</span>
- one part of program detect problem and pass job of resolving to another part of program (Detecting part 不需要知道handling part)
- exception is **raised** by throwing an expression. type of thrown expression, with current call chain 决定了 which <span style="color:red">**handler**</span> 处理 exception
   - selected handler in current call chain 是最接近 type of thrown object
   - type and contents of throwing object inform halder what went wrong 
- when ```throw``` executed, <span style="color:red">statement following ```throw``` 不被执行</span>. 而是 <span style="color:red">**control** is transferred from ```throw``` to matching ```catch```</span>. ```catch``` 可能是同一个函数local 的 or 直接或间接called the function  which exception occurred. control pass 用两个implications:
    - <span style="color:red">**Functions**</span> along the call chain 也许<span style="color:red">**prematurely exited**</span>(提早退出)
    - when a handler is entered, <span style="color:red">**objects**</span> created along the call chain 将 <span style="color:red">被 **destoryed**</span>.
    - 因此statements following a throw 不会被执行, a <span style="color:red">```throw``` is like return </span>. 通常是<span style="color:red">**conditional statement**</span> or <span style="color:red">**last statement in a function**</span>


**Stack Unwinding**

- 发exception thrown, execeution of current <span style="color:red">function **suspended** and search for matching ```catch ``</span> clause begin:
    - 如果 ```throw``` inside a try block, 检查与该 ```try``` 块关联的 ```catch``` 语句。如果catch 匹配, 就使用该 catch 处理exception. 否则. 如果该 try 语句嵌套在 其他的try 块中, <span style="color:red">检查与**外层try** 匹配的 ```catch```</span>. <span style="color:red">如果找不到匹配的 ```catch```, 退出当前函数</span>(current function) and search continue in the calling function （在调用当前函数外层函数中继续寻找）
    - 如果call to the function that threw is in a ```try``` block, 检查与try 关联的catch, 如果发现匹配的catch, 用该catch处理异常. 否则 继续检查外层try 匹配的catch, 如果没有找到, calling function is exited. search 外层的函数
    - 上面的过程叫做 <span style="background-color:#FFFF00">**stack unwinding**</span>: <span style="color:red">continue up **the chain of nested function** calls until a ```catch``` clause</span> for exception is found, or ```main``` function is exited without having found a matching ```catch```
        - 如果matching catch found, catch is entered, <span style="color:red">**program continue** by executing code inside catch</span>. 
        - 如果没有matching catch found,  <span style="color:red">*program is **exited**</span>. program calls the library ```terminate``` function, stops the execution of program.
- During **stack unwinding**, blocks in the call chain may be **exited prematurely**(调用链上的语句块可能提前退出)
    - <span style="color:red">When a block is exited during **stack unwinding**</span>, the <span style="color:red">compiler **guarantees**</span> that <span style="color:red">objects</span> created in that block are <span style="color:red">properly **destroyed**</span>
        - 如果local object is class type, <span style="color:red">destructor 自动被call </span>
        - As usual, compiler does **no work** to destroy objects of built-in type. 
    - 如果exception in <span style="background-color:#FFFF00">**constructor**</span>, object 也许 <span style="color:red">**partial constructor**</span>.一些member 被 initialized, but others 没有被initialized. 我们需要<span style="color:red">保证constructed member properly destroyed</span>
    - 如果exception in **destructor**, exception occurs before 负责free resource 代码, free resources被跳过(will not executed). 所以we 需要ensure that resouces are properly freed when using class to control resource allocation.  
        - 如果throw exception, 没有被catch, ```terminated``` is called
        - 所以<span style="color:red">never throw exceptions that destructor itself doesn't hanlde</span>; 如果might throw, should <span style="color:red">wrap in a try block</span> and handle it locally to destructor
        - 实际上, 因为destructor <span style="color:red">free resources, **unlikely** they will throw exceptions</span>. 
        - 所有的standard library types <span style="color:red">保证destructor not raise an exception</span>.
 


**The Exception Object** 

- <span style="background-color:#FFFF00">**execption object**</span>: compiler <span style="color:red">use the **thrown expression** to **copy initalize**. 
    - 因此, the  <span style="color:red"> expression in a ```throw``` 必须有 **complete type**</span>
    - 如果expression has class type,  <span style="color:red">destructor accessible and accessible copy or move constructor</span>.
    - 如果expression 是array of function type, expression 被转化为pointer type
- exception object 在space 中, managed by compiler, guaranteed to be **accessible** to ```catch``` is invoked. THe exception object <span style="color:red">被 **destoryed** after exception is completely handled</span>
- 因为an exception thrown, call chain exit 直到 发现 matching handler, 所以 <span style="color:red">throw a **pointer to a local object**</span> is <span style="color:red">**error**</span>
    - 因为If the pointer points to an object in a <span style="color:red">**block** that is **exited** before the catch</span>, then that local object will have been destroyed before the catch.
    - 同理返回a pointer to local object is error, 因为返回前, local object destoryed.
- Expression <span style="background-color:#FFFF00">**static**, compile-time type 决定了 **type of exception** object</span>
    - 比如throw expression derefereces <span style="color:red">a pointer to a base-class type points to a derived-type object</span>. thrown object is sliced-down; <span style="color:red">only **base-class** part is thrown</span>


**2.Catching an Exception**

- **exception declaration** 在 **catch clause** 像function parameter list 只有 exavtly 一个parameter. 可以<span style="color:red">忽略name</span> of catch parameter 如果 catch <span style="color:red">no need to access thrown expression</span>
- The **type** of the declaration 决定什么类型exceptions can catch, <span style="color:red">Type 必须是 **a complete type**, 可以是 **lvalue reference**, 不能是 rvalue reference </span>
- parameter in <span style="background-color:#FFFF00">**exception declaration** is **initialized** by **exception object**</span>. 
    - 如果 ```catch``` parameter 是 <span style="color:red">**nonreference** type</span>, then parameter in catch is <span style="color:red">**copy** of exception object</span>. changes made to parameter inside catch are made to local copy not to exception object 
    - 如果 ```catch``` parameter 是 <span style="color:red">**reference** type</span>. catch parameter is another name for exception object. <span style="color:red">Changes</span> made to parameter are made to <span style="color:red">exception object</span>
    - 如果 catch parameter that has <span style="color:red">**a base-class**</span> type 可以被<span style="color:red">initialized by an exception **object derived from parameter type**</span>
        - 如果 catch parameter a <span style="color:red">**nonreference type**</span>, <span style="color:red">exception object is **sliced down**</span>. 
        - 如果parameter is <span style="color:red">**reference** to a base-class type</span>, then parameter bound to exception object in usual way(derived-to-base conversion).
    - 跟function 一样, <span style="color:red">**static** type</span> of the exception declaration <span style="color:red">determines the actions that the catch may perform</span> 比如 如果catch parameter 是 base-class type, then the catch <span style="color:red">cannot use any members that are unique to the derived type</span>.


**Finding a Matching Handler**

- catch 发现的 不一定是最匹配的,而是 <span style="background-color:#FFFF00">**first one**</span> that <span style="color:red">matches the exception at all</span>
    - 因此, in a list of ```catch```, the <span style="color:red">most specialized catch must appear first</span>
    - <span style="color:red">**derived** type</span> should ocure <span style="color:red">**before**</span> a catch for <span style="color:red">**base** type</span>. Most derived 放前面, least derived 放后面
- rules for when an <span style="color:red">**exception** matchces a catch **exception declaration** 是严格的</span>
    - Conversions from nonconst to const are allowed. 因此throw of a **nonconst** oject 可以match a catch specified to take a **reference to const** 
    - Conversion from derived type to bas type are allowed.
    - Array is converted to a pointer to the type of the array; A function is converted to the appropriate pointer to function type.
    - 不允许arithmetic conversion 和 conversion defined for class types 
-  To **catch all exceptions**,use an **ellipsis** for the exception declaration. 
    - 通常上 <span style="background-color:#FFFF00">catch all clause ```catch(...)``` is often combination</span> with a **rethrow**</span> expression
    -  如果```catch(...)``` is used in combination with other catch clauses, catch-all 必须最后出息 （last), 否则<span style="color:red">any match 在 catch-all 之后的 never matched</span>


```c++
void manip(){
    try{
        //actions that cause an exception to be thrown

    }catch(...){
        //work to partially handle the exception

    } 

}
```


**Rethrow**

- 有时候单独catch 不能完全处理 exception. A catch may decide that the exception must be handled by a function **further up the call chain**. A catch <span style="color:red">passes its exception out to another catch</span> by <span style="background-color:#FFFF00">**rethrowing**</span> the exception
- A rethrow is a ```throw``` that is not followed by an expression: ```throw```
    - empty ```throw``` 只能<span style="color:red">出现在 in a ```catch``` or in a function called from a ```catch```</span>
    - rethrow 不 specify an expression, <span style="color:red">**exception object is passed up the chain**</span>
    - 如果改变parameter后 rethrow, <span style="color:red">这些changes will be propagated only if catch **exception declaration** is a **reference**</span>

比如下面例子只有parameter 是 reference时候, 才会更改 exception object pass up the chain 

```c++
catch (my_error &eObj) { // specifier is a reference type

    eObj.status = errCodes::severeErr; // modifies the exception object

    throw; // the status member of the exception object is severeErr

} catch (other_error eObj) { // specifier is a nonreference type 

    eObj.status = errCodes::badErr; // modifies the local copy only

    throw; // the status member of the exception object is unchanged 
    
}
```

**3. Function try Blocks and Constructors**

- 如果exception occur in <span style="color:red">**consturctor initializer**</span>, <span style="color:red">catch inside constructor body can't handle</span> exception thrown by constructor initializer 因为 ```try``` block inside constructor body 不会in effect when exception thrown
- try block lets us associate a group< of catch clauses with the **initialization** phase of a **constructor**(or the destruction phase of a destructor) 和 constructor's (or destructor's) function body. 比如下面例子
- The only way for a constructor to handle an exception from a constructor initializer is to <span style="color:red">write the constructor as a **function try block**</span>.

注意:

- keyword <span style="color:red">```try``` appears before colon</span> that begins constructor initializer list and before curly brace that forms constructor function body
- try 关联的 <span style="background-color:#FFFF00">catch 既能处理excpetion in **initialization list** fo from **constructor body**</span>
- 还有注意的是: exception can happen while initializing constructor's parameter. <span style="color:red">Such exceptions 不是 part of function ```try``` block</span>, **function try block** 只能 handle once constructor 开始execution. <span style="color:red">if exception occurs 在parameter **initialization**, that exception is handled in caller's context</span>


```c++
template <typename T> Blob<T>::Blob(std::initializer_list<T> il) try :
        data(std::make_shared<std::vector<T>>(il)) { 
    /* empty body */
} catch(const std::bad_alloc &e) { handle_out_of_memory(e); }
```


**4. The noexcept Exception Specification****

- 如果compiler know no exception thrown, perform optimiations (不适用于可能throw的)
  - The ```noexcept``` specifier must appear <span style="color:red">on **all of the declarations**</span> and the corresponding <span style="color:red">**definition**</span> of a function or <span style="color:red">on **none** of them</span>
  - ```noexcept``` 应在trailing return 之前. 
  - 也可以 sepcify ```noexcept``` on declaration and definition of a function pointer. 
  - 不能appear in a ```typedef``` or type alias.
  - 在const ,reference qualifier 之后, 在 ```final```, ```override``` or virtual function ```=0``` 之前
- compiler <span style="background-color:#FFFF00">no check sxception specifications </span> 对于 声明 ```noexcept``` 是否throw exception 不会检查 at <span style="background-color:#FFFF00">**compiled time**</span>
  - 如果声明了```noexcept``` does throw, <span style="color:red">```terminate``` is called</span>. enforcing the promise not to throw at **run time**
- ```noxcept``` 应该被用于两种情况: 
  - case 1: confident that function won't throw
  - case 2: don't know what to handle the error
- ```noexcept``` 有个 <span style="color:red">optional argument</span> that 必须 convertible to ```bool```. 如果argument is true, the function won't throw; 如果argument is false, then function might throw.
- ```noexcept``` Operator: unary operator(一元运算符), returns a **bool rvalue constant expression** 表示 whether given expression might throw. 像```sizeof```, ```noexcept``` 不会 evaluate its operand.  
  - ```noexcept``` specifier 的argument 通常与 ```noexcept``` operator 混合使用, 
  - ```noexcept(e)``` : 返回true, 如果 e  <span style="color:red">have nonthrowing specification ```noexcept```</span> and ```e``` itself does <span style="color:red">not contain a ```throw```</span>. 否则 返回 false
- ```noexcept``` has two meanings:
  -  It is an exception specifier when it follows a function’s parameter list, 
  -  it is an operator that is often used as the bool argument to a ```noexcept``` exception specifier.







下面例子, 我们说 ```recoup``` has a <span style="color:red">**nonthrowing specification**</span>
```c++
void recoup(int) noexcept; // won't throw 

void alloc(int); // might throw

```

早期c++ 提供了更详细的exception specifications 可以specify the types of exceptions that function might throw. ```throww``` specifier appeared in the same place as ```noexcept``` specifier. The approach never use and deprecated in current standarad. ```throw()``` 表示不throw any exceptions

```c++
void recoup(int) noexcept; // recoup doesn't throw 

void recoup(int) throw(); // equivalent declaration

```

```noexcept``` optional argument 

```c++
void recoup(int) noexcept(true); // recoup won't throw 

void alloc(int) noexcept(false); // alloc can throw

```

```noexcept``` Operator: 下面例子如果 function g 承诺不 throw, ```f``` is nonthrowing. 若 ```g``` has no exception specifier, or has an exception specifier that allows exceptions, then ```f``` might throw

```c++
noexcept(recoup(i)) 
// true if calling recoup can't throw, false otherwise

void f() noexcept(noexcept(g())); // f has same exception specifier as g

```


**5. Exception Specifications and Pointers, Virtuals, and Copy Control**

- 尽管```noexcept``` 不属于 function's type, 但 a function <span style="color:red">has an **exeception specification** 会影响function 使用</span>
    - 因为a **pointer to function** and the function to which that pointer points <span style="color:red">must have compatible specifications</span>. 
    - 如果声明a pointer 有<span style="background-color:#FFFF00">**nonthrowing exception specification**</span>. 我们可以用pointer only to point to similarly qualified functions(<span style="color:red">只能是nonthrowing的 function</span>)
    - 但是如果 declare <span style="color:red">a pointer 可能throw</span>, pointer 可以<span style="color:red">指向任何function</span>, 即使promise not to throw
- 如果<span style="color:red">**virtual function** promise not to throw, inherited virtual 必须都是not to throw</span>. 但是base 没有声明, derived function 可以promise not to throw
- 如果**all class members** operation and **base classess** promise not to throw(```noexcept),  那么 compiler synthesized 的copy-control member 是 ```noexcept```, 
  - 如果any function invoked by synthesized member can throw, 纳闷 sythesized member is ```noexcept(false)```
- 如果<span style="color:red">没有Provide **exception specification** for **destructor** we define, compiler 会synthesizes one for us</span>. 生成的speciaition 与compiler 假设synthesized 的destructor类型一样 

```c++
// both recoup and pf1 promise not to throw 

void (*pf1)(int) noexcept = recoup;

// ok: recoup won't throw; it doesn't matter that pf2 might 

void (*pf2)(int) = recoup;

pf1 = alloc; // error: alloc might throw but pf1 said it wouldn't 

pf2 = alloc; // ok: both pf2 and alloc might throw

```


```c++
class Base {
public:
    virtual double f1(double) noexcept; // doesn't throw virtual 
    
    int f2() noexcept(false); // can throw virtual 
    
    void f3(); // can throw
};
class Derived : public Base { 
public:
    double f1(double); // error: Base::f1 promises not to throw 
    
    int f2() noexcept(false); // ok: same specification as Base::f2 
    
    void f3() noexcept; // ok: Derived f3 is more restrictive

};
```


**6. Exception Class Hierarchies**

![](/img/post/C++/ExceptionHierarchies.png)

- ```exception``` 只定义 copy constructor, copy-assignment operator, a virtual destructor, and a virtual member named ```what```
  - ```what``` 返回 ```const char*``` that points to a null-terminated character array. <span style="color:red">guaranteed not to throw any exceptions.</span>
  - 因为```what``` is <span style="color:red">**virtual**</span>, 可以<span style="color:red">catch a **reference to base-type**</span> a call to the ```what``` function <span style="color:red">将execute the version to dynamic type</span> of exception object
-  ```exception```, ```bad_cast```, and ```bad_alloc``` classes also <span style="color:red">define a **default constructor**</span>. The ```runtime_error``` and ```logic_error``` classes do <span style="color:red">not have a default constructor</span> but do have constructors that take a **C-style character string** or a library **string** argument. Those arguments are intended to <span style="color:red">**give additional information** about the error</span>. 
- As the hierarchy becomes deeper, each layer becomes a more specific exception. 比如catch an object of type ```exception``` 只知道something wrong, 细节没有描述
- ```runttime_error```: 表示can be <span style="background-color:#FFFF00">detected only</span> when program **is** executing</span>  ```logic_error```:表示我们可以从程序代码中发现的错误

e.g. Bookstore application exception 

```c++
// hypothetical exception classes for a bookstore application 

class out_of_stock: public std::runtime_error { 
public:
    explicit out_of_stock(const std::string &s): std::runtime_error(s) { }
};
class isbn_mismatch: public std::logic_error { 
public:
    explicit isbn_mismatch(const std::string &s): std::logic_error(s) { }
    isbn_mismatch(const std::string &s,
            const std::string &lhs, const std::string &rhs): 
            std::logic_error(s), left(lhs), right(rhs) { }
    const std::string left, right;
};
```

比如, 为 ```Sales_data``` 定义了一个复合加法运算符,当检测两个 ```ISBN``` 编号不一致时, 抛出名为 ```isbn_mismatch``` 的异常.

```c++
// throws an exception if both objects do not refer to the same book 

Sales_data&
Sales_data::operator+=(const Sales_data& rhs)
{
    if (isbn() != rhs.isbn())
        throw isbn_mismatch("wrong isbns", isbn(), rhs.isbn());
    units_sold += rhs.units_sold; 
    revenue += rhs.revenue; 
    return *this;
}

// use the hypothetical bookstore exceptions

Sales_data item1, item2, sum;
while (cin >> item1 >> item2) { // read two transactions

    try {
        sum = item1 + item2; // calculate their sum
        // use sum
    } catch (const isbn_mismatch &e) {
        cerr << e.what() << ": left isbn(" << e.left
        << ") right isbn(" << e.right << ")" << endl;
    }
}
```















****











***
<br/> <br/> <br/>

## Include Guard

InC and C++, an **#include guard**, sometimes called a **macro guard**, **header guard** or **file guard**, is a particular construct used to avoid the problem of double inclusion when dealing with the include directive.避免double include 

<span style="background-color:#FFFF00">C preprocessor 把include 的file 复制its contents  into a copy of the source file known as translation unit.</span> The files included in this regard are generally header files() 包括了 functions, classes, structs的declarations. If certain C or C++ language constructs are defined twice, the resulting translation unit is invalid (<span style="background-color:#FFFF00">如果被defined两次, translation unit invalid</span>). #include guards prevent this erroneous construct from arising by the double inclusion mechanism.



The addition of <span style="background-color:#FFFF00">**#include guards**</span> to a header file is one way to make that file idempotent. Another construct to combat double inclusion is <span style="background-color:#FFFF00">**#pragma once**</span>, which is non-standard but nearly universally supported among C and C++ compilers.


**Double Inclusion**


File "grandparent.h"
```c++
struct foo {
    int member;
};

```


File "parent.h"

```c++
#include "grandparent.h"

```


File "child.c"

```c++
#include "grandparent.h"

#include "parent.h"

```

Result

```c++

struct foo {
    int member;
};
struct foo {
    int member;
};

```

Here, the file "child.c" has indirectly included two copies of the text in the header file "grandparent.h". This causes a <span style="color:red""> compilation error</span>, since the structure type foo will thus be defined twice. In C++, this would be called a violation of the [one definition rule](https://en.wikipedia.org/wiki/One_Definition_Rule)

**Use of #include guards**

In this section, the addition of #include guards, the C preprocessor preprocesses the header files, including and further preprocessing them recursively. This will result in a correct source file, 

File "grandparent.h"

```c++
#ifndef GRANDPARENT_H
#define GRANDPARENT_H

struct foo {
    int member;
};

#endif /* GRANDPARENT_H */

```

File "parent.h"

```c++
#include "grandparent.h"

```

File "child.c"

```c++
#include "grandparent.h"

#include "parent.h"

```

Result

```c++
struct foo {
    int member;
};
```


Here, the first inclusion of "grandparent.h" causes the macro GRANDPARENT_H to be defined. 在parent 之后, when "child.c" includes "grandparent.h" the second time, the #ifndef test returns false, and the preprocessor skips down to the #endif(<span style="background-color:#FFFF00"> 当第二次include parent.h, ifndef返回false, preprocessor skips to endif </span>), thus avoiding the second definition of struct foo. The program compiles correctly.


## Pointer 

#### Function Pointer

1. Unlike normal pointers, <span style="background-color:#FFFF00">a function pointer points to code</span>, not data. <span style="background-color:#FFFF00"> Typically function pointer stores the start of executable code </span>
2. Unlike normal pointers, <span style="background-color:#FFFF00"> we do not allocate de-allocate memory</span> using function pointers. 不用allocate de-allocate memory 
3. A function's name can also be used to get functions' address. For example, we can use address operator ```&``` or without it. ```void (*fucPtr)() = fun```  or ```void (*fucPtr)() = &fun```, 用不用```&```一样的
4. We can have array of function pointers. <span style="background-color:#FFFF00">必须function parameter 和 return type 都是一样的</span> 
5. Function pointer can be passed an **argument** and can also be **returned** from a function

Pointers to functions
```c++
// fcnPtr is a pointer to a function that takes no arguments and returns an integer

int (*fcnPtr)();
```
上面例子中, ```fcnPtr``` is a pointer to a function that has no parameters and returns an integer, <span style="background-color:#FFFF00">it can point to any function that matches this type</span>. 其中```()``` is necessary. as ```int *fcnPtr()```是<span style="color:red">a declaration for a function named fcnPtr that takes no parameters and returns a point to an integer</span>

**Const function pointer**
```
int (*const fcnPtr)();
```
<span style="background-color#FFFF00">如果put const before int ```const int (* fcnPtr)();```, 表示function being pointed to would return a const int</span>


<span style="background-color#FFFF00">Function pointers can be initialized with a function (and non-const function pointers can be assigned a function) </span>

```c++
int foo()
{
    return 5;
}
 
int goo()
{
    return 6;
}
 
int main()
{
    int (*fcnPtr)() = foo; // fcnPtr points to function foo
    
    fcnPtr = goo; // fcnPtr now points to function goo
 
    return 0;
}
```

One common mistake is to do this: ```fcnPtr = goo();```. This would actually <span style="background-color:#FFFF00">assign the return value from a call to function ```goo()``` to ```fcnPtr```</span>.  是assign funcion 返回的值
    
<span style="color:red">Note the type of the function pointer must match the type of the function </span>   
    
```c++
// function prototypes

int foo();
double goo();
int hoo(int x);
 
// function pointer assignments

int (*fcnPtr1)() = foo; // okay

int (*fcnPtr2)() = goo; // wrong -- return types don't match!

double (*fcnPtr4)() = goo; // okay

fcnPtr1 = hoo; // wrong -- fcnPtr1 has no parameters, but hoo() does

int (*fcnPtr3)(int) = hoo; // okay

```
    
**Calling a function using a function pointer**

<span style="background-color:#FFFF00"> Explicit dereference </span>
```c++
int foo(int x)
{
    return x;
}
 
int main()
{
    int (*fcnPtr)(int) = foo; // assign fcnPtr to function foo

    /* The above line is equivalent of following two 
       int (*fcnPtr)(int); 
       fun_ptr = &fun;  
    */
    
    (*fcnPtr)(5); // call function foo(5) through fcnPtr.

    fcnPtr(5); // call function foo(5) through fcnPtr.
    
    int (*fcnPtr2)() = &foo;//assign pointer to function

    (*fcnPtr2)(5); // call function foo(5) through fcnPtr.

    fcnPtr2(5); // call function foo(5) through fcnPtr.

    return 0;
}
```

<span style="background-color:#FFFF00"> Implicit dereference </span>: 就像normal function call, since normal function names are pointers to functions anyway!
```c++
int foo(int x)
{
    return x;
}
 
int main()
{
    int (*fcnPtr)(int) = foo; // assign fcnPtr to function foo
    
    fcnPtr(5); // call function foo(5) through fcnPtr.
 
    return 0;
}
```

<span style="background-color:#FFFF00">需要注意 **Default parameters won't work for functions called through function pointers**: 因为default parameters are resolved at compiled time(意味着if you don't supply an argument for a defaulted parameter, the compiler substitues one when code is compiled), 但是function pointers are resolved at run-time</span>. Consequently, default parameters cannot be resolved when making a function call with a function pointer. 你不得不pass in vlaues for any defaulted parameteres.

Array of function pointers

```c++
void add(int a, int b){
    cout << "a + b  = "<<a+b<<endl;
}

void subtract(int a, int b){
    cout << "a - b = "<<a+b<<endl;
}

void multiply(int a, int b){
    cout << "a * b = "<<a*b<<endl;
}


int main()
{
    const int r = 3;
    void (* FucPtrArray[])(int, int) = {add, subtract, multiply};
    FucPtrArray[2](5,3);
    // It's the same as (*FucPtrArray[2])(5,3);

}
```

**Passing function as arguments to other functions**

Functions used as arguments to another function are called **callback functions** 比如让用户选择自己的sorting algorithm 在selection sort algorithm,
```c++
bool (*comparisonFcn)(int, int);//因为compare tow interters and return a boolean value

```

```c++
#include <algorithm> // for std::swap, use <utility> instead if C++11

#include <iostream>
 
// Note our user-defined comparison is the third parameter

void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))
{
    for (int startIndex = 0; startIndex < size; ++startIndex)
    {
        int bestIndex = startIndex;
        for (int currentIndex = startIndex + 1; currentIndex < size; ++currentIndex)
        {
            if (comparisonFcn(array[bestIndex], array[currentIndex])) // COMPARISON DONE HERE

                bestIndex = currentIndex;
        }
 
        // Swap our start element with our smallest/largest element
        
        std::swap(array[startIndex], array[bestIndex]);
    }
}
 
// Here is a comparison function that sorts in ascending order

bool ascending(int x, int y)
{
    return x > y; // swap if the first element is greater than the second
    
}

bool evensFirst(int x, int y)
{
	// if x is even and y is odd, x goes first (no swap needed)
    
	if ((x % 2 == 0) && !(y % 2 == 0))
		return false;
 
	// if x is odd and y is even, y goes first (swap needed)
    
	if (!(x % 2 == 0) && (y % 2 == 0))
		return true;
 
        // otherwise sort in ascending order
        
	return ascending(x, y);
}
 
// Here is a comparison function that sorts in descending order

bool descending(int x, int y)
{
    return x < y; // swap if the second element is greater than the first
    
}
 
 
int main()
{
    int array[9] = { 3, 7, 9, 5, 6, 1, 8, 2, 4 };
 
    // Sort the array in descending order using the descending() function
    
    selectionSort(array, 9, descending);
    printArray(array, 9);
    //9 8 7 6 5 4 3 2 1

 
    // Sort the array in ascending order using the ascending() function
    
    selectionSort(array, 9, ascending);
    printArray(array, 9); 
    //1 2 3 4 5 6 7 8 9
    
    selectionSort(array, 9, evensFirst);
    printArray(array, 9);
    //2 4 6 8 1 3 5 7 9
    
    return 0;
}
```

<span style="background-color:#FFFF00"> Note: If a function parameter is of a function type, it will be converted to a pointer to the function type</span>. It means 
```c++
void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int))
```

is equivalently written as 
```c++
void selectionSort(int *array, int size, bool comparisonFcn(int, int))
```

<span style="background-color:#FFFF00"> This only works for function parameters, not stand-alone function pointers </span>


**Providing default functions**: 下面例子, as long as user calls selectionSort normally(不是通过function pointer), the comparisonFcn parameter will default to ascending. 

```c++
// Default the sort to ascending sort

void selectionSort(int *array, int size, bool (*comparisonFcn)(int, int) = ascending);
```

**Making function pointers prettier with typedef or type aliases**: the syntax for pointers to functions is ugly. However, typedefs can be used to make pointers to functions look more like regular variables:

```c++
typedef bool (*validateFcn)(int, int);
```
This defines a typedef called “validateFcn” that is a pointer to a function that takes two ints and returns a bool.

Now instead of doing this 

```c++
bool validate(int x, int y, bool (*fcnPtr)(int, int)); // ugly

```

You can do this 

```c++
bool validate(int x, int y, validateFcn pfcn) // clean

```

**Using std::function in C++11**: Introduced in C++11, an alternate method of defining and storing function pointers is to use ```std::function```, which is part of the standard library ```<functional>``` header. Both the return type and parameters go inside angled brackets, with the parameters inside parenthesis. If there are no parameters, the parentheses can be left empty. 


    
```c++
#include <functional>

bool validate(int x, int y, std::function<bool(int, int)> fcn); 
// std::function method that returns a bool and takes two int parameters

#include <functional>
#include <iostream>
 
int foo()
{
    return 5;
}
 
int goo()
{
    return 6;
}
 
int main()
{
    std::function<int()> fcnPtr = foo; // declare function pointer that returns an int and takes no parameters
    
    fcnPtr = goo; // fcnPtr now points to function goo
    
    std::cout << fcnPtr(); // call the function just like normal
 
 
    return 0;
}
```

**Type inference for function pointers(Auto)**: the auto keyword can also infer the type of a function pointer.<span style="color:red">The downside is, of course, that all of the details about the function’s parameters types and return type are hidden(**parameters types 和 return types 都是hidden**), so it’s easier to make a mistake when making a call with the function, or using its return value</span>. Unfortunately, type inference won’t work for function parameters (even if they have default values(Auto 不能传入用于function parameters)

```c++
#include <iostream>
 
int foo(int x)
{
	return x;
}
 
int main()
{
	auto fcnPtr = foo;
	std::cout << fcnPtr(5);
 
	return 0;
}
```

<span style="background-color:#FFFF00"> Because the native syntax to declare function pointers is ugly and error prone, we recommend you use typedefs (or in C++11, std::function).</span>

