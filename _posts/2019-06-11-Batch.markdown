---
layout:     post
title:      "Batch - 笔记"
subtitle:   "Batch Script learning note "
date:       2019-06-11 20:00:00
author:     "Becks"
header-img: "img/post-bg2.jpg"
catalog:    true
tags:
    - Batch
    - 学习笔记
---

Internal or external command are buildin to cmd.exe command. Batch let you run program within the shell. cmd.exe inside C:/Windows/System32 <br/>
如果直接双击 batch script without pause, it 可能闪退 without letting you see the output

## command

```shell

dir #show everything inside the folder 

ver #show the version of Microsoft Windows

cls #clean cmd 

pause #wait to press input 


```

## Data Type, varibles

Integer: 1 0 -1 -30 9000 <br/>
Character:  a  b c d e <br/>
String:  "Hey! My name is" (sometimes, we use 双引号，有时候不用双引号) <br/> 



```shell
set varname=Howdy   #把varname 等于 Howdy

%varname% #显示'Howdy' is not recognized as a internal or external command

set varname="Howdy" #加quotation mark
echo %varname% #显示'"Howdy"'
#even though it is string, it still interpret quotation mark which we don't want that

```

## Environment Variables

windows/batch has some stored variables, we can access this variables. They are called environment variables because these are variables stored in the environment  

<span style="background-color: #FFFF00">注:</span> 假如我在prompt 中运行batch script(test.bat)， batch script中有set aab=Hello. 即使我run 完script, 只要不关闭prompt, aab会一直存在cmd 中, echo %aab% 会打印hello


```shell
set #显示all the variables whindows track of 
echo %%COMPUTERNAME% #显示 电脑名字

set varname=Howdy 
set #打出的environment variables 显示varname=Howdy
set var #打出所有environment variables starting with var
set USER #打出所有environment variables starting with USER
```



## String Concatenation

```shell

set string=becks 
set string+=wu #用+= string 依旧是becks
echo %string% #打印becks
#实际上，又建立了一个新的variable 叫string+
echo %string+% #打印wu


set string=%string% wu #string 现在是 becks wu (有空格)
%string% #显示'becks' is not recognized as an internal or external command
echo %string% #显示becks wu

```

## Echo

```shell

echo Hello There #会打印出Hello There
echo "Hello There" #会打印出"Hello There"
echo #打印 echo is on
echo. #打印出一个konghang

```


## Command Argument, Help

```shell

dir Desktop #显示Desktop的dir

vol ##显示C盘的volume Serial Number, default is C Disk
vol D:  #显示D盘的volume Serial Number

help #show every command

help dir #give dir 的help 所有可以用的flag 
dir /? #与help dir 效果一样

```

## @Symbol

@ 作用:  stop command from displaying within the prompt 在batch script中

```shell

@echo Hello Wolrd
echo Hello World
#上面两个作用一样

#比如文件中不想打印出ver
@ver, 只显示ver的结果，不会先打印ver, 再显示ver在cmd中，只显示ver的结果
@dir, 只显示dir的结果，不会打印dir 再显示结果在cmd中


```

## Echo off

如果script用@echo off，不会display everything inside the batch, 只显示output

```shell
help echo #显示ECHO 可以 ON | OFF 
echo /? #与上面作用一样 


echo #显示ECHO is on. 

echo off #stop display prompty

echo on #turn prompt back on 

```



## Escape Characters

%% scape %, ^<, ^> escape <>, ^^ escape ^

```shell
@echo off

set variable=PROBLEM

echo This is a  %%variable%% #显示This is a %variable%

#显示 >  < ^
echo ^<html^> #显示<html> 用^ escape <>

echo ^^ #显示^

```


## Math

SET /A 表示数学

![](/img/post/batch/math.png)

注: 在prompt 中可以用 % (mod), 但在script中，对于mod需要 % escape %

```shell

@echo off

set sum=1+1 #把1+1设置成了string
echo The sum is %sum% #This sum is 1+1

#可以用help 
set /?

set /a sum=1+1
echo The sum is %sum% #This sum is 2

set /a sum=5 * 2 
echo The multiplier is %sum% #This multiplier is 10

#下面的在prompt中可以用
set /a sum=10 / 2 
echo The divider is %sum% #This divider is 5

set /a mod=10%3
echo The module is %sum% #This module is 1

#在script中

set /a mod=10 %% 3
echo The module is %sum% #This module is 1

```


## Input

set /p 读取input from user 

```shell

@echo off
set /p input=Please enter your name!
echo Your name is %name%; 

#换行输入
echo Please enter your name! #第一行显示 Please enter your name!，第二行输入
set /p input=
echo Your name is %name%; 


```


## Label, Goto


batch won't interpret when label is not starting position of each line

```shell
#echo off

:another 

cls #belong to another
ver #belong to another

:label #everything below label is part of label
#label is belong to another

vol #belong to label 

```


Goto 

```shell
@echo fof

echo This is the very beginning of the program!

goto :start #跳到start, print start, middle, end
goto :middle #跳到start, print middle, end
goto :end #跳到start, print  end


:start 
echo This is the START of the program!
#goto :end 跳到：end, 跳过middle

:middle 
echo This is the MIDDLE of the program!

:end 
echo This is the end of the program!

```



## Comment

rem 会读取这一行的内容，slowdown your execution of program, 
:: comment， 但这也是label, 因为是label，必须是beginning of line

```shell

@echo off 

ehco This is a script

rem This is a comment #rem 会读取这一行的内容 即使表示comment，slowdown your execution
help rem #显示REM [ comment]

:: This is comment/label! #comments, 但也是labels, 不会打印出来


```



## Function

**%~1** as the function first input <br/>
**goto** : eof, finish current job, if main exit, if function (label), return to main <br/>
**endlocal**: delete all variable being seen from setlocal <br/>
**Group command &** 在function 结尾 endlocal & set /a x=%x% + 1 , x会更改main 中的x <br/>
**pass value to function** default pass to function is string, 如果想pass value 加上是百分号 %y% <br/>


```shell

@echo off 

goto :main #jump to main function 


:function 
    echo This is another function
goto :eof


:main
    echo Main function is being called!
    call :function  #call another function
    echo End of main function
    echo End of program
goto :eof #end of file, goto eof 会exit

```


Function Arguments
```shell

@echo off 

goto :main #jump to main function 


:say_something 
    echo I am saying %~1  and %~2
goto :eof

:main
    echo Main function is being called!
    call :say_something tiger boat #call another function, tiger is string, boat is string
goto :eof #end of file, goto eof 会exit

```

可以更改function的%~1 值，更改外面的variable

```shell
@echo off 
goto :main #jump to main function 


:function_return 
    echo    Changing a variable
    set variable=Value 
goto :eof


:change_variable
    echo    Changing a variable
    set %~1=Lunch
goto :eof


:main
    echo Main function is being called!

    echo %variable% #显示Echo is off, 因为没有variable
    call :function_return
    eco The variable  is %variable%  #显示The variable new value is Value

    set new_var=Dinner
    call :change_variable new_var
    eco The variable is %new_var%  #显示The variable new value is Lunch

goto :eof #end of file, goto eof 会exit


```

local variable: setlocal, endlocal

```shell
@echo off

:local_var
setlocal 
    echo  Func says %p% #显示The says is 4
    set x=30 
    echo Func says x is %x %#显示Func says X is 30
endlocal
goto :eof

:main
setlocal
    echo Main function is being called!
    set p=4
    echo Main says p is %p% #显示Main says P is 4

    call :local_var
    echo Main says x is %x% #显示Main says X is (因为x在local_var中式local)

endlocal
goto :eof 

```

script local scope: <span style="background-color: #FFFF00">script不设置setlocal(不管是main 还是function, function 不设local，也会存进system_variable中), 只要不关闭prompt,script中 set的variable 设置的会在system_variable中 </span>

```shell
@echo off
goto :main

:main 
    set global_var=exisiting
goto :eof 

#上面的file run了之后，global_var会存在system variable中

:main 
setlocal
    set global_var=exisiting
endlocal
goto :eof 

```

return local, Group command & : 在function 结尾endlocal & set /a x=%x% + 1 , x会更改main 中的x


```shell
@echo off
goto :main

:add_one 
setlocal
    echo Performing ADD ONE on x
endlocal & set /a x=%x% + 1   #group command, 先执行endlocal, 再执行x = x+1
goto :eof 

:main 
setlocal
    echo Main function is running
    echo Setting X to 1 #显示Setting X to 1
    set /a x=1
    call :add_one
    echo The value of X is now %x% #显示The value of X to 2

endlocal #x 不会存进system 当run 完code， 因为endlocal 删除了 x, 即使add_one set不是 local 
goto :eof 

```


```shell
@echo off
goto :main

:add_one 
setlocal
    echo Running 'add_one'
endlocal & set /a %~1=%~2 + 1   #group command, 先执行endlocal, 再执行x = x+1
goto :eof 

:main 
setlocal
    set /a x = 1
    set /a y = 50

    echo Created variable X and set it to %x%

    call: add_one  y   %y% #pass y as first variable, pass value of y as second variable
    #如果pass y function 认为是string, 

    echo The value of y is %y% #显示the value of x is 51

endlocal #x 不会存进system 当run 完code， 因为endlocal 删除了 x, 即使add_one set不是 local 
goto :eof 

```




## If 

equ : ==   <br/>
neq : != <br/>
lss : < less than <br/>
leq : <= less than or equal <br/>
gtr : > greater than <br/>
geq : <= greater than or equal <br/>

if statement, 不用parathesis 来include condition 表示group command 

 <span style="background-color: #FFFF00">else 需要在）的同一行接着，不能换在)下一个行 加else, 否则会报错</span>

```shell
#echo off 

goto :main 


:main 
setlocal
    set /a food=10
    set /a needed_food=10

    if %food%==%needed_food% ( #beginning of if 
        echo We have enough food
    ) else  (
        echo We do not have enough food!
    )



    if %food% equ %needed_food% ( #beginning of if 
        echo We have enough food
    ) #end of if

    if not %food%==%needed_food% ( #beginning of if 
        echo We do not have enough food
    ) #end of if

    if %food% neq %needed_food% ( #beginning of if 
        echo We do not have enough food
    ) #end of if


    if %food% leq %needed_food% ( #beginning of if 
        echo We  have enough food
    ) #end of if

    if %food% gtr %needed_food% ( #beginning of if 
        echo We more than enough food
    ) #end of if


endlocal
goto :eof

```





## Nesting


```shell
@echo off

goto :main 

:main 
setlocal
    set /a food=50
    set /a needed_food=50
    set /a people=10

    set /a rations=5
    set /a all_food=%people%*%rations%

    if %food% geq %needed_food%(
        echo We have a good amount of food!

        if %all_food% leq %food% (
            echo We have enough food for all %people% peoples!
        )else (
            echo We do not have enough food for all these people!
        )
    )else (
        echo We do not have enough food!
    )

endlocal
goto :eof

```





## Delayed Variable Expression

在if statement 括号里，括号里是group command, in fact they are only one command. 如果用普通set 加上 %% 会报错 显示unexpected, 因为是one command, set 会在所有command 结束后才create variable，但是我们需要create variable right away to see if condition，<span style="background-color: #FFFF00">需要加上setlocal  enabledelayedexpension</span>, 当call variable时候，需要用！, e.g. !food！, 对于echo 感叹号, <span style="background-color: #FFFF00">需要escape，e.g. Hello World ^^!  </span>



```shell
@echo off
setlocal  enabledelayedexpension
goto :main

:main
setlocal

    echo Hello World ^^! #需要^^ escape !, 打出 Hello World!
    echo "Hello World!" #打出 "Hello World!"

    set /a food=50
    set /a needed_food=50
    set /a people=10

    set /a rations=5
   

    if !food! geq !needed_food!(
        echo We have a good amount of food!

        set /a all_food=%people%*%rations%

        echo !all_food!

        if !all_food! leq !food! (
            echo We have enough food for all !people! peoples!
        )else (
            echo We do not have enough food for all these people!
        )
    )else (
        echo We do not have enough food!
    )
endlocal
goto :eof

```



## While

Batch 不支持while, 需要用label + goto

```shell
@echo off 

setlocal enabledelayedexpansion 

goto :main 

:main 
setlocal

    set /a counter=0
    set /a limit=10

    :loop
    if !counter! < lss !limit! (
        echo !counter!
        sete /a counter=!counter!+1
        goto :loop
    )
    
    echo. 

endlocal
goto :eof

```


## For Loop

/l: %%g in (start, step, end) <br/>
/d : directory



#### basic

in batch script, specify %%variable instead of %variable. set () 中用space 分开表示不同的需要loop 的是variable, 如果用引号就表是set中只有一个variable需要loop 的

For Loop Number Syntax: for /l %%g in (start, step, end) . end 是include的

```shell
@echo off
setlocal enabledelayedexpansion

goto :main 

:main 
setlocal 

    set string=Heloo world^^!
    echo !string!
    set /a test=3

    for %%g in  (1 2 3 4 5) do ( #需要%% 来表示variable, 
        echo %%g
        if !test! equ %%a (
            echo !test! in %%g
        )
    )

    for %%g in  (a b c d e) do ( #需要%% 来表示variable, 
        echo %%g
        if !test! equ %%a (
            echo !test! in %%g
        )
    )

    for %%g in  (This is a block of words) do ( #需要%% 来表示variable, space分开不同的string
        echo %%g #打印第一行This, 第二行is, 第三行 a ....
        if !test! equ %%a (
            echo !test! in %%g
        )
    )

    for %%g in  ("This is a block of words") do ( 
        echo %%g #打印第一行"This is a block of words" 有引号的
        if !test! equ %%a (
            echo !test! in %%g
        )
    )

    for /l %%g in  (1, 1, 20) do (  # /l   l-type, start, step, end, (1, 1, 20), 从1到20 每一次增加1
        echo %%g 
    )

    for /l %%g in  (0, 5, 20) do (  # 0 -> 5 -> 10 -> 15 -> 20
        echo %%g 
    )

endlocal
goto :eof

```


#### directory, file

/d: directory, 不能显示file，只能显示directory<br/>
\* : wildcard, dispaly every file <br/>
不能用. (表示现在的directory)，需要用wildcard \*

```shell
@echo off
setlocal enabledelayedexpansion

goto :main 

:main 
setlocal 

    set string=Heloo world^^!
    echo !string!
    set /a test=3

    for /d %%g in  (*) do ( #/d display directory, * wildcard
        echo %%g
    )

    for /d %%g in  (D*) do ( #/d display directory, D* any folder start with D
        echo %%g
    )

    for /d %%g in  (D*s) do ( #/d display directory, D*o any folder start with D and end with s
        echo %%g
    )

    for /d %%g in  ( . ) do ( #. 表示现在directory, 不会显示任何东西，因为需要用* wildcard
        echo %%g
    )




endlocal
goto :eof

```

## Directory Permission


```shell

chmod u-w dir #remove user write permission for directory
#cd 进dir, touch f.txt 显示permission denied

chmod u-r dir #remove read access from user
#cd dir 显示 permission denied

chmod u-x dir #remove execute access from user 
#cd dir 或者 ls dir/ 都显示permission denied


```


## Octal & Numerical Permissions

![](/img/post/linux/pic6.png)

![](/img/post/linux/pic7.png)

比如你想给user access read write and x, you need to give number as 7(binary start from right to left for each group)

```shell

chmod 755 file.txt #give user read, write execute(7), give both group and othe group read and execute access

```





## Bash Script

Script: txt file contain sequence of command

```shell

nano myscript.sh #open editor 

#! /bin/bash  #需要contain location of bash
which bash #会告诉哪里有bash，give location 

./myscript.sh #./ 是去run bash script
#显示permission denied 因为file created not have execute permission 

#先给permission 
chmod +x myscript.sh #give permission for all groups
./myscript.sh #显示会成功


```

![](/img/post/linux/pic8.png)

![](/img/post/linux/bash.png)



## which & what

which: where software/command located

what: display short manual page description

```shell
#which ls #give location where ls command located

which firefox # location of bash
which bash # location of bash

whatis ls # short description, to know what ls doing command
whatis grep #short description, to know what is grep command

```



## useradd

create user

```shell

useradd the_name_of_user #syntax

sudo useradd mark -m -s /bin/bash -g users -c "my comment"
#-m:  create default home directory for this user
#-s /bin/bash allow usesr to use shell
#-g assign group, default group is users
#-c "my comment" provide comment to user 
#-G assign/give user defined group
#sudo: because you don't want anybody create user, only root can create user

sudo passwd mark  #change password for user


```



## userdel



```shell

sudo userdel mark #delete user mark (username, password, data), not delete home directory for user

sudo userdel -r mark #delete user (home directory, username, password, data)

sudo -r /home/mark/  #remove all the data from user

```
![](/img/post/linux/userdel.png)



## groups, groupadd, groupdel

group show which group is currently user connected to

```shell
groups #show which group is currently user connected to

cat /etc/group #show all the group in your system,  group <-> user connected to 

sudo groupadd Java #add newgroup in system
sudo groupdel Java #delete existing group

#-a add user to group, -d remove user from group
sudo gpasswd -a mark Java # add mark to the Java group
sudo gpasswd -d mark Java #remove user from Group


```




## bashrc

bashrc is a script executed whenever a new terminal session start in interactive mode

some linux system， .bashrc file exist when a new terminal session start. Some not

Bashrc file is used for setting up environment variable such as Java. When use git, which repo you checked or cloned, use Bashrc

```shell

ls -a #在home directory ls -a 可以看见有.bashrc

nano .bashrc #查看.bashrc
gedit .bashrc #查看 .bashrc

```

可以修改 .bashrc file 比如加上alias ls='ls --color=auto -l', 之后open new terminal, 输入ls, 显示long list of ls 

![](/img/post/linux/bashrc.png)


![](/img/post/linux/bashrc2.png)

## du, df, free

View Resources




```shell
df #the amount of disk space being used by your file system
df -h #the human readable output, 显示多少G, M, k

du #estimate and display the disk space used by files in details
du -h #human readable format
du -sh #-s summary 只给你现在所在directory 文件所占的大小
sudo du -sh #用sudo 原因是因为可能有的file permission denied 需要用sudo 
du -sh /etc/ #show summary used space by etc folder

free #display the total amount free and used physical and swap memory in the system as well as buffer in the kernel
free -b  #-b btye, -k KB, -m MB, -G GB, -T TB

```


## watch

run scripts for command at a regular interval or repeatedly


```shell

watch free -m #可以看见几秒会更新一次
Ctrl + C #exit watch command
watch -n 1 free -m #让free -m command run every 1 second
watch -n 0,5 free -m #让free -m command run every 0.5 second


```

![](/img/post/linux/watch.png)

## head tail

Head: output the first part of the file 
Tail: output the last part of the file


```shell
head log.txt #show first 10 line of file 
tail log.txt #show last 10 line of file 


head -n3 log.txt #show first 3 lines of file
head -3 log.txt #跟上面一样

tail -n3 log.txt #show last 3 lines of file
tail -3 log.txt #跟上面一样

tail -f log.txt #output last 10 lines of file. watch the file, whenever file change, will show last 10 lines of code
ctrl + C #exit 
head  log.txt kern.log #先print 10 lines of log.txt 再print 10 lines of kern.log

head -3 log.txt kern.log #先print 3 lines of log.txt 再print 3 lines of kern.log


```



## find



```shell

find location -name file_name #syntax

find /home/ -name test.sh #-name search by name, return directory 
find /home/dir1 -name test.* #search in /home/dir1 folder by name, any file start with test. 可以是.txt, .sh
find /home/dir1 -name *.txt #search any file extension is txt
find / -name dmesg #search in the root directory, 也许有permission error 因为有些directory 不允许access
sudo find / -name dmesg 

find /home  -mtime -1  #look at the file created 1 days before, 也可以用加号，+1, + 2


```



## wc

wc: world count, print a count of lines, words and characters for each files


```shell

wc test.txt #打出#lines, #words, #characters
wc -c test.txt #只打出#characters
wc -l test.txt #只打出#lines
wc -w test.txt #只打出#words

wc -L test.txt #只给出number of character in longest line


```

1, 6, 42: 1 number of line, 6 number of words, 42 number of characters

![](/img/post/linux/wc.png)


## cal

show conventially formatted calendar on your command line

```shell

cal #显示calendar, weekday on the top
ncal  #显示calendar, weekday on the left 
cal 2016 #显示2016的calendar
cal 2 2016 #显示2016年 2月 calendar
cal -3 #give you current month, previous month and next month calendar
#default 是 -1, 比如cal, 等于cal -1
```



## date

used to print out and change system date and time information

```shell

date #print 现在系统的时间

date -s "11/20/2003 12:48:00" #设置system time 为 11/20/2003 12:48:00

date +%d%h%y #显示13Jan17

date +%d/%h/%y #显示13-Jan-17

man date #可以显示详细的date format的格式


date "+Date: %m/%d/y%n" #显示01/13/17 %n 是空行线



```
设置时间格式
![](/img/post/linux/date.png)


## Run Multiple Terminal(; && || )



```shell

#; sequence matter 
ls; pwd #先run ls 再显示pwd
date; cal ; pwd #先run date, 再run cal, 再pwd

#如果有中间一个command 是错的
date; CAL;  pwd #date, pwd run 成功了, CAL 会显示command not found 

#&& sequence matter, 顺序一个接一个
ls && pwd && date && cal #先run ls, 再pwd, 再date, 再cal

ls && CAL && pwd #先run ls, CAL error, not run pwd

ls || pwd #如果第一个command 成功了，不会run 第二个command

CAL || pwd #CAL command failure, pwd 会被run

```

<span style="background-color: #FFFF00">Difference</span>: ; run every command regardless success/failure of each command. && 如果中间的failure, does not go to the next command


## apt-get

apt-get(urbantu): install, uninstall, update packages. apt: advance packaging tool

对于centos: 用yum, dnf instead of apt-get 

```shell

sudo apt-get update #resync your local package file to the server package file, update all the packages

java -version #check if java installed, and if so check version
php5 -version #check if php installed, 如果没有install 会给出install的hint

sudo apt-get install php5 #安装首先what is required extra dependency to install php5, 也会显示多少space required to install
php5 -v #显示php5 version

sudo apt-get remove php5 #remove php5
sudo apt-get remove --purge php5 #remove all configuration file related to php5
sudo apt-get autoremove  #auto remove the dependency which required for the package(php5) and no longer needed for other packages



```




## ifconfig

ifconfig: interface configuration: used to view and change network interface configuration on your system

```shell
ifconfig #show you some output

ifconfig eth0 #only show eth0 interface

#up, down to disable internet connection 
sudo ifconfig eth0 down #internet connection will be down

sudo ifconfig eth0 up #enable internet 

```

ethO: wired internet cable  <br/>
WLAN0: wireless internet connection <br/>
0: is the first internet interface. 如果有multiple internet interface, 显示eth1, or WLAN2
l0: loop back interface. An interface that system use to communcate to excel


## tar

tar: Tape Archive, compress and extract file 


```shell

tar -cvf test.tar test #cvf: create verb, f filename, 把test folder compress 成命名为test tar 压缩文件
tar -xvf test.tar #xvf x: extract v verb, f filename,  把test.tar extract 压缩文件

#有时候用 tar.gz  gz stands for gzip format

tar -cvfz test.tar.gz f.txt #z 表示生成gz file, z必须在c flag 之后, 压缩文件成tar.gz 
tar -xvfz test.tar.gz f.txt #解压 gz 文件

man tar > tar.txt #把tar 的man output 到tar.txt 中

```



## grep

grep: global regular expression print. can be used to search pattern / word in a text file or a number of text file with grep command

```shell

#
man tar > file.txt 

grep "options" file.txt #keyword I want to search and file name, 
#grep 是case sensitive的, 上面的search options 不会search Options,

grep -i "options" file.txt #make search not case sensitive, 也会search Options

grep -n "options" file.txt #在file 中search并显示file.txt的options, 并显示在哪行

grep -n "Some options" file.txt #在file 中search并显示Some options


#used in multiple files
grep -n "Some options" f1.txt, f2.txt f3.txt f4.txt #在多个file 中search并显示Some options
grep -n "Some options" * #在现在folder中的所有file search并显示Some options 的行

grep -nv "Some options" f1.txt #显示f1.txt 不包含Some options的行

grep -help #显示有的flag, options 用grep command

```
![](/img/post/linux/grep.png)


## netstat

netstat is to display network connection, routing tables and a number of network interfaces, and view network protocal states 

```shell

netstat -a #show all connections which are available on your system whether it is TCP or UDP or UNIX connection,
#上面aslo display the status if it connected, listening, or established

# | means after | whatever second command is used will implement the output of the first command  
netstat -a | less #use the output of netstat to display with less command 

netstat -at | less #-t means just show the TCP connection

netstat -au | less #-u means just show the UDP connection

netstat -l | less #-l means just show listenning state

netstat  -lt | less #-lt means just show listening and TCP connection

netstat -lu | less #-lu means just show listenning and UDP connection

netstat -s | less  #-s show the statistic of connection, you can see which type of connection it is and properties of the packet what is happening

netstat -st | less #-st show the statistic of TCP connection

netstat -su | less #-su show the statistic of UDP connection 

netstat -pt | less #-pt show PID of TCP connection 

netstat -px | less #-px show PID of UNIX connection

netstat -n  | less #-n show the numeric port of connection

netstat -c # show the connection continuously, it refresh by itself

netstat -ie   #-ie extended interface, it is the same output as ifconfig 

netstat -an | grep ":80"  #-an show numeric port of all conection and search which port has :80 

```





